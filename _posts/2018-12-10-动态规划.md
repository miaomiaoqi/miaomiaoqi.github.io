---
layout: post
title:  "动态规划"
date:   2018-12-10 11:27:41
categories: Algorithm
tags: 动态规划
author: miaoqi
---

* content
{:toc}
## 题目一

* 有一座高度是**10**级台阶的楼梯，从下往上走，每跨一步只能向上**1**级或者**2**级台阶。要求用程序来求出一共有多少种走法。

	比如，每次走1级台阶，一共走10步，这是其中一种走法。我们可以简写成 1,1,1,1,1,1,1,1,1,1。

	再比如，每次走2级台阶，一共走5步，这是另一种走法。我们可以简写成 2,2,2,2,2。

## 动态规划

* 动态规划的英文名是Dynamic Programming, 是一种分阶段求解决策问题的数学思想. 它不止用于编程领域, 也应用于管理学, 经济学, 生物学.

	总结一句话就是**大事化小, 小事化了**

* 以刚才的题目来说, 假设只差最后一步就走到第10级台阶了, 这时候会有几种情况呢?

	答案是两种情况, 因为每一步只许走1级或是2级. 第一种是从9级走到10级, 第二种是从8级走到10级

* 接下来引出一个新的问题, 如果我们已知0到9级台阶走法有X种, 0到8级台阶有Y中走法, 那么0到10级台阶的走法有多少种?

	10级台阶的走法可以根据最后一步的不同而分为两部分, 第一部分的最后一步是从9级到10级, 这部分的走法数量和9级台阶的走法数量是相等的, 也就是X

	第二部分是最后一步从8级到10级, 这部分的走法数量和8级台阶的走法数量是相等的, 也就是Y.

	这两部分相加, 总的走法数量就是X + Y

	![http://www.miaomiaoqi.cn/images/algorithm/dynamic_1.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic_1.png)

	为了方便表达, 我们把10级台阶的走法数量简写为F(10), 此时F(10) = F(9) + F(8), 那么如何计算F(9)和F(8)呢?

	利用刚才的思路可以很容易推断出:

	F(9) = F(8) + F(7), F(8) = F(7) + F(6)

	**我们正在把一个复杂分阶段进行简化, 逐步简化成简单问题, 这就是动态规划的思想.**

	当只有1级台阶和2级台阶的时候, 有几种走法呢?显然分别是1和2, 由此可以归纳出如下的公式:

	* F(1) = 1

		F(2) = 2
		F(n) = F(n - 1) + F(n - 2) (n >= 3)

	**动态规划当中包含了三个重要的概念**

	* 最优子结构

		刚才我们分析出F(10) = F(9) + F(8), 因此F(9)和F(8)是F(10)的最**优子结构**

	* 边界

		当只有1级台阶或2级台阶时, 我们可以直接得出结果, 无需继续简化. 我们称F(1)和F(2)是问题的**边界**, 如果一个问题没有边界, 将永远无法得到有限的结果

	* 状态转移公式

		F(n) = F(n - 1) + F(n - 2) 是阶段与阶段之间的**状态转移方程**, 这是动态规划的核心, 决定了问题每一个阶段和下一阶段的关系

	以上是动态规划的前半部分: **问题建模**, 接下来是真正麻烦的阶段: **问题求解**

	* 方法一: 递归求解

		要计算出F(N), 首先要得到F(N - 1)和F(N - 2)的值. 要计算F(N - 1)就要得到F(N - 2)和F(N - 3)的值...以此类推, 可以归纳成下面的图

		![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_2.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_2.png)

		这就是一颗二叉树, 树的节点个数就是我们的递归方法所需要计算的次数.

		不难看出这颗树的高度是N - 1, 节点个数接近2的N - 1次方. 所以方法的时间复杂度可以近似的看作是O(2 ^ N)

		上述图中存在大量的重复计算的值.

		![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_3.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_3.png)

		可以使用哈希表每次把不同参数的计算结果存入哈希. 当遇到相同参数时, 再从哈希表中取出, 就不用重复计算了, 这种方式叫做**备忘录算法**

	* 方法二: 备忘录算法

		从F(1)到F(N)一共有N个不同的输入, 在哈希表里存了N - 2个结果, 抛出1和2的情况, 所以时间复杂度和空间复杂度都是O(N)

	虽然我们的性能已经得到了明显的优化, 但这还不是真正的动态规划, 时间复杂度已经不能再小了, 在空间复杂度上还能不能在缩小了呢?

	**我们不妨把思路逆转过来**, 我们一定要对F(N)自顶向下做递归运算吗?可不可以自底向上, 用迭代的方式推导出结果?

	* 方法三: 动态规划求解

		![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_4.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_4.png)

		表格的第一行代表了楼梯台阶的数量, 第二行代表了若干级台阶对应的走法数. F(1) = 1, F(2) = 2, 这是之前已经明确过的

		![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_5.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_5.png)

		第一次迭代, 台阶数等于3时, 走法数量是3, 这个结果是F(1), F(2)这两个结果相加得来的, 所以F(3)只依赖F(1)和F(2)

		![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_6.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_6.png)

		第二次迭代, 台阶数等于4时, 走法数量是5, 这个结果是F(2), F(3)这两个结果相加得来的, 所以F(4)只依赖F(2)和F(3)

		![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_7.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_7.png)

		同理, 在后续迭代中, F(5)只依赖于F(4)和F(3); F(6)只依赖于F(5),F(4)

		由此可见, 每一次迭代中, 只要保留之前的两个状态, 就可以推导出新的状态. 而不需要像备忘录算法那样, 这才是真正的动态规划

		程序从 i = 3 开始迭代，一直到 i = n 结束。每一次迭代，都会计算出多一级台阶的走法数量。迭代过程中只需保留两个临时变量a和b，分别代表了上一次和上上次迭代的结果。 为了便于理解，我引入了temp变量。temp代表了当前迭代的结果值。

## 题目二

* 有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？

  ![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_8.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_8.png)

* **方法一: 排列组合**

  每一座金矿都有挖与不挖两种选择，如果有N座金矿，排列组合起来就有2^N种选择。对所有可能性做遍历，排除那些使用工人数超过10的选择，在剩下的选择里找出获得金币数最多的选择。

* 动态规划有三个核心元素: **最优子结构, 边界, 状态转移量**, 首先思考一下这个题目的最优子结构, 题目要求10个工人5个金矿时, 挖最多黄金的选择. **那么最优子结构应该是10个工人4个金矿时, 挖出最多金矿的选择**
  * 如果不挖第5座金矿, 对应的最优子结构是上述的情况
  * 如果选择挖, 会占用掉一部分工人, 那么前4个金矿所分配的工人数量就是[10 - 第5个金矿所需人数], 而不再是10 了, 所以说问题的最优子结构有两个, 一个是4金矿10工人时的最优选择, 一个是4金矿10 - 3工人时的最优选择

  ![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_9.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_9.png)

* 接下来讨论4个金矿的最优选择和5个金矿的最优选择之间是什么样的关系呢?

  **5个金矿的最优选择, 就是(前4座金矿10工人的挖金数量)和(前4做金矿7工人挖金数量 + 第5座金矿的挖金数量)的最大值**

  ![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_10.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_10.png)

* **为了便于描述, 我们把金矿的数量设为N, 工人数设为W, 金矿的黄金量设置为数组G[], 金矿的用工量设为数组P[], 那么5座金矿和4座金矿的最优选择之间存在这样的关系:**

  * **F(5, 10) = MAX(F(4, 10), F(4, 10 - P[4]) + G[4])**

* 接下来确定边界, 边界也是分为两种情况, 前提是在只有1座金矿的时候
  * 当 N = 1, W >= P[0] 时, F(N, W) = G[0]
  * 当 N = 1, W < P[0] 时, F(N, W) = 0

* **下面经过整理, 我们就能得到状态转移方程式**
  * F(n,w) = 0    (n<=1, w<p[0]);
  * F(n,w) = g[0]     (n==1, w>=p[0]);
  * F(n,w) = F(n-1,w)    (n>1, w<p[n-1])  
  * F(n,w) = max(F(n-1,w),  F(n-1,w-p[n-1])+g[n-1])    (n>1, w>=p[n-1])

* **方法二: 简单递归**

  把状态转移方程式翻译成递归程序，递归的结束的条件就是方程式当中的边界。因为每个状态有两个最优子结构，所以递归的执行流程类似于一颗高度为N的二叉树。

  方法的时间复杂度是O(2^N)

* **方法三: 备忘录算法**

  在简单递归的基础上增加一个HashMap备忘录，用来存储中间结果。HashMap的Key是一个包含金矿数N和工人数W的对象，Value是最优选择获得的黄金数。

  方法的时间复杂度和空间复杂度相同，都等同于备忘录中不同Key的数量。

* **方法四: 动态规划**

  至于动态规划的实现, 这个问有两个参数, 也就是存在两个维度的输入, 怎么才能实现自底向上的递推呢? 首先来看一张表格

  ![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_11.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_11.png)

  表格的第一列代表给定前1-5座金矿的情况, **也就是N的取值**, 表格的第一行代表给定的工人的数量, **也就是W的取值**, 表格中其余的空白格, 代表给定N和W值对应的黄金获得数, 也就是F(N, W), 下面逐行来填写表格

  **第1座金矿的信息, 400金, 5工人**, 所以前4格都是0, 因为工人不够, 后面的格子都是400, 因为只有这一座金矿可挖

  ![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_12.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_12.png)

  第一行实际上就是我们刚才分析的问题边界, 从第二行开始就会复杂了

  **第2座金矿有500黄金, 需要5工人**, 第2行的前4个格子怎么算呢? 因为W < 5, 所以F(N, W) = F(N - 1, W) = 0

  ![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_13.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_13.png)

  第2行的后6个格子怎么算呢? 因为 W >= 5, 所以根据F(N, W) = Max(F(N-1 ,W), F(N - 1, W - 5) + 500), 第5-9个格子的值是500

  ![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_14.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_14.png)

  需要注意的是第2行的第10个格子, 也就是N = 2, W = 10的时候, F(N - 1, W) = 400, F(N - 1, W - 5) = 400, Max(400, 400 + 500) = 900

  ![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_15.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_15.png)

  **第3座金矿有200黄金, 需要3工人**, 第3行的计算方法如出一辙

  ![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_16.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_16.png)

  第4座金矿有300黄金, 需要4工人

  第5座金矿有350黄金, 需要3工人

  ![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_17.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_17.png)

  **似乎除了第1行以外, 每个格子都是前一行的一个或两个格子推导而来**, 比如3金矿的8工人的结果, 就来自于2金矿5工人和2金矿8工人, Max(500, 500 + 200) = 700

  ![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_18.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_18.png)

  再比如5金矿10工人的结果, 就来自于4金矿7工人和4金矿10工人, Max(900, 500 + 350) = 900

  ![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_19.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_19.png)

  我们使用程序实现的时候, 也可以像这样从左至右, 从上到下一格一格的推导出最终结果, 而且我们不需要存储整个表格, 只需要存储到前一行, 就可以推导出新的一行

  **方法利用两层迭代，来逐步推导出最终结果。在外层的每一次迭代，也就是对表格每一行的迭代过程中，都会保留上一行的结果数组 preResults，并循环计算当前行的结果数组results。**

  **方法的时间复杂度是 O(n * w)，空间复杂度是(w)。需要注意的是，当金矿只有5座的时候，动态规划的性能优势还没有体现出来。当金矿有10座，甚至更多的时候，动态规划就明显具备了优势。**

* 接下来在思考一个问题, 我们把题目变一下, 总工人数变成1000人, 每个金矿的用工数也相应增加, 这时候如何实现最优选择呢

  动态规划的时间复杂度是O(n * w), 空间复杂度是O(w), 在n = 5, w = 1000时, 显然要计算5000次, 开辟1000单位空间

  而我们用简单递归的复杂度是O(2 ^ n), 需要计算32次, 开辟5单位的空间(递归深度), 1000工人的时候, 动态规划的性能反而不如简单递归呢

## 题目三

* 有**2**个鸡蛋，从**100**层楼上往下扔，以此来测试鸡蛋的硬度。比如鸡蛋在第9层没有摔碎，在第10层摔碎了，那么鸡蛋不会摔碎的临界点就是9层。

	**如何用最少的尝试次数，测试出鸡蛋不会摔碎的临界点？**

* 举个栗子，最笨的测试方法是什么样呢？

	把其中一个鸡蛋从第1层开始往下扔。

	如果在第1层没碎，换到第2层扔

	如果在第2层没碎，换到第3层扔

	.......

	如果第59层没碎，换到第60层扔

	如果第60层碎了，说明不会摔碎的临界点是第59层

	**在最坏情况下，这个方法需要扔100次。**

* **方法一: 二分法**

	采用类似于二分查找的方法，把鸡蛋从一半楼层（50层）往下扔。

	如果第一枚鸡蛋在50层碎了，第二枚鸡蛋就从第1层开始扔，一层一层增长，一直扔到第49层。

	如果第一枚鸡蛋在50层没碎了，则继续使用二分法，在剩余楼层的一半（75层）往下扔......

	这个方法在最坏情况下，需要尝试50次。

* **方法二：平方根法**

	如何让第一枚鸡蛋和第二枚鸡蛋的尝试次数尽可能均衡呢？

	很简单，做一个平方根运算，100的平方根是10。

	因此，我们尝试每10层扔一次，第一次从10层扔，第二次从20层扔，第三次从30层......一直扔到100层。

	这样的最好情况是在第10层碎掉，尝试次数为 1 + 9 = 10次。

	最坏的情况是在第100层碎掉，尝试次数为 10 + 9 = 19次。

	![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_20.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_20.png)
	**不过，这里有一个小小的优化点，我们可以从15层开始扔，接下来从25层、35层扔......一直到95层。**

	**这样最坏情况是在第95层碎掉，尝试次数为 9 + 9 = 18次。**

* **方法三: 解方程法**

	**假设问题存在最优解, 这个最优解的最坏尝试次数是x次, 那么我第一层应该选择在哪一行?**

	**恰恰是从第x层开始扔, 选择更高或是更低的一层都不合适**

	![http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_21.png](http://www.miaomiaoqi.cn/images/algorithm/dynamic/dynamic_21.png)

	**假设第一次扔在第x+1层：**

	如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x层。

	这样一来，我们总共尝试了x+1次，和假设尝试x次相悖。由此可见，第一次扔的楼层必须小于x+1层。

	**假设第一次扔在第x-1层：**

	如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-2层。

	这样一来，我们总共尝试了x-2+1 = x-1次，虽然没有超出假设次数，但似乎有些过于保守。

	**假设第一次扔在第x层：**

	如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-1层。

	这样一来，我们总共尝试了x-1+1 = x次，刚刚好没有超出假设次数。

	**关于x的选择: 因为我们假设最坏的情况是x次, 那么恰恰是第一个鸡蛋扔的位置处在临界点的上方就碎掉了, 第二个鸡蛋从1层一直扔上来才是最坏的情况**

	**因此，要想尽量楼层跨度大一些，又要保证不超过假设的尝试次数x，那么第一次扔鸡蛋的最优选择就是第x层。**

	**如果第一次鸡蛋没有碎, 我们的尝试次数消耗了一次, 问题就转换成了两个鸡蛋在100 - x层楼往下扔, 要求尝试的次数不得超过x - 1次**

	**由于最坏情况已经消耗了1次, 所以剩余的最坏尝试次数是x - 1次, 所以第二次尝试的楼层跨度是x - 1层, 这个x - 1是相对于x这个楼层的, 在0 - 100这个楼层中, 绝对的楼层位置要把第一次尝试的x层加上, 因此是x + x - 1**

	**同理如果鸡蛋还是没有碎, 第三次的楼层跨度是x - 2层, 第四次的楼层跨度是x - 3层**

	根据这个规律我们可以列出一个方程式:

	**x + (x - 1) + (x - 2) + ... + 1 = 100**

	**这个方程式不难理解：**

	左边的多项式是各次扔鸡蛋的楼层跨度之和。由于假设尝试x次，所以这个多项式共有x项。

	右边是总的楼层数100。

	**下面我们来解这个方程：**

	x + (x-1) + (x-2) + ... + 1 = 100  转化为

	(x+1)*x/2 = 100



	**这里解释一下这个方程:**

	1. 左边一共有x项, 开始的数字是x, 所以从x开始每次加上一个递减1的数字, 共加x项, 到最后就是 + 1的情况

	1. 等于100实际上是要大于等于100, 如果是一个小于100的数字, 那么第一个鸡蛋的楼层尝试次数会有覆盖不到的地方

	1. 方程转化可以举个例子, 假设x = 6那么原方程是:

		6 + (6 - 1) + (6 - 2) + (6 - 3) + (6 - 4) + (6 - 5) = 100

		可以转换为6 + 5 + 4 + 3 + 2 + 1 = 100

		就可以转换为公式 (6 + 1) + (5 + 2) + (4 + 3) = 100

		继续转换 (6 + 1) * 3 = 100

		可推导出上边方程式的解法

		(x + 1) * x / 2 = 100

		就可以求出x了, 因为是要大于等于100, 所以我们的x向上取整


	最终x向上取整，得到 **x = 14**

	因此，最优解在最坏情况的尝试次数是**14次**，第一次扔鸡蛋的楼层也是**14层**。

	最后，让我们把第一个鸡蛋没碎的情况下，所尝试的楼层数完整列举出来：

	**14，27， 39， 50， 60， 69， 77， 84， 90， 95， 99， 100**

	举个栗子验证下：

	假如鸡蛋不会碎的临界点是65层，那么第一个鸡蛋扔出的楼层是14，27，50，60，69。这时候啪的一声碎了。

	第二个鸡蛋继续，从61层开始，61，62，63，64，65，66，啪的一声碎了。

	因此得到不会碎的临界点65层，总尝试次数是 6 + 6 = 12 < 14 

* **方法四: 动态规划**

	我们的问题得到了升级, 有M层楼 / N个鸡蛋，要找到鸡蛋摔不碎的临界点，需要尝试几次？