---
layout: post
title: "Socket 网络编程"
categories: [Network]
description:
keywords:
---

* content
{:toc}


## 网络

### 什么是网络

在计算机领域中, 网络是信息传输, 接收, 共享的虚拟平台

通过它可以把各个点, 面, 体的信息联系到一起, 从而实现这些资源的共享

### 什么是网络编程

网络编程从大的方面说就是对信息的发送到接收

通过操作相应的Api调度计算机硬件资源, 并利用传输管道(网线)进行数据交换的过程

## Socket与TCP, UDP

### 什么是Socket

简单来说是IP地址与端口的结合协议(RFC 793)

一种地址与端口结合描述协议

TCP/IP协议的相关API的总称, 是网络API的集合实现

涵盖了 Stream Socket/Datagram Socket

### Socket的作用与组成

在网络传输中用于唯一标示两个**端点**之间的链接

端点: 包括(IP + 端口)

4个要素: 客户端地址, 客户端端口, 服务端地址, 服务端端口

### Socket 之 TCP

TCP是面向连接的通信协议

通过三次握手建立连接, 通讯完成时要拆除连接

由于TCP是面向连接的所以只能用于端到端的通讯

### Socket 之 UPD

UDP是面向无连接的通讯协议

UDP数据包括目的端口号和源端口号信息

由于通讯不需要连接, 所以可以实现广播发送, 并不限于端到端

## 报文, 协议, MAC地址

### 报文段

报文段是指TCP/IP协议网络传输过程中, 起着路由导航作用

用以查询各个网络路由网段, IP地址, 交换协议等IP数据包

报文在传输过程中会不断地封装成分组, 包, 帧来传输

### 传输协议

协议顾名思义, 一中规定, 约束

约定大于配置, 在网络传输中依然适用, 网络的传输流程是健壮的稳定的, 得益于基础的协议构成

简单来说, A -> B的传输数据, B能识别, 反之, B -> A的传输数据A也能识别, 这就是协议

### MAC地址

Media Access Control或者Medium Access Control

意译为媒体访问控制, 或称为物理地址, 硬件地址

用来定义网络设备的位置

形如 44-45-53-54-00-00, 类似身份证

## IP, 端口, 远程服务器

### IP地址

互联网协议地址(Internet Protocol Address, 又译为网际协议地址), 缩写为IP地址(IP Address)

是分配给网络上使用网际协议的设备的数字标签

IP地址由32位二进制数字组成, 常以XXX.XXX.XXX.XXX形式表现, 每组XXX代表小于等于255的10进制数

分为A, B, C, D, E五大类, 其中E类属于特殊保留地址

### 端口

如果把 IP 地址比作一间房子, 端口就是出入这间房子的门或者窗户

在不同的门或者窗户后有不同的人, 房子中的用户与外界交流的出入口

外界鸽子(信息)飞到不同窗户也就是给不同的人传递信息

0 到 1023 号端口是特殊端口

计算机之间依照互联网传输层 TCP/IP 协议的协议通信, 不同的协议都对应不同的端口

49152 到 65535 都属于动态端口范围, 没有端口可以正式地注册占用

### 远程服务器

局域网: 一般而言, 家里的环境以及公司相互电脑之间环境都属于局域网

## Socket-UDP 快速入门

### UPD 介绍

#### UPD 是什么

User Datagram Protocol, 缩写为 UDP

一种**用户数据报协议**, 又称**用户数据报文协议**

是一个简单的面向**数据报**的**传输层**协议, 正式规范为RFC 768

用户数据协议, **非连接协议**

#### 为什么不可靠

它一旦把应用程序发给网络层的数据发送出去, 就不保留数据备份

UPD在IP数据报的头部仅仅加入了复用和数据校验(字段)

发送端产生数据, 接收端从网络中抓取数据

结构简单, 无校验, 速度快, 容易丢包, 可广播

#### UPD 能做什么

DNS, TFTP, SNMP

音频, 视频, 普通数据(无关紧要的数据)

![https://miaomiaoqi.github.io/images/net/socket/socket_1.png](https://miaomiaoqi.github.io/images/net/socket/socket_1.png)

#### UPD 包最大长度

16位 -> 2字节 存储长度信息

2^16 - 1 = 64K - 1 = 65536 - 1 = 65535

自身协议占用 32 + 32 位 = 64位 = 8字节

### UDP 核心 API

#### DatagramSocket

用于接收和发送UDP的类

负责发送某一个UDP包, 或者接收UDP包

不同于TCP, UDP并没有合并到SocketAPI中

DatagramSocket()创建简单实例, 不指定端口与IP

DatagramSocket(int port)创建监听固定端口的实例

DatagramSocket(int port, inetAddress localAddr)创建固定端口指定IP的实例

receive(DatagramPacket d): 接收

send(DatagramPacket d): 发送

setSoTimeout(int timeout): 设置超时, 毫秒

close(): 关闭, 释放

#### DatagramPacket

用于处理报文

将byte数组, 目的地址, 目标端口等数据包装成报文或者将报文拆卸成byte数组

Datagram(byte[] buf, int offset, int length, IntAddress address, int port)

Datagram(byte[] buf, int offset, int length, SocketAddress address)

setData(byte[] buf, int offset, int length)

setData(byte[] buf)

setLength(int length)

getData(), getOffset(), getLength()

setAddress(IntAddress iaddr), setPort(int port)

getAddress(), getPort()

setSocketAddress(SocketAddress address)

getSocketAddress()

### UDP 单播, 多播, 广播

#### 单播

点对点发送

#### 多播(组播)

点对多发送信息

#### 广播

给所有设备发送信息

### 局域网搜索案例

UDP接收消息并回送功能实现

UDP局域网广播发送实现

UDP局域网回送消息实现

## Socket-TCP 快速入门

### TCP 介绍

#### TCP 是什么

英语: Transmission Control Protocol, 缩写为TCP

TCP是**传输控制协议**, 是一种**面向连接**的, 可靠的, 基于字节流的传输层通信协议, 由IETF的RFC 793定义

与UDP一样完成第四层传输层所指定的功能与职责

#### TCP 的机制

三次握手, 四次挥手

具有校验机制, 可靠, 数据传输稳定

#### TCP 能做什么

聊天消息传输, 推送

单人语音, 视频聊天等

几乎UDP能做的事情都可以做, 但需要考虑复杂性, 性能问题

限制: 无法进行广播, 多播等操作

#### TCP 核心 API

socket(): 创建一个**客户端** Socket

bind(): 绑定一个Socket到一个本地地址和端口上

accept(): 接受一个**新的连接**

write(): 把数据写入到Socket 输出流

read(): 从Socket输入流读取数据

![https://miaomiaoqi.github.io/images/net/socket/socket_2.png](https://miaomiaoqi.github.io/images/net/socket/socket_2.png)

![https://miaomiaoqi.github.io/images/net/socket/socket_3.png](https://miaomiaoqi.github.io/images/net/socket/socket_3.png)

### Socket 与进程的关系

![https://miaomiaoqi.github.io/images/net/socket/socket_4.png](https://miaomiaoqi.github.io/images/net/socket/socket_4.png)

### TCP 的连接可靠性

#### 三次握手

![https://miaomiaoqi.github.io/images/net/socket/socket_5.png](https://miaomiaoqi.github.io/images/net/socket/socket_5.png)

syn 和 ack 都是命令, x 是随机数, y 也是随机数

三次握手保证双方可以收到对方的内容(全双工)

一个服务端可以接收多个客户端, 因此在通信的时候带上一个随机数进行校验, 保证了连接的正确性

#### 四次挥手

![https://miaomiaoqi.github.io/images/net/socket/socket_6.png](https://miaomiaoqi.github.io/images/net/socket/socket_6.png)

全双工要依次断开, 如果是三次挥手的话, 提出断开的一方, 要等待被动方发送完数据, 才能收到 ack 命令, 其实这段时间主动方可以断开输出流

如果是五次挥手, 没有必要, 会造成浪费

### TCP 的传输可靠性

拆分, 排序, 顺序发送, 顺序组装

丢弃, 超时

![https://miaomiaoqi.github.io/images/net/socket/socket_7.png](https://miaomiaoqi.github.io/images/net/socket/socket_7.png)

当发送一条数据时, TCP 会将这条数据拆封成不同的片段并把片段排序, 将排序后的片段顺序发送

### 案例实操

#### TCP 传输初始化配置

1. 初始化服务器TCP链接监听

2. 初始化客户端发起链接操作

3. 服务器 Socket 链接处理

#### 客户端与服务器交互

1. 客户端发送简单字节

2. 服务器接收客户端发送数据

3. 服务器回送消息, 客户端识别回送消息

## 局域网内 UDP 辅助 TCP 实现点对点传输案例

tcp 是面向连接的, 而 udp 是面向报文的, 我们通过 udp 广播寻找目标 ip 与端口, 在通过 tcp 进行连接会话

### UDP 搜索 IP 与端口

1. 构建基础口令消息

2. 局域网广播口令消息(指定端口)
3. 接收指定端口回送消息(得到客户端 ip, port)

### UDP 搜索取消实现

1. 异步线程接收回送消息
2. 异步线程等待完成(定时)
3. 关闭等待 - 终止线程等待

### 数据发送与接收并行

1. 多线程收发并行
2. TCP多线程收发协作

### 聊天室数据传输数据

必要条件: 客户端, 服务器

必要约束: 数据传输协议

原理: 服务器监听消息来源, 客户端链接服务器并发送消息到服务器

## 阻塞 IO 和非阻塞 IO

### 阻塞 IO

![https://miaomiaoqi.github.io/images/net/socket/socket_8.png](https://miaomiaoqi.github.io/images/net/socket/socket_8.png)

假如有 1000 个客户端连接, 就要开启 1000 个线程进行数据读取操作, 这个 read() 操作是阻塞的. 其次向外发送数据, 也会开启线程池进行数据的 send() 操作, 还有调度线程, 这说明我们至少开启 1000 多个线程进行操作, 而这其中的许多线程是阻塞的, CPU 会在这些线程中来回扫描切换, 造成了大量的资源浪费.

### 非阻塞 IO

NIO 全称: Non-blocking I/O

JDK1.4 引入全新的输入输出标准库 NIO, 也叫New I/O

在标准 Java 代码中提供了告诉的, 可伸缩性的, 面向块的, 非阻塞的 IO 操作

![https://miaomiaoqi.github.io/images/net/socket/socket_9.png](https://miaomiaoqi.github.io/images/net/socket/socket_9.png)

使用非阻塞IO我们只有一个主线程, 当有客户端连接的时候, 我们注册一个事件, 当有数据来的时候又会有一个新的事件, 这些事件只放在主线程中, 我们充分的利用了主线程, 大大提高了线程的使用率.

## NIO 重写服务器

监听客户端到达

接收, 回送客户端数据

转发客户端数据到另一个客户端

多客户端的消息处理

## NIO 服务器 Thread 优化

### 现有线程模型

![https://miaomiaoqi.github.io/images/net/socket/socket_10.png](https://miaomiaoqi.github.io/images/net/socket/socket_10.png)

Selector 线程用于轮询事件的到达, 每个 Channel 又有一个读线程和写线程, 目前并没有解决线程过多的问题

### 单线程模型

![https://miaomiaoqi.github.io/images/net/socket/socket_11.png](https://miaomiaoqi.github.io/images/net/socket/socket_11.png)

所有的 Channel 都用一个线程来做, 这个单线程是非常繁忙的几乎占用了所有 CPU 的资源进行轮询, 但是效率并不是高效的.

1. 我们有多个 CPU 并没有利用起来多核的优势.
2. 假如正在处理客户端的消息读取, 就会导致新的客户端无法建立连接, 所有的操作都是串行的, 会造成阻塞.

### 监听与数据处理线程分离

![https://miaomiaoqi.github.io/images/net/socket/socket_12.png](https://miaomiaoqi.github.io/images/net/socket/socket_12.png)

1. 使用一个 Accepter Thread 监听 ServerSocketChannel 获取客户端连接
2. 使用线程池尽可能保证客户端的数据处理是分离的





## BIO

同步阻塞IO（Blocking IO）：即传统的IO模型。

![https://miaomiaoqi.github.io/images/net/io/io_1.png](https://miaomiaoqi.github.io/images/net/io/io_1.png)

```java
public static void main(String[] args) throws IOException {
    ServerSocket serverSocket = new ServerSocket();
    serverSocket.bind(new InetSocketAddress("127.0.0.1", 8888));

    while (true) {
        Socket socket = serverSocket.accept(); // 阻塞等待连接(Blocking)

        BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        String line = null;
        while ((line = reader.readLine()) != null) { // 阻塞等待客户端输入数据
            System.out.println(line);
        }
        reader.close();
    }
}
```

传统 bio 中, serverSocket 需要阻塞式的等待客户端连接

当客户端 socket 连接后还要阻塞的读取数据

如果 serverSocket 与 socket 在同一个线程中, socket 在阻塞的时候会导致 serverSocket 无法建立新的连接, 所以要为每一个 socket 单独开一个线程

### 优势

可以接收很多的连接, 没有太多限制

### 劣势

线程内存浪费, 我们要为每一个连接都建立读写线程

线程过度导致 cpu 调度消耗增大

### 解决方案

可以使用 NONBLOCKING 非阻塞式 IO 解决



## NIO

同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。

对 Java 开发者而言, NIO 有两层含义, 一个是 Java 中的 nio 包中提供的类, 另一个代表 nonblocking 非阻塞式 io

![https://miaomiaoqi.github.io/images/net/io/io_2.png](https://miaomiaoqi.github.io/images/net/io/io_2.png)

```java
public static void main(String[] args) throws IOException {
    LinkedList<SocketChannel> clients = new LinkedList<>();
    ServerSocketChannel ss = ServerSocketChannel.open();
    ss.bind(new InetSocketAddress(9090));
    ss.configureBlocking(false); // 设置 os nonblocking
    while (true) {
        SocketChannel client = ss.accept(); // 非阻塞 在 linux 层返回-1, java 层返回 null
        // accent 调用了内核, 如果没有客户端连接, 在 BIO 时会阻塞等待连接进来, 在 NIO 会返回 null
        // 如果客户端连接, 会返回客户端的文件描述符, java 层是 client 对象
        if (client == null) {
            System.out.println("null.....");
        } else {
            client.configureBlocking(false); // 设置客户端非阻塞
            int port = client.socket().getPort();
            System.out.println("client...port: " + port);
            clients.add(client);
        }
        ByteBuffer buffer = ByteBuffer.allocate(4096);
        // 遍历已经连接进来的客户端进行数据读取
        for (SocketChannel c : clients) { // 串行化遍历
            int num = c.read(buffer); // 非阻塞式读取数据
            if (num > 0) {
                buffer.flip();
                byte[] aa = new byte[buffer.limit()];
                buffer.get(aa);
                String b = new String(aa);
                System.out.println(c.socket().getPort() + " : " + b);
                buffer.clear();
            }
        }
    }
}
```

### 优势

规避了多线程的问题, 因为 accept 与 recv 方法都是非阻塞的, 就不需要开启多线程接收数据了

### 劣势

假设有 1 万个连接, 但是只有 1 个发来数据, 每次循环遍历 1 万个客户端, 会发起 1 万次 recv 的系统调用, 实际上有 9999 次是无意义的, 消耗时间和资源, 浪费在用户空间向内核空间的系统调用上

### 解决方案

select/poll

epoll



## AIO

即经典的Proactor设计模式，也称为异步非阻塞IO。

![https://miaomiaoqi.github.io/images/net/io/io_3.png](https://miaomiaoqi.github.io/images/net/io/io_3.png)





## BIO, NIO, AIO 适用场景分析

BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。

NIO方式适用于**连接数目多且连接比较短**（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。

AIO方式使用于**连接数目多且连接比较长**（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。

## select, poll, epoll

现代计算机中分为用户态和内核态, 一些危险操作例如 io 的读取只有内核态可以执行, 在我们的 java 程序中如果想要进行 io 的读取, CPU 会从用户态切换到内核态读取网卡上的数据, 再从内核态切换到用户态并返回数据, 这是一个非常消耗性能的操作

### select/poll

select/poll 通过将 fds 一次性全部传送给内核, 内核自己进行遍历将有数据的连接返回给用户空间, 减少了系统调用, select 与 poll 的本质是一样的, 只不过 select 限制了只能传送 1024 个 fds, 而 poll 可以动态改变

**优势**

通过一次系统调用, 将 1 万个 fds 全部传给内核, 内核中进行遍历判断哪个连接有数据发送, 虽然无法避免遍历, **但是极大地减少了系统调用的次数**

**劣势**

每次 select 都会传送 fds, 实际上第一次传送就可以

每次 select/poll 的时候内核都要重新全量遍历 fds



**解决方案**

epoll



### epoll

应用程序会将 fds 发送给内核, 内核会开辟一片空间保存 fds, 以后就不需要再次发送 fds 了, 当有数据过来时, CPU01 会将 fds 拷贝到内核中的另一个空间, 同时 CPU02 会将拷贝的 fds 返回给引用程序, CPU01与 CPU02 是并行异步的, 这样是用内核的空间换取时间

![https://miaomiaoqi.github.io/images/net/io/io_4.png](https://miaomiaoqi.github.io/images/net/io/io_4.png)

```java
public class SocketMultiplexingSingleThreadv1 {

    private ServerSocketChannel server = null;
    private Selector selector = null; // linux 多路复用器（select poll    epoll kqueue） nginx  event{}
    int port = 9090;

    public void initServer() {
        try {
            this.server = ServerSocketChannel.open();
            this.server.configureBlocking(false);
            this.server.bind(new InetSocketAddress(this.port));
            // 如果在epoll模型下，open--》  epoll_create -> fd3
            this.selector = Selector.open();  //  select  poll  *epoll  优先选择：epoll  但是可以 -D修正
            // server 约等于 listen状态的 fd4
            /*
            register
            如果：
            select，poll：jvm 里开辟一个数组 fd4 放进去
            epoll：  epoll_ctl(fd3,ADD,fd4,EPOLLIN
             */
            this.server.register(this.selector, SelectionKey.OP_ACCEPT);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void start() {
        this.initServer();
        System.out.println("服务器启动了。。。。。");
        try {
            while (true) {  //死循环
                Set<SelectionKey> keys = this.selector.keys();
                System.out.println(keys.size() + "   size");
                //1,调用多路复用器(select,poll  or  epoll  (epoll_wait))
                /*
                select()是啥意思：
                1，select，poll  其实  内核的select（fd4）  poll(fd4)
                2，epoll：  其实 内核的 epoll_wait()
                *, 参数可以带时间：没有时间，0  ：  阻塞，有时间设置一个超时
                selector.wakeup()  结果返回0
                 */
                while (this.selector.select(500) > 0) {
                    Set<SelectionKey> selectionKeys = this.selector.selectedKeys();  //返回的有状态的fd集合
                    Iterator<SelectionKey> iter = selectionKeys.iterator();
                    //so，管你啥多路复用器，你呀只能给我状态，我还得一个一个的去处理他们的R/W。同步好辛苦！！！！！！！！
                    //  NIO  自己对着每一个fd调用系统调用，浪费资源，那么你看，这里是不是调用了一次select方法，知道具体的那些可以R/W了? 
                    //幕兰，是不是很省力? 
                    //我前边可以强调过，socket：  listen   通信 R/W
                    while (iter.hasNext()) {
                        SelectionKey key = iter.next();
                        iter.remove(); //set  不移除会重复循环处理
                        if (key.isAcceptable()) {
                            // 看代码的时候，这里是重点，如果要去接受一个新的连接
                            // 语义上，accept接受连接且返回新连接的FD对吧? 
                            // 那新的FD怎么办? 
                            // select，poll，因为他们内核没有空间，那么在jvm中保存和前边的fd4那个listen的一起
                            // epoll： 我们希望通过epoll_ctl把新的客户端fd注册到内核空间
                            this.acceptHandler(key);
                        } else if (key.isReadable()) {
                            this.readHandler(key);
                            // 在当前线程，这个方法可能会阻塞  ，如果阻塞了十年，其他的IO早就没电了。。。
                            // 所以，为什么提出了 IO THREADS
                            // redis  是不是用了epoll，redis是不是有个io threads的概念 ，redis是不是单线程的
                            // tomcat 8,9  异步的处理方式  IO  和   处理上  解耦
                        }
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void acceptHandler(SelectionKey key) {
        try {
            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();
            SocketChannel client = ssc.accept(); //来啦，目的是调用accept接受客户端  fd7
            client.configureBlocking(false);
            ByteBuffer buffer = ByteBuffer.allocate(8192);  //前边讲过了
            // 0.0  我类个去
            //你看，调用了register
            /*
            select，poll：jvm里开辟一个数组 fd7 放进去
            epoll：  epoll_ctl(fd3,ADD,fd7,EPOLLIN
             */
            client.register(this.selector, SelectionKey.OP_READ, buffer);
            System.out.println("-------------------------------------------");
            System.out.println("新客户端：" + client.getRemoteAddress());
            System.out.println("-------------------------------------------");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void readHandler(SelectionKey key) {
        SocketChannel client = (SocketChannel) key.channel();
        ByteBuffer buffer = (ByteBuffer) key.attachment();
        buffer.clear();
        int read = 0;
        try {
            while (true) {
                read = client.read(buffer);
                if (read > 0) {
                    buffer.flip();
                    while (buffer.hasRemaining()) {
                        client.write(buffer);
                    }
                    buffer.clear();
                } else if (read == 0) {
                    break;
                } else {
                    client.close();
                    break;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws IOException {
        SocketMultiplexingSingleThreadv1 service = new SocketMultiplexingSingleThreadv1();
        service.start();
    }

}
```



![https://miaomiaoqi.github.io/images/net/epoll/epoll_1.jpg](https://miaomiaoqi.github.io/images/net/epoll/epoll_1.jpg)