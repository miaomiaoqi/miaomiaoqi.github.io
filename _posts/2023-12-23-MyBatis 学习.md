---
layout: post
title: "MyBatis 学习"
categories: [Framework]
description:
keywords:
---

* content
{:toc}


## MyBatis 简介

### MyBatis 历史

MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁

移到了Google Code. 随着开发团队转投Google Code旗下,  iBatis3.x正式更名为MyBatis. 代码于

2013年11月迁移到Github. 

iBatis一词来源于“internet”和“abatis”的组合, 是一个基于Java的持久层框架.  iBatis提供的持久层框架

包括SQL Maps和Data Access Objects(DAO). 

### MyBatis 特性

MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架

MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集

MyBatis 可以使用简单的XML或注解用于配置和原始映射, 将接口和 Java的POJO(Plain Old Java Objects, 普通的 Java 对象)映射成数据库中的记录

MyBatis 是一个 半自动的 ORM(Object Relation Mapping) 框架

### MyBatis 下载

MyBatis下载地址: https://github.com/mybatis/mybatis-3

### MyBatis 和其他持久化框架技术对比

#### JDBC

SQL 夹杂在 Java 代码中耦合度高, 导致硬编码内伤

维护不易且实际开发需求中 SQL 有变化, 频繁修改的情况多见

代码冗长, 开发效率低

#### Hibernate 和 JPA

操作简便, 开发效率高

程序中的长难复杂 SQL 需要绕过框架

内部自动生产的 SQL, 不容易做特殊优化

基于全映射的全自动框架, 大量字段的 POJO 进行部分映射时比较困难. 

反射操作太多, 导致数据库性能下降

#### MyBatis

轻量级, 性能出色

SQL 和 Java 编码分开, 功能边界清晰. Java 代码专注业务、SQL 语句专注数据

开发效率稍逊于 HIbernate, 但是完全能够接受



## 搭建 MyBatis

### 开发环境

IDE: idea 2019.2

构建工具: maven 3.5.4

MySQL版本: MySQL 5.7

MyBatis版本: MyBatis 3.5.7

### 创建 maven 工程

**打包方式: jar**

**引入依赖**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.miaoqi.atguigu</groupId>
    <artifactId>atguigu-mybatis2022</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>
    <modules>
        <module>MyBatis_Demo1</module>
    </modules>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- Mybatis核心 -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.7</version>
        </dependency>
        <!-- junit测试 -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
        <!-- MySQL驱动 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.3</version>
        </dependency>
        <!-- log4j日志 -->
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>
    </dependencies>

</project>
```



### 创建 MyBatis 的核心配置文件

习惯上命名为 mybatis-config.xml, 这个文件名仅仅只是建议, 并非强制要求. 将来整合 Spring

之后, 这个配置文件可以省略, 所以大家操作时可以直接复制、粘贴. 

核心配置文件主要用于配置连接数据库的环境以及 MyBatis 的全局配置信息

**核心配置文件存放的位置是 src/main/resources 目录下**

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!--设置连接数据库的环境-->
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/MyBatis"/>
                <property name="username" value="root"/>
                <property name="password" value="miaomiaoqi"/>
            </dataSource>
        </environment>
    </environments>
    <!--引入映射文件-->
    <mappers>
        <mapper resource="mappers/UserMapper.xml"/>
    </mappers>
</configuration>
```



### 创建 Mapper 接口

MyBatis 中的 mapper 接口相当于以前的 dao. 但是区别在于, mapper 仅仅是接口, 我们不需要提供实现类. 

```java
public interface UserMapper {
    /**
    * 添加用户信息
    */
    int insertUser();
}
```



### 创建数据库表

```sql
CREATE TABLE `t_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(20) DEFAULT NULL,
  `password` varchar(20) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `sex` char(1) DEFAULT NULL,
  `email` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
```



### 创建 MyBatis 的映射文件

相关概念: ORM(Object Relationship Mapping)对象关系映射. 

*   对象: Java 的实体类对象
*   关系: 关系型数据库
*   映射: 二者之间的对应关系

| Java 概念 | 数据库概念 |
| --------- | ---------- |
| 类        | 表         |
| 属性      | 字段/列    |
| 对象      | 记录/行    |

1.   映射文件的命名规则: 

​	表所对应的实体类的类名+Mapper.xml

​	例如: 表 t_user, 映射的实体类为 User, 所对应的映射文件为 UserMapper.xml

​	因此一个映射文件对应一个实体类, 对应一张表的操作

​	MyBatis 映射文件用于编写 SQL, 访问以及操作表中的数据

​	MyBatis 映射文件存放的位置是 src/main/resources/mappers 目录下

2.   MyBatis 中可以面向接口操作数据, 要保证两个一致: 
     *   mapper 接口的全类名和映射文件的命名空间(namespace)保持一致
     *   mapper 接口中方法的方法名和映射文件中编写 SQL 的标签的 id 属性保持一致

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.atguigu.mybatis.mapper.UserMapper">
    <!--int insertUser();-->
    <insert id="insertUser">
        INSERT INTO t_user
        VALUES (NULL, '张三', '123', 23, '女', '12345@qq.com')
    </insert>
</mapper>
```



### 通过 Junit 测试功能

```java
package com.atguigu.mybatis.test;

import com.atguigu.mybatis.mapper.UserMapper;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import java.io.IOException;
import java.io.InputStream;

public class MyBatisTest {

    /**
     * SqlSession 默认不自动提交事务, 若需要自动提交事务
     * 可以使用 SqlSessionFactory.openSession(true)
     *
     * @author miaoqi
     * @date 2023-12-24 0:22:18
     *
     * @return
     */
    @Test
    public void testMyBatis() throws IOException {
        // 加载核心配置文件
        InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
        // 获取 SqlSessionFactoryBuilder
        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
        // 获取 SqlSessionFactory
        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
        // 获取 SqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        // 获取 Mapper 接口对象
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        // 测试功能
        int result = userMapper.insertUser();
        // 提交事务
        // sqlSession.commit();
        System.out.println("result: " + result);
    }

}

```



### 加入 log4j 日志功能

**加入依赖**

```xml
<!-- log4j日志 -->
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
```

**加入 log4j 的配置文件**

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">
    <appender name="STDOUT" class="org.apache.log4j.ConsoleAppender">
        <param name="Encoding" value="UTF-8"/>
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern" value="%-5p %d{MM-dd HH:mm:ss,SSS}%m (%F:%L) \n"/>
        </layout>
    </appender>
    <logger name="java.sql">
        <level value="debug"/>
    </logger>
    <logger name="org.apache.ibatis">
        <level value="info"/>
    </logger>
    <root>
        <level value="debug"/>
        <appender-ref ref="STDOUT"/>
    </root>
</log4j:configuration>
```

**日志的级别**

FATAL(致命)>ERROR(错误)>WARN(警告)>INFO(信息)>DEBUG(调试
从左到右打印的内容越来越详细



## 核心配置文件讲解

核心配置文件中的标签必须按照固定的顺序: 

properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorF

actory?,plugins?,environments?,databaseIdProvider?,mappers?

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//MyBatis.org//DTD Config 3.0//EN"
        "http://MyBatis.org/dtd/MyBatis-3-config.dtd">
<configuration>
    <!--引入properties文件, 此时就可以${属性名}的方式访问属性值-->
    <properties resource="jdbc.properties"></properties>
    <settings>
        <!--将表中字段的下划线自动转换为驼峰-->
        <setting name="mapUnderscoreToCamelCase" value="true"/>
        <!--开启延迟加载-->
        <setting name="lazyLoadingEnabled" value="true"/>
    </settings>
    <typeAliases>
        <!--
        typeAlias: 设置某个具体的类型的别名
        属性: 
        type: 需要设置别名的类型的全类名
        alias: 设置此类型的别名, 若不设置此属性, 该类型拥有默认的别名, 即类名且不区分大小
        写
        若设置此属性, 此时该类型的别名只能使用alias所设置的值
        -->
        <!--<typeAlias type="com.atguigu.mybatis.bean.User"></typeAlias>-->
        <!--<typeAlias type="com.atguigu.mybatis.bean.User" alias="abc">
        </typeAlias>-->
        <!--以包为单位, 设置改包下所有的类型都拥有默认的别名, 即类名且不区分大小写-->
        <package name="com.atguigu.mybatis.bean"/>
    </typeAliases>
    <!--
    environments: 设置多个连接数据库的环境
    属性: 
    default: 设置默认使用的环境的id
    -->
    <environments default="mysql_test">
        <!--
        environment: 设置具体的连接数据库的环境信息
        属性: 
        id: 设置环境的唯一标识, 可通过environments标签中的default设置某一个环境的id, 
        表示默认使用的环境
        -->
        <environment id="mysql_test">
            <!--
            transactionManager: 设置事务管理方式
            属性: type: 设置事务管理方式, type="JDBC|MANAGED"
                type="JDBC": 设置当前环境的事务管理都必须手动处理
                type="MANAGED": 设置事务被管理, 例如spring中的AOP
                -->
            <transactionManager type="JDBC"/>
            <!--
            dataSource: 设置数据源
            属性: 
            type: 设置数据源的类型, type="POOLED|UNPOOLED|JNDI"
            type="POOLED": 使用数据库连接池, 即会将创建的连接进行缓存, 下次使用可以从
            缓存中直接获取, 不需要重新创建
            type="UNPOOLED": 不使用数据库连接池, 即每次使用连接都需要重新创建
            type="JNDI": 调用上下文中的数据源
            -->
            <dataSource type="POOLED">
                <!--设置驱动类的全类名-->
                <property name="driver" value="${jdbc.driver}"/>
                <!--设置连接数据库的连接地址-->
                <property name="url" value="${jdbc.url}"/>
                <!--设置连接数据库的用户名-->
                <property name="username" value="${jdbc.username}"/>
                <!--设置连接数据库的密码-->
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>
    <!--引入映射文件-->
    <mappers>
        <mapper resource="UserMapper.xml"/>
        <!--
        以包为单位, 将包下所有的映射文件引入核心配置文件
        注意: 此方式必须保证mapper接口和mapper映射文件必须在相同的包下
        -->
        <package name="com.atguigu.mybatis.mapper"/>
    </mappers>
</configuration>
```



## MyBatis 获取参数值的两种方式

MyBatis 获取参数值的两种方式: ${}和#{}

${} 的本质就是字符串拼接, #{} 的本质就是占位符赋值

${} 使用字符串拼接的方式拼接 sql, 若为字符串类型或日期类型的字段进行赋值时, 需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql, 此时为字符串类型或日期类型的字段进行赋值时, 可以自动添加单引号

### 单个字面量类型的参数

若 mapper 接口中的方法参数为单个的字面量类型此时可以使用\$\{\}和#{}以任意的名称获取参数的值, 注意\$\{\}需要手动加单引号

### 多个字面量类型的参数

若 mapper 接口中的方法参数为多个时

此时 MyBatis 会自动将这些参数放在一个 map 集合中, 以arg0,arg1...为键, 以参数为值；以param1,param2...为键, 以参数为值；因此只需要通过\${}和#{}访问 map 集合的键就可以获取相对应的值, 注意 \${}需要手动加单引号

### map 集合类型的参数

若 mapper 接口中的方法需要的参数为多个时, 此时可以手动创建 map 集合, 将这些数据放在 map 中

只需要通过 \${} 和 #{} 访问 map 集合的键就可以获取相对应的值, 注意 ${} 需要手动加单引号

### 实体类类型的参数

若 mapper 接口中的方法参数为实体类对象时

此时可以使用 \${} 和 #{}, 通过访问实体类对象中的属性名获取属性值, 注意${}需要手动加单引号

### 使用 @Param 标识参数

可以通过 @Param 注解标识 mapper 接口中的方法参数

此时, 会将这些参数放在map集合中, 以@Param注解的value属性值为键, 以参数为值；以param1,param2...为键, 以参数为值；只需要通过${}和#{}访问map集合的键就可以获取相对应的值, 注意\${}需要手动加单引号



## MyBatis 的各种查询功能

### 查询一个实体类对象

```java
/**
* 根据用户id查询用户信息
* @param id
* @return
*/
User getUserById(@Param("id") int id);
```

```xml
<!--User getUserById(@Param("id") int id);-->
<select id="getUserById" resultType="User">
	select * from t_user where id = #{id}
</select>
```



### 查询一个list集合

```java
/**
* 查询所有用户信息
* @return
*/
List<User> getUserList();
```

```xml
<!--List<User> getUserList();-->
<select id="getUserList" resultType="User">
	select * from t_user
</select>
```



### 查询单个数据

```java
/**
* 查询用户的总记录数
* @return
* 在MyBatis中, 对于Java中常用的类型都设置了类型别名
* 例如: java.lang.Integer-->int|integer
* 例如: int-->_int|_integer
* 例如: Map-->map,List-->list
*/
int getCount();
```

```xml
<!--int getCount();-->
<select id="getCount" resultType="_integer">
    select count(id) from t_user
</select>
```



### 查询一条数据为map集合

```java
/**
* 根据用户id查询用户信息为map集合
* @param id
* @return
*/
Map<String, Object> getUserToMap(@Param("id") int id);
```

```xml
<!--Map<String, Object> getUserToMap(@Param("id") int id);-->
<select id="getUserToMap" resultType="map">
	select * from t_user where id = #{id}
</select>
<!--结果: {password=123456, sex=男, id=1, age=23, username=admin}-->
```



### 查询多条数据为map集合

**方式一**

```java
/**
* 查询所有用户信息为map集合
* @return
* 将表中的数据以map集合的方式查询, 一条数据对应一个map；若有多条数据, 就会产生多个map集合, 此
时可以将这些map放在一个list集合中获取
*/
List<Map<String, Object>> getAllUserToMap();
```

```xml
<!--Map<String, Object> getAllUserToMap();-->
<select id="getAllUserToMap" resultType="map">
	select * from t_user
</select>
```



**方式二**

```java
/**
* 查询所有用户信息为map集合
* @return
* 将表中的数据以map集合的方式查询, 一条数据对应一个map；若有多条数据, 就会产生多个map集合, 并
且最终要以一个map的方式返回数据, 此时需要通过@MapKey注解设置map集合的键, 值是每条数据所对应的
map集合
*/
@MapKey("id")
Map<String, Object> getAllUserToMap();
```

```xml
<!--Map<String, Object> getAllUserToMap();-->
<select id="getAllUserToMap" resultType="map">
	select * from t_user
</select>
结果: 
<!--
{
1={password=123456, sex=男, id=1, age=23, username=admin},
2={password=123456, sex=男, id=2, age=23, username=张三},
3={password=123456, sex=男, id=3, age=23, username=张三}
}
-->
```



## 特殊SQL的执行

### 模糊查询

```java
/**
* 测试模糊查询
* @param mohu
* @return
*/
List<User> testMohu(@Param("mohu") String mohu);
```

```xml
<!--List<User> testMohu(@Param("mohu") String mohu);-->
<select id="testMohu" resultType="User">
    <!--select * from t_user where username like '%${mohu}%'-->
    <!--select * from t_user where username like concat('%',#{mohu},'%')-->
    select * from t_user where username like "%"#{mohu}"%"
</select>
```



### 批量删除

```java
/**
* 批量删除
* @param ids
* @return
*/
int deleteMore(@Param("ids") String ids);
```

```xml
<!--int deleteMore(@Param("ids") String ids);-->
<delete id="deleteMore">
	delete from t_user where id in (${ids})
</delete>
```



### 动态设置表名

```java
/**
* 动态设置表名, 查询所有的用户信息
* @param tableName
* @return
*/
List<User> getAllUser(@Param("tableName") String tableName);
```

```xml
<!--List<User> getAllUser(@Param("tableName") String tableName);-->
<select id="getAllUser" resultType="User">
	select * from ${tableName}
</select>
```



### 添加功能获取自增的主键

t_clazz(clazz_id,clazz_name)

t_student(student_id,student_name,clazz_id)

1.   添加班级信息
2.   获取新添加的班级的 id
3.   为班级分配学生, 即将某学的班级id修改为新添加的班级的 id

```java
/**
* 添加用户信息
* @param user
* @return
* useGeneratedKeys: 设置使用自增的主键
* keyProperty: 因为增删改有统一的返回值是受影响的行数, 因此只能将获取的自增的主键放在传输的参
数user对象的某个属性中
*/
int insertUser(User user);
```

```xml
<!--int insertUser(User user);-->
<insert id="insertUser" useGeneratedKeys="true" keyProperty="id">
	insert into t_user values(null,#{username},#{password},#{age},#{sex})
</insert>
```



## 自定义映射 ResultMap

```sql
CREATE TABLE t_emp (
  eid      INT PRIMARY KEY AUTO_INCREMENT,
  emp_name VARCHAR(20),
  age      INT,
  sex      CHAR,
  email    VARCHAR(20),
  did      INT
)
```

```sql
CREATE TABLE t_dept (
  did       INT PRIMARY KEY AUTO_INCREMENT,
  dept_name VARCHAR(20)
)
```



### resultMap 处理字段和属性的映射关系

若字段名和实体类中的属性名不一致, 则可以通过 resultMap 设置自定义映射

```xml
<!--
resultMap: 设置自定义映射
属性: 
id: 表示自定义映射的唯一标识
type: 查询的数据要映射的实体类的类型
子标签: 
id: 设置主键的映射关系
result: 设置普通字段的映射关系
association: 设置多对一的映射关系
collection: 设置一对多的映射关系
属性: 
property: 设置映射关系中实体类中的属性名
column: 设置映射关系中表中的字段名
-->
<resultMap id="userMap" type="User">
    <id property="id" column="id"></id>
    <result property="userName" column="user_name"></result>
    <result property="password" column="password"></result>
    <result property="age" column="age"></result>
    <result property="sex" column="sex"></result>
</resultMap>
<!--List<User> testMohu(@Param("mohu") String mohu);-->
<select id="testMohu" resultMap="userMap">
    <!--select * from t_user where username like '%${mohu}%'-->
    select id,user_name,password,age,sex from t_user where user_name like
    concat('%',#{mohu},'%')
</select>
```

若字段名和实体类中的属性名不一致, 但是字段名符合数据库的规则(使用_), 实体类中的属性

名符合Java的规则(使用驼峰)此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系

*   可以通过为字段起别名的方式, 保证和实体类中的属性名保持一致

*   可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase, 可以在查询表中数据时, 自动将_类型的字段名转换为驼峰

例如: 字段名user_name, 设置了mapUnderscoreToCamelCase, 此时字段名就会转换为 userName



### 多对一映射处理

查询员工信息以及员工所对应的部门信息

**级联方式处理映射关系**

```xml
<resultMap id="empDeptMap" type="Emp">
	<id column="eid" property="eid"></id>
    <result column="ename" property="ename"></result>
    <result column="age" property="age"></result>
    <result column="sex" property="sex"></result>
    <result column="did" property="dept.did"></result>
    <result column="dname" property="dept.dname"></result>
</resultMap>
<!--Emp getEmpAndDeptByEid(@Param("eid") int eid);-->
<select id="getEmpAndDeptByEid" resultMap="empDeptMap">
    select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did =
    dept.did where emp.eid = #{eid}
</select>
```

**使用 association 处理映射关系**

```xml
<resultMap id="empDeptMap" type="Emp">
    <id column="eid" property="eid"></id>
    <result column="ename" property="ename"></result>
    <result column="age" property="age"></result>
    <result column="sex" property="sex"></result>
    <association property="dept" javaType="Dept">
        <id column="did" property="did"></id>
        <result column="dname" property="dname"></result>
    </association>
</resultMap>
<!--Emp getEmpAndDeptByEid(@Param("eid") int eid);-->
<select id="getEmpAndDeptByEid" resultMap="empDeptMap">
    select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did =
    dept.did where emp.eid = #{eid}
</select>
```

**分步查询**

查询员工信息

```java
/**
* 通过分步查询查询员工信息
* @param eid
* @return
*/
Emp getEmpByStep(@Param("eid") int eid);
```

```xml
<resultMap id="empDeptStepMap" type="Emp">
    <id column="eid" property="eid"></id>
    <result column="ename" property="ename"></result>
    <result column="age" property="age"></result>
    <result column="sex" property="sex"></result>
    <!--
    select: 设置分步查询, 查询某个属性的值的sql的标识(namespace.sqlId)
    column: 将sql以及查询结果中的某个字段设置为分步查询的条件
    -->
    <association property="dept"
    	select="com.atguigu.MyBatis.mapper.DeptMapper.getEmpDeptByStep" column="did">
    </association>
</resultMap>
<!--Emp getEmpByStep(@Param("eid") int eid);-->
<select id="getEmpByStep" resultMap="empDeptStepMap">
	select * from t_emp where eid = #{eid}
</select>
```

根据员工所对应的部门id查询部门信息

```java
/**
* 分步查询的第二步: 根据员工所对应的did查询部门信息
* @param did
* @return
*/
Dept getEmpDeptByStep(@Param("did") int did);
```

```xml
<!--Dept getEmpDeptByStep(@Param("did") int did);-->
<select id="getEmpDeptByStep" resultType="Dept">
	select * from t_dept where did = #{did}
</select>
```



### 一对多映射处理

**collection**

```xml
/**
* 根据部门id查新部门以及部门中的员工信息
* @param did
* @return
*/
Dept getDeptEmpByDid(@Param("did") int did);
<resultMap id="deptEmpMap" type="Dept">
    <id property="did" column="did"></id>
    <result property="dname" column="dname"></result>
    <!--
    ofType: 设置collection标签所处理的集合属性中存储数据的类型
    -->
    <collection property="emps" ofType="Emp">
        <id property="eid" column="eid"></id>
        <result property="ename" column="ename"></result>
        <result property="age" column="age"></result>
        <result property="sex" column="sex"></result>
    </collection>
</resultMap>
<!--Dept getDeptEmpByDid(@Param("did") int did);-->
<select id="getDeptEmpByDid" resultMap="deptEmpMap">
	select dept.*,emp.* from t_dept dept left join t_emp emp on dept.did =
    emp.did where dept.did = #{did}
</select>
```

**分步查询**

查询部门信息

```java
/**
* 分步查询部门和部门中的员工
* @param did
* @return
*/
Dept getDeptByStep(@Param("did") int did);
```

```xml
<resultMap id="deptEmpStep" type="Dept">
    <id property="did" column="did"></id>
    <result property="dname" column="dname"></result>
    <collection property="emps" fetchType="eager"
    	select="com.atguigu.MyBatis.mapper.EmpMapper.getEmpListByDid" column="did">
    </collection>
</resultMap>
<!--Dept getDeptByStep(@Param("did") int did);-->
<select id="getDeptByStep" resultMap="deptEmpStep">
	select * from t_dept where did = #{did}
</select>
```

根据部门id查询部门中的所有员工

```java
/**
* 根据部门id查询员工信息
* @param did
* @return
*/
List<Emp> getEmpListByDid(@Param("did") int did);
```

```xml
<!--List<Emp> getEmpListByDid(@Param("did") int did);-->
<select id="getEmpListByDid" resultType="Emp">
	select * from t_emp where did = #{did}
</select>
```

分步查询的优点: 可以实现延迟加载, 但是必须在核心配置文件中设置全局配置信息: lazyLoadingEnabled: 延迟加载的全局开关. 当开启时, 所有关联对象都会延迟加载

aggressiveLazyLoading: 当开启时, 任何方法的调用都会加载该对象的所有属性.  否则, 每个属性会按需加载此时就可以实现按需加载, 获取的数据是什么, 就只会执行相应的sql. 此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载, fetchType="lazy(延迟载)|eager(立即加载)"



## 动态SQL

Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能, 它存在的意义是为了解决拼接SQL语句字符串时的痛点问题. 

### if

if标签可通过test属性的表达式进行判断, 若表达式的结果为true, 则标签中的内容会执行；反之标签中的内容不会执行

```xml
<!--List<Emp> getEmpListByMoreTJ(Emp emp);-->
<select id="getEmpListByMoreTJ" resultType="Emp">
    select * from t_emp where 1=1
    <if test="ename != '' and ename != null">
        and ename = #{ename}
    </if>
    <if test="age != '' and age != null">
        and age = #{age}
    </if>
    <if test="sex != '' and sex != null">
        and sex = #{sex}
    </if>
</select>
```

### where

```xml
<select id="getEmpListByMoreTJ2" resultType="Emp">
    select * from t_emp
    <where>
        <if test="ename != '' and ename != null">
            ename = #{ename}
        </if>
        <if test="age != '' and age != null">
            and age = #{age}
        </if>
        <if test="sex != '' and sex != null">
            and sex = #{sex}
        </if>
    </where>
</select>
```

where和if一般结合使用: 

*   若 where 标签中的if条件都不满足, 则 where 标签没有任何功能, 即不会添加 where 关键字

*   若 where 标签中的if条件满足, 则 where 标签会自动添加 where 关键字, 并将条件最前方多余的 and 去掉

注意: where 标签不能去掉条件最后多余的 and



### trim

```xml
<select id="getEmpListByMoreTJ" resultType="Emp">
    select * from t_emp
    <trim prefix="where" suffixOverrides="and">
        <if test="ename != '' and ename != null">
        	ename = #{ename} and
        </if>
        <if test="age != '' and age != null">
        	age = #{age} and
        </if>
        <if test="sex != '' and sex != null">
        	sex = #{sex}
        </if>
    </trim>
</select>
```

trim 用于去掉或添加标签中的内容

常用属性: 

*   prefix: 在 trim 标签中的内容的前面添加某些内容

*   prefixOverrides: 在 trim 标签中的内容的前面去掉某些内容

*   suffix: 在 trim 标签中的内容的后面添加某些内容

*   suffixOverrides: 在t rim 标签中的内容的后面去掉某些内容

### choose、when、otherwise

choose、when、otherwise 相当于 if...else if..else

```xml
<!--List<Emp> getEmpListByChoose(Emp emp);-->
<select id="getEmpListByChoose" resultType="Emp">
    select <include refid="empColumns"></include> from t_emp
    <where>
        <choose>
            <when test="ename != '' and ename != null">
            	ename = #{ename}
            </when>
            <when test="age != '' and age != null">
            	age = #{age}
            </when>
            <when test="sex != '' and sex != null">
            	sex = #{sex}
            </when>
            <when test="email != '' and email != null">
            	email = #{email}
            </when>
        </choose>
    </where>
</select>
```

### foreach

```xml
<!--int insertMoreEmp(List<Emp> emps);-->
<insert id="insertMoreEmp">
    insert into t_emp values
    <foreach collection="emps" item="emp" separator=",">
    	(null,#{emp.ename},#{emp.age},#{emp.sex},#{emp.email},null)
    </foreach>
    </insert>
    <!--int deleteMoreByArray(int[] eids);-->
    <delete id="deleteMoreByArray">
    	delete from t_emp where
    <foreach collection="eids" item="eid" separator="or">
    	eid = #{eid}
    </foreach>
    </delete>
    <!--int deleteMoreByArray(int[] eids);-->
    <delete id="deleteMoreByArray">
    	delete from t_emp where eid in
    <foreach collection="eids" item="eid" separator="," open="(" close=")">
    	#{eid}
    </foreach>
</delete>
```

属性: 

*   collection: 设置要循环的数组或集合

*   item: 表示集合或数组中的每一个数据

*   separator: 设置循环体之间的分隔符

*   open: 设置foreach标签中的内容的开始符

*   close: 设置foreach标签中的内容的结束符

### SQL 片段

sql 片段, 可以记录一段公共 sql 片段, 在使用的地方通过 include 标签进行引入

```xml
<sql id="empColumns">
	eid,ename,age,sex,did
</sql>
select <include refid="empColumns"></include> from t_emp
```



## MyBatis 的缓存

### MyBatis 的一级缓存

一级缓存是 SqlSession 级别的, 通过同一个 SqlSession 查询的数据会被缓存, 下次查询相同的数据, 就会从缓存中直接获取, 不会从数据库重新访问

使一级缓存失效的四种情况

1)   不同的SqlSession对应不同的一级缓存
2)   同一个SqlSession但是查询条件不同
3)   同一个SqlSession两次查询期间执行了任何一次增删改操作
4)   同一个SqlSession两次查询期间手动清空了缓存



### MyBatis 的二级缓存

二级缓存是SqlSessionFactory级别, 通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存, 此后若再次执行相同的查询语句, 结果就会从缓存中获取

二级缓存开启的条件: 

*   在核心配置文件中, 设置全局配置属性cacheEnabled="true", 默认为true, 不需要设置

*   在映射文件中设置标签\<cache />

*   二级缓存必须在SqlSession关闭或提交之后有效

*   查询的数据所转换的实体类类型必须实现序列化的接口

使二级缓存失效的情况:\

两次查询之间执行了任意的增删改, 会使一级和二级缓存同时失效



### 二级缓存的相关配置

在 mapper 配置文件中添加的 cache 标签可以设置一些属性

*   eviction 属性: 缓存回收策略

    LRU(Least Recently Used) – 最近最少使用的: 移除最长时间不被使用的对象. 

    FIFO(First in First out) – 先进先出: 按对象进入缓存的顺序来移除它们. 

    SOFT – 软引用: 移除基于垃圾回收器状态和软引用规则的对象. 

    WEAK – 弱引用: 更积极地移除基于垃圾收集器状态和弱引用规则的对象. 

    默认的是 LRU. 

*   flushInterval 属性: 刷新间隔, 单位毫秒

    默认情况是不设置, 也就是没有刷新间隔, 缓存仅仅调用语句时刷新

*   size 属性: 引用数目, 正整数

    代表缓存最多可以存储多少个对象, 太大容易导致内存溢出

*   readOnly 属性: 只读, true/false

    true: 只读缓存；会给所有调用者返回缓存对象的相同实例. 因此这些对象不能被修改. 这提供了很重要的性能优势. 

    false: 读写缓存；会返回缓存对象的拷贝(通过序列化). 这会慢一些, 但是安全, 因此默认是false. 



### MyBatis缓存查询的顺序

先查询二级缓存, 因为二级缓存中可能会有其他程序已经查出来的数据, 可以拿来直接使用. 

如果二级缓存没有命中, 再查询一级缓存

如果一级缓存也没有命中, 则查询数据库

SqlSession 关闭之后, 一级缓存中的数据会写入二级缓存



### 整合第三方缓存EHCache

添加依赖

```xml
<!-- Mybatis EHCache整合包 -->
<dependency>
    <groupId>org.mybatis.caches</groupId>
    <artifactId>mybatis-ehcache</artifactId>
    <version>1.2.1</version>
</dependency>
<!-- slf4j日志门面的一个具体实现 -->
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.3</version>
</dependency>
```

各jar包功能

| jar包名称       | 作用                              |
| --------------- | --------------------------------- |
| mybatis-ehcache | Mybatis 和 EHCache 的整合包       |
| ehcache         | EHCache 核心包                    |
| slf4j-api       | SLF4J 日志门面包                  |
| logback-classic | 支持 SLF4J 门面接口的一个具体实现 |

创建 EHCache 的配置文件 ehcache.xml

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="../config/ehcache.xsd">
<!-- 磁盘保存路径 -->
<diskStore path="D:\atguigu\ehcache"/>
<defaultCache
    maxElementsInMemory="1000"
    maxElementsOnDisk="10000000"
    eternal="false"
    overflowToDisk="true"
    timeToIdleSeconds="120"
    timeToLiveSeconds="120"
    diskExpiryThreadIntervalSeconds="120"
    memoryStoreEvictionPolicy="LRU">
</defaultCache>
</ehcache>
```

设置二级缓存的类型

```xml
<cache type="org.mybatis.caches.ehcache.EhcacheCache"/>
```

加入 logback 日志

存在 SLF4J 时, 作为简易日志的 log4j 将失效, 此时我们需要借助 SLF4J 的具体实现 logback 来打印日志

创建 logback 的配置文件 logback.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration debug="true">
<!-- 指定日志输出的位置 -->
<appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
<encoder>
<!-- 日志输出的格式 -->
<!-- 按照顺序分别是: 时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 -
->
<pattern>[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger]
[%msg]%n</pattern>
</encoder>
</appender>
<!-- 设置全局日志级别. 日志级别按顺序分别是: DEBUG、INFO、WARN、ERROR -->
<!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志.  -->
<root level="DEBUG">
<!-- 指定打印日志的appender, 这里通过“STDOUT”引用了前面配置的appender -->
<appender-ref ref="STDOUT" />
</root>
<!-- 根据特殊需求指定局部日志级别 -->
<logger name="com.atguigu.crowd.mapper" level="DEBUG"/>
</configuration>
```

EHCache 配置文件说明

| 属性名                          | 是否必须 | 作用                                                         |
| ------------------------------- | -------- | ------------------------------------------------------------ |
| maxElementsInMemory             | 是       | 在内存中缓存的 element 的最大数目                            |
| maxElementsOnDisk               | 是       | 在磁盘上缓存的element的最大数目, 若是0表示无穷大             |
| eternal                         | 是       | 设定缓存的elements是否永远不过期.  如果为true, 则缓存的数据始终有效,  如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断 |
| overflowToDisk                  | 是       | 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上      |
| timeToIdleSeconds               | 否       | 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时,  这些数据便会删除, 默认值是0,也就是可闲置时间无穷大 |
| timeToLiveSeconds               | 否       | 缓存element的有效生命期, 默认是0.,也就是element存活时间无穷大 |
| diskSpoolBufferSizeMB           | 否       | DiskStore(磁盘缓存)的缓存区大小. 默认是30MB. 每个Cache都应该有自己的一个缓冲区 |
| diskPersistent                  | 否       | 在VM重启的时候是否启用磁盘保存EhCache中的数据, 默认是false.  |
| diskExpiryThreadIntervalSeconds | 否       | 磁盘缓存的清理线程运行间隔, 默认是120秒. 每个120s,  相应的线程会进行一次EhCache中数据的清理工作 |
| memoryStoreEvictionPolicy       | 否       | 当内存缓存达到最大, 有新的element加入的时候,  移除缓存中element的策略.  默认是LRU(最近最少使用), 可选的有LFU(最不常使用)和FIFO(先进先出) |





## MyBatis 的逆向工程

正向工程: 先创建 Java 实体类, 由框架负责根据实体类生成数据库表. Hibernate 是支持正向工程的. 

逆向工程: 先创建数据库表, 由框架负责根据数据库表, 反向生成如下资源: 

*   Java 实体类
*   Mapper 接口
*   Mapper 映射文件

### 创建逆向工程的步骤

添加依赖和插件

```xml
<!-- 依赖MyBatis核心包 -->
<dependencies>
    <dependency>
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis</artifactId>
        <version>3.5.7</version>
    </dependency>
</dependencies>
<!-- 控制Maven在构建过程中相关配置 -->
<build>
    <!-- 构建过程中用到的插件 -->
    <plugins>
    <!-- 具体插件, 逆向工程的操作是以构建过程中插件形式出现的 -->
        <plugin>
        <groupId>org.mybatis.generator</groupId>
        <artifactId>mybatis-generator-maven-plugin</artifactId>
        <version>1.3.0</version>
            <!-- 插件的依赖 -->
            <dependencies>
                <!-- 逆向工程的核心依赖 -->
                <dependency>
                    <groupId>org.mybatis.generator</groupId>
                    <artifactId>mybatis-generator-core</artifactId>
                    <version>1.3.2</version>
                </dependency>
                <!-- 数据库连接池 -->
                <dependency>
                    <groupId>com.mchange</groupId>
                    <artifactId>c3p0</artifactId>
                    <version>0.9.2</version>
                </dependency>
                <!-- MySQL驱动 -->
                <dependency>
                    <groupId>mysql</groupId>
                    <artifactId>mysql-connector-java</artifactId>
                    <version>5.1.8</version>
                </dependency>
            </dependencies>
        </plugin>
    </plugins>
</build>
```

创建 MyBatis 的核心配置文件

创建逆向工程的配置文件

文件名必须是: generatorConfig.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <!--
    targetRuntime: 执行生成的逆向工程的版本
    MyBatis3Simple: 生成基本的CRUD(清新简洁版)
    MyBatis3: 生成带条件的CRUD(奢华尊享版)
    -->
    <context id="DB2Tables" targetRuntime="MyBatis3Simple">
    <!-- 数据库的连接信息 -->
    <jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mybatis" userId="root" password="123456">
    </jdbcConnection>
    <!-- javaBean的生成策略-->
    <javaModelGenerator targetPackage="com.atguigu.mybatis.bean"
    targetProject=".\src\main\java">
        <property name="enableSubPackages" value="true" />
        <property name="trimStrings" value="true" />
    </javaModelGenerator>
    <!-- SQL映射文件的生成策略 -->
    <sqlMapGenerator targetPackage="com.atguigu.mybatis.mapper"
    targetProject=".\src\main\resources">
    	<property name="enableSubPackages" value="true" />
    </sqlMapGenerator>
    <!-- Mapper接口的生成策略 -->
    <javaClientGenerator type="XMLMAPPER"
    targetPackage="com.atguigu.mybatis.mapper" targetProject=".\src\main\java">
    	<property name="enableSubPackages" value="true" />
    </javaClientGenerator>
        <!-- 逆向分析的表 -->
        <!-- tableName设置为*号, 可以对应所有表, 此时不写domainObjectName -->
        <!-- domainObjectName属性指定生成出来的实体类的类名 -->
        <table tableName="t_emp" domainObjectName="Emp"/>
        <table tableName="t_dept" domainObjectName="Dept"/>
    </context>
</generatorConfiguration>
```

执行 MBG 插件的 generate 目标



### QBC 查询

```java
@Test
public void testMBG() throws IOException {
    InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
    SqlSession sqlSession = new
    SqlSessionFactoryBuilder().build(is).openSession(true);
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    EmpExample empExample = new EmpExample();
    //创建条件对象, 通过andXXX方法为SQL添加查询添加, 每个条件之间是and关系
    empExample.createCriteria().andEnameLike("a").andAgeGreaterThan(20).andDidIsNot
    Null();
    //将之前添加的条件通过or拼接其他条件
    empExample.or().andSexEqualTo("男");
    List<Emp> list = mapper.selectByExample(empExample);
    for (Emp emp : list) {
    System.out.println(emp);
    }
}
```



## 分页插件

### 分页插件使用步骤

添加依赖

```xml
<!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper -->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
    <version>5.2.0</version>
</dependency>
```

配置分页插件

在MyBatis的核心配置文件中配置插件

```xml
<plugins>
    <!--设置分页插件-->
    <plugin interceptor="com.github.pagehelper.PageInterceptor"></plugin>
</plugins>
```

### 分页插件的使用

在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能

*   pageNum: 当前页的页码
*   pageSize: 每页显示的条数

在查询获取list集合之后, 使用PageInfo\<T> pageInfo = new PageInfo<>(List\<T> list, intnavigatePages)获取分页相关数据

*   list: 分页之后的数据
*   navigatePages: 导航分页的页码数

分页相关数据

PageInfo{

​	pageNum=8, pageSize=4, size=2, startRow=29, endRow=30, total=30, pages=8,

​	list=Page{count=true, pageNum=8, pageSize=4, startRow=28, endRow=32, total=30,

​	pages=8, reasonable=false, pageSizeZero=false},

​	prePage=7, nextPage=0, isFirstPage=false, isLastPage=true, hasPreviousPage=true,

​	hasNextPage=false, navigatePages=5, navigateFirstPage4, navigateLastPage8,

​	navigatepageNums=[4, 5, 6, 7, 8]

}

常用数据: 

*   pageNum: 当前页的页码

*   pageSize: 每页显示的条数

*   size: 当前页显示的真实条数

*   total: 总记录数

*   pages: 总页数

*   prePage: 上一页的页码

*   nextPage: 下一页的页码

*   isFirstPage/isLastPage: 是否为第一页/最后一页

*   hasPreviousPage/hasNextPage: 是否存在上一页/下一页

*   navigatePages: 导航分页的页码数

*   navigatepageNums: 导航分页的页码, [1,2,3,4,5]



## MyBatis 面试集锦

### #{}和${}的区别是什么? 

\${}是Properties文件中的变量占位符, 它可以用于标签属性值和sql内部, 属于静态文本替换, 比如${driver}会被静态替换为com.mysql.jdbc.Driver. 

\#{}是sql的参数占位符, Mybatis会将sql中的#{}替换为?号, 在sql执行前会使用PreparedStatement的参数设置方法, 按序给sql的?号占位符设置参数值, 比如ps.setInt(0, parameterValue), #{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值, 相当于param.getItem().getName(). 

### Xml映射文件中, 除了常见的select|insert|updae|delete标签之外, 还有哪些标签? 

还有很多其他的标签, \<resultMap>、\<parameterMap>、\<sql>、\<include>、\<selectKey>, 加上动态sql的9个标签, trim|where|set|foreach|if|choose|when|otherwise|bind等, 其中\<sql>为sql片段标签, 通过\<include>标签引入sql片段, \<selectKey>为不支持自增的主键生成策略标签. 

#### 最佳实践中, 通常一个Xml映射文件, 都会写一个Dao接口与之对应, 请问, 这个Dao接口的工作原理是什么? Dao接口里的方法, 参数不同时, 方法能重载吗? 

Dao接口, 就是人们常说的Mapper接口, 接口的全限名, 就是映射文件中的namespace的值, 接口的方法名, 就是映射文件中MappedStatement的id值, 接口方法内的参数, 就是传递给sql的参数. 

Mapper接口是没有实现类的, 当调用接口方法时, 接口全限名+方法名拼接字符串作为key值, 可唯一定位一个MappedStatement, 举例: com.mybatis3.mappers.StudentDao.findStudentById, 可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement. 在Mybatis中, 每一个\<select>、\<insert>、\<update>、\<delete>标签, 都会被解析为一个MappedStatement对象. 

Dao接口里的方法, 是不能重载的, 因为是全限名+方法名的保存和寻找策略. 

Dao接口的工作原理是JDK动态代理, Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象, 代理对象proxy会拦截接口方法, 转而执行MappedStatement所代表的sql, 然后将sql执行结果返回. 

### Mybatis是如何进行分页的? 分页插件的原理是什么? 

Mybatis使用RowBounds对象进行分页, 它是针对ResultSet结果集执行的内存分页, 而非物理分页, 可以在sql内直接书写带有物理分页的参数来完成物理分页功能, 也可以使用分页插件来完成物理分页. 

分页插件的基本原理是使用Mybatis提供的插件接口, 实现自定义插件, 在插件的拦截方法内拦截待执行的sql, 然后重写sql, 根据dialect方言, 添加对应的物理分页语句和物理分页参数. 

举例: select * from student, 拦截sql后重写为: select t.* from (select * from student)t limit 0, 10

### 简述Mybatis的插件运行原理, 以及如何编写一个插件

Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件, Mybatis使用JDK的动态代理, 为需要拦截的接口生成代理对象以实现接口方法拦截功能, 每当执行这4种接口对象的方法时, 就会进入拦截方法, 具体就是InvocationHandler的invoke()方法, 当然, 只会拦截那些你指定需要拦截的方法. 

实现Mybatis的Interceptor接口并复写intercept()方法, 然后在给插件编写注解, 指定要拦截哪一个接口的哪些方法即可, 记住, 别忘了在配置文件中配置你编写的插件. 

### Mybatis执行批量插入, 能返回数据库主键列表吗? 

能, JDBC都能, Mybatis当然也能. 

### Mybatis动态sql是做什么的? **都有哪些动态sql? 能简述一下动态sql的执行原理不? 

Mybatis动态sql可以让我们在Xml映射文件内, 以标签的形式编写动态sql, 完成逻辑判断和动态拼接sql的功能, Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind. 

其执行原理为, 使用OGNL从sql参数对象中计算表达式的值, 根据表达式的值动态拼接sql, 以此来完成动态sql的功能. 

### Mybatis是如何将sql执行结果封装为目标对象并返回的? 都有哪些映射形式? 

第一种是使用\<resultMap>标签, 逐一定义列名和对象属性名之间的映射关系. 第二种是使用sql列的别名功能, 将列别名书写为对象属性名, 比如T_NAME AS NAME, 对象属性名一般是name, 小写, 但是列名不区分大小写, Mybatis会忽略列名大小写, 智能找到与之对应对象属性名, 你甚至可以写成T_NAME AS NaMe, Mybatis一样可以正常工作. 

有了列名与属性名的映射关系后, Mybatis通过反射创建对象, 同时使用反射给对象的属性逐一赋值并返回, 那些找不到映射关系的属性, 是无法完成赋值的. 

### Mybatis能执行一对一、一对多的关联查询吗? 都有哪些实现方式, 以及它们之间的区别. 

能, Mybatis不仅可以执行一对一、一对多的关联查询, 还可以执行多对一, 多对多的关联查询, 多对一查询, 其实就是一对一查询, 只需要把selectOne()修改为selectList()即可；多对多查询, 其实就是一对多查询, 只需要把selectOne()修改为selectList()即可. 

关联对象查询, 有两种实现方式, 一种是单独发送一个sql去查询关联对象, 赋给主对象, 然后返回主对象. 另一种是使用嵌套查询, 嵌套查询的含义为使用join查询, 一部分列是A对象的属性值, 另外一部分列是关联对象B的属性值, 好处是只发一个sql查询, 就可以把主对象和其关联对象查出来. 

那么问题来了, join查询出来100条记录, 如何确定主对象是5个, 而不是100个? 其去重复的原理是\<resultMap>标签内的\<id>子标签, 指定了唯一确定一条记录的id列, Mybatis根据\<id>列值来完成100条记录的去重复功能, \<id>可以有多个, 代表了联合主键的语意. 

同样主对象的关联对象, 也是根据这个原理去重复的, 尽管一般情况下, 只有主对象会有重复记录, 关联对象一般不会重复. 

举例: 下面join查询出来6条记录, 一、二列是Teacher对象列, 第三列为Student对象列, Mybatis去重复处理后, 结果为1个老师6个学生, 而不是6个老师6个学生.  

| t_id | t_name  | s_id |
| ---- | ------- | ---- |
| 1    | teacher | 38   |
| 1    | teacher | 39   |
| 1    | teacher | 40   |
| 1    | teacher | 41   |
| 1    | teacher | 42   |
| 1    | teacher | 43   |

### Mybatis是否支持延迟加载? 如果支持, 它的实现原理是什么? 

Mybatis仅支持association关联对象和collection关联集合对象的延迟加载, association指的就是一对一, collection指的就是一对多查询. 在Mybatis配置文件中, 可以配置是否启用延迟加载lazyLoadingEnabled=true|false. 

它的原理是, 使用CGLIB创建目标对象的代理对象, 当调用目标方法时, 进入拦截器方法, 比如调用a.getB().getName(), 拦截器invoke()方法发现a.getB()是null值, 那么就会单独发送事先保存好的查询关联B对象的sql, 把B查询上来, 然后调用a.setB(b), 于是a的对象b属性就有值了, 接着完成a.getB().getName()方法的调用. 这就是延迟加载的基本原理. 

当然了, 不光是Mybatis, 几乎所有的包括Hibernate, 支持延迟加载的原理都是一样的. 

### Mybatis的Xml映射文件中, 不同的Xml映射文件, id是否可以重复? 

不同的Xml映射文件, 如果配置了namespace, 那么id可以重复；如果没有配置namespace, 那么id不能重复；毕竟namespace不是必须的, 只是最佳实践而已. 

原因就是namespace+id是作为Map<String, MappedStatement>的key使用的, 如果没有namespace, 就剩下id, 那么, id重复会导致数据互相覆盖. 有了namespace, 自然id就可以重复, namespace不同, namespace+id自然也就不同. 

### Mybatis中如何执行批处理? 

使用BatchExecutor完成批处理. 

### Mybatis都有哪些Executor执行器? 它们之间的区别是什么? 

Mybatis有三种基本的Executor执行器, SimpleExecutor、ReuseExecutor、BatchExecutor. 

SimpleExecutor: 每执行一次update或select, 就开启一个Statement对象, 用完立刻关闭Statement对象. 

ReuseExecutor: 执行update或select, 以sql作为key查找Statement对象, 存在就使用, 不存在就创建, 用完后, 不关闭Statement对象, 而是放置于Map<String, Statement>内, 供下一次使用. 简言之, 就是重复使用Statement对象. 

BatchExecutor: 执行update(没有select, JDBC批处理不支持select), 将所有sql都添加到批处理中(addBatch()), 等待统一执行(executeBatch()), 它缓存了多个Statement对象, 每个Statement对象都是addBatch()完毕后, 等待逐一执行executeBatch()批处理. 与JDBC批处理相同. 

作用范围: Executor的这些特点, 都严格限制在SqlSession生命周期范围内. 

### Mybatis中如何指定使用哪一种Executor执行器? 

在Mybatis配置文件中, 可以指定默认的ExecutorType执行器类型, 也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数. 

### Mybatis是否可以映射Enum枚举类? 

Mybatis可以映射枚举类, 不单可以映射枚举类, Mybatis可以映射任何对象到表的一列上. 映射方式为自定义一个TypeHandler, 实现TypeHandler的setParameter()和getResult()接口方法. 

TypeHandler有两个作用, 一是完成从javaType至jdbcType的转换, 二是完成jdbcType至javaType的转换, 体现为setParameter()和getResult()两个方法, 分别代表设置sql问号占位符参数和获取列查询结果. 

### Mybatis映射文件中, 如果A标签通过include引用了B标签的内容, 请问, B标签能否定义在A标签的后面, 还是说必须定义在A标签的前面? 

虽然Mybatis解析Xml映射文件是按照顺序解析的, 但是, 被引用的B标签依然可以定义在任何地方, Mybatis都可以正确识别. 

原理是, Mybatis解析A标签, 发现A标签引用了B标签, 但是B标签尚未解析到, 尚不存在, 此时, Mybatis会将A标签标记为未解析状态, 然后继续解析余下的标签, 包含B标签, 待所有标签解析完毕, Mybatis会重新解析那些被标记为未解析的标签, 此时再解析A标签时, B标签已经存在, A标签也就可以正常解析完成了. 

### 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系? 

Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部. 在Xml映射文件中, \<parameterMap>标签会被解析为ParameterMap对象, 其每个子元素会被解析为ParameterMapping对象. 

\<resultMap>标签会被解析为ResultMap对象, 其每个子元素会被解析为ResultMapping对象. 每一个\<select>、\<insert>、\<update>、\<delete>标签均会被解析为MappedStatement对象, 标签内的sql会被解析为BoundSql对象. 

### 为什么说Mybatis是半自动ORM映射工具? 它与全自动的区别在哪里? 

Hibernate属于全自动ORM映射工具, 使用Hibernate查询关联对象或者关联集合对象时, 可以根据对象关系模型直接获取, 所以它是全自动的. 而Mybatis在查询关联对象或关联集合对象时, 需要手动编写sql来完成, 所以, 称之为半自动ORM映射工具. 

