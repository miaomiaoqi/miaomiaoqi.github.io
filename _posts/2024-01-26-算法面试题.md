---
layout: post
title: 算法面试题
categories: [java]
description: 
keywords: 
---

* content
{:toc}




## 1. 一个数组取第 k 个最大值，快排

## 2. 写什么边界条件（口述，不一定准确）

## 3. 链表k个一组反转

## 5. 给了一个数组，让打印其中的重复元素int [] arr = {8,1,6,3,21}

## 6. 一个数组先降后升，求最小值

## 7. 代码实现根号运算，不能调用函数

## 8. 算法是两个特别长的字符串相乘，需要包含不同的字符类型--候选人的解法是未考虑到不同类型的字符，面试官不太满意

## 10. 一个阻塞队列

## 12. 一个数组，里面的元素先递增再递减，获取最大值的下标，要求算法时间复杂度小于O（N）







## 13 两数求和

给定一个整数数组 nums 和一个目标值 target, 请你在该数组中找出和为目标值的那两个整数, 并返回他们的数组下标
可以假设每种输入只会对应一个答案. 但是数组中的一个元素不能使用两遍
示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9. 所以返回[0, 1]

### 暴力求解

```java
public static int[] twoSum(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            if (target - nums[i] == nums[j]) {
                return new int[]{i, j};
            }
        }
    }
    return null;
}
```



### 优化解法

```java
public static void main(String[] args) {
    int[] nums = new int[]{2, 7, 11, 15};
    int target = 9;
    int[] myIndex = twoSum2(nums, target);
    for (int index : myIndex) {
        System.out.println(index);
    }
}

public static int[] twoSum2(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int key = target - nums[i];
        if (map.containsKey(key)) {
            return new int[]{map.get(key), i};
        }
        map.put(nums[i], i);
    }
    return null;
}
```



## 14 给定一个数 m, 求大于该数的最小 2 的 n 次幂, 求 n



## 15 给定一个链表, 删除相邻相同的数据项. 比如 2 -> 2-> 3 返回 2 -> 3



## 16 LRU 算法

```java
public class LRUCache {

    private Node head;
    private Node end;

    // 缓存存储上限
    private int limit;

    private HashMap<String, Node> hashMap;

    public LRUCache(int limit) {
        this.limit = limit;
        this.hashMap = new HashMap<String, Node>();
    }

    public String get(String key) {
        Node node = hashMap.get(key);
        if (node == null) {
            return null;
        }
        refreshNode(node);
        return node.value;
    }

    public void put(String key, String value) {
        Node node = hashMap.get(key);
        if (node == null) {
            // 如果key不存在, 插入K-V
            if (hashMap.size() >= limit) {
                String oldKey = removeNode(head);
                hashMap.remove(oldKey);
            }
            node = new Node(key, value);
            addNode(node);
            hashMap.put(key, node);
        } else {
            // 如果key存在, 刷新value
            node.value = value;
            refreshNode(node);
        }
    }

    public void remove(String key) {
        Node node = hashMap.get(key);
        this.removeNode(node);
        hashMap.remove(key);
    }

    /**
     * 刷新节点
     *
     * @author miaoqi
     * @date 2018/11/13
     * @param node
     * @return
     */
    private void refreshNode(Node node) {
        // 如果访问的是尾节点, 无需移动节点
        if (node == end) {
            return;
        }
        // 移除节点
        this.removeNode(node);
        // 重新插入节点
        this.addNode(node);
    }

    /**
     * 删除节点
     *
     * @author miaoqi
     * @date 2018/11/13
     * @param node
     * @return
     */
    private String removeNode(Node node) {
        if (node == end) {
            // 移除尾节点
            end = end.pre;
        } else if (node == head) {
            // 移除头结点
            head = head.next;
        } else {
            // 移除中间节点
            node.pre.next = node.next;
            node.next.pre = node.pre;
        }
        return node.key;
    }

    /**
     * 尾部插入
     *
     * @author miaoqi
     * @date 2018/11/13
     * @param node 要插入的节点
     * @return
     */
    private void addNode(Node node) {
        if (end != null) {
            end.next = node;
            node.pre = end;
            node.next = null;
        }
        end = node;
        if (head == null) {
            head = end;
        }
    }

    /**
     * 数据节点
     *
     * @author miaoqi
     * @date 2018/11/13
     */
    class Node {
        public String key;

        public String value;

        public Node pre;

        public Node next;

        Node(String key, String value) {
            this.key = key;
            this.value = value;
        }
    }

    public static void main(String[] args) {
        LRUCache lruCache = new LRUCache(5);
        lruCache.put("001", "用户1信息");
        lruCache.put("002", "用户2信息");
        lruCache.put("003", "用户3信息");
        lruCache.put("004", "用户4信息");
        lruCache.put("005", "用户5信息");
        lruCache.get("002");
        lruCache.put("004", "用户4更新信息");
        lruCache.put("006", "用户6信息");
        System.out.println(lruCache.get("001"));
        System.out.println(lruCache.get("006"));
    }
}
```



## 17 环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) {
 * val = x;
 * next = null;
 * }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (fast == slow) {
                return true;
            }
        }
        return false;
    }
}
```



## 18 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        while(head != null) {
            ListNode next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
}
```



## 19 有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1.  左括号必须用相同类型的右括号闭合。
2.  左括号必须以正确的顺序闭合。
3.  每个右括号都有一个对应的相同类型的左括号。

```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack();
        char[] array = s.toCharArray();
        for (char c : array) {
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else {
                if (stack.isEmpty()) {
                    return false;
                }
                char t = stack.pop();
                if (c == ')' && t != '(') {
                    return false;
                }
                if (c == '}' && t != '{') {
                    return false;
                }
                if (c == ']' && t != '[') {
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }
}
```



## 20 删除链表的节点

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

题目保证链表中节点的值互不相同

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        if(head != null && head.val == val){
            return head.next;
        }
        ListNode pre = head;
        ListNode cur = head.next;
        while(cur != null && cur.val != val){
            pre = cur;
            cur = cur.next;
        }
        if(cur != null) {
            pre.next = cur.next;
        }
        return head;
    }
}

class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        if (head != null && head.val == val) {
            ListNode next = head.next;
            head.next = null;
            return next;
        }
        ListNode pre = head;
        ListNode cur = head.next;
        while(cur != null) {
            if(cur.val == val){
                pre.next = cur.next;
                cur.next = null;
            }
            pre = cur;
            cur = cur.next;
        }
        return head;
    }
}
```



## 21 判断对称二叉树

请设计一个函数判断一棵二叉树是否 **轴对称** 。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public boolean checkSymmetricTree(TreeNode root) {
        if (root == null) {
            return true;
        }
        Queue<TreeNode> queue = new LinkedList();
        queue.add(root.left);
        queue.add(root.right);
        while (!queue.isEmpty()) {
            TreeNode left = queue.poll();
            TreeNode right = queue.poll();
            if (left == null && right == null) {
                continue;
            }
            if (left == null || right == null || left.val != right.val) {
                return false;
            }
            queue.add(left.left);
            queue.add(right.right);
            queue.add(left.right);
            queue.add(right.left);
        }
        return true;
    }
}
```

## 22 彩灯装饰记录(树的层序遍历)

一棵圣诞树记作根节点为 `root` 的二叉树，节点值为该位置装饰彩灯的颜色编号。请按照从 **左** 到 **右** 的顺序返回每一层彩灯编号。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public int[] decorateRecord(TreeNode root) {
        if(root == null) {
            return null;
        }
        Queue<TreeNode> queue = new LinkedList();
        queue.add(root);
        List<Integer> list = new ArrayList();
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            list.add(node.val);
            if(node.left != null){
                queue.add(node.left);
            }
            if(node.right != null) {
                queue.add(node.right);
            }
        }
        int[] result = new int[list.size()];
        for(int i = 0; i < list.size(); i++) {
            result[i] = list.get(i);
        }
        return result;
    }
}
```



## 23 两数相加

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode result = new ListNode((l1.val + l2.val) % 10);
        ListNode resultCur = result;
        int jinwei = (l1.val + l2.val) / 10;
        l1 = l1.next;
        l2 = l2.next;
        while (l1 != null && l2 != null) {
            int val = (l1.val + l2.val + jinwei) % 10;
            jinwei = (l1.val + l2.val + jinwei) / 10;
            resultCur.next = new ListNode(val);
            resultCur = resultCur.next;
            l1 = l1.next;
            l2 = l2.next;
        }
        while (l1 != null) {
            int val = (l1.val + jinwei) % 10;
            jinwei = (l1.val + jinwei) / 10;
            resultCur.next = new ListNode(val);
            resultCur = resultCur.next;
            l1 = l1.next;
        }
        while (l2 != null) {
            int val = (l2.val + jinwei) % 10;
            jinwei = (l2.val + jinwei) / 10;
            resultCur.next = new ListNode(val);
            resultCur = resultCur.next;
            l2 = l2.next;
        }
        if (jinwei > 0) {
            resultCur.next = new ListNode(1);
        }
        return result;
    }
}
```

## 24 二叉树前中后序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList();
        preOrder(root, result);
        return result;
    }

    public void preOrder(TreeNode node, List<Integer> result) {
        if (node == null) {
            return;
        }
        result.add(node.val);
        preOrder(node.left, result);
        preOrder(node.right, result);
    }
}
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList();
        inOrder(root, result);
        return result;
    }

    public void inOrder(TreeNode node, List<Integer> result) {
        if (node == null) {
            return;
        }
        inOrder(node.left, result);
        result.add(node.val);
        inOrder(node.right, result);
    }
}
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList();
        postOrder(root, result);
        return result;
    }

    public void postOrder(TreeNode node, List<Integer> result) {
        if (node == null) {
            return;
        }
        postOrder(node.left, result);
        postOrder(node.right, result);
        result.add(node.val);
    }
}
```



## 25 按序打印

三个不同的线程 A、B、C 将会共用一个 `Foo` 实例。

-   线程 A 将会调用 `first()` 方法
-   线程 B 将会调用 `second()` 方法
-   线程 C 将会调用 `third()` 方法

请设计修改程序，以确保 `second()` 方法在 `first()` 方法之后被执行，`third()` 方法在 `second()` 方法之后被执行。

```java
class Foo {

    private Lock lock = new ReentrantLock();
    private Condition conditionA = lock.newCondition();
    private Condition conditionB = lock.newCondition();
    private Condition conditionC = lock.newCondition();
    private int num = 1;

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        lock.lock();
        if (num != 1) {
            conditionA.await();
        }
        // printFirst.run() outputs "first". Do not change or remove this line.
        printFirst.run();
        num = 2;
        conditionB.signal();
        lock.unlock();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        lock.lock();
        if (num != 2) {
            conditionB.await();
        }
        // printSecond.run() outputs "second". Do not change or remove this line.
        printSecond.run();
        num = 3;
        conditionC.signal();
        lock.unlock();
    }

    public void third(Runnable printThird) throws InterruptedException {
        lock.lock();
        if (num != 3) {
            conditionC.await();
        }
        // printThird.run() outputs "third". Do not change or remove this line.
        printThird.run();
        num = 1;
        conditionC.signal();
        lock.unlock();
    }
}
```



## 26 返回倒数第 k 个链表

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthToLast(ListNode head, int k) {
        ListNode temp = head;
        while (--k >= 0) {
            head = head.next;
        }
        while (head != null) {
            head = head.next;
            temp = temp.next;
        }
        return temp.val;
    }
}
```



## 27 相交链表

给定两个单链表的头节点 `headA` 和 `headB` ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

```java
package com.miaoqi.juc.lock;

public class Solution {

    public static class ListNode {

        int val;
        ListNode next;

        ListNode(int x) {
            this.val = x;
            this.next = null;
        }

    }

    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode nodeA = headA, nodeB = headB;
        while (nodeA != nodeB) {
            // 如果长度相同, 且没有交集, 则会直接走到底, 不会有死循环问题
            // 如果长度不同, 会拼接两个链表, 且中间会有一次补 null
            // nodeA != nodeB 相当于先判断然后再走, 如果发现 null, 就会填充, 最后一定会一起走到 null
            nodeA = nodeA == null ? headB : nodeA.next;
            System.out.println(nodeA);
            nodeB = nodeB == null ? headA : nodeB.next;
        }
        return nodeA;
        // ListNode nodeA = headA;
        // ListNode nodeB = headB;
        // while (nodeA != nodeB) {
        //     nodeA = nodeA.next;
        //     nodeB = nodeB.next;
        //     if (nodeA == null) {
        //         nodeA = headB;
        //     }
        //     if (nodeB == null) {
        //         nodeB = headA;
        //     }
        // }
        // return nodeA;
    }

    public static void main(String[] args) {
        ListNode headA1 = new ListNode(1);
        ListNode headA2 = new ListNode(2);
        ListNode headA3 = new ListNode(3);

        ListNode headB1 = new ListNode(1);
        ListNode headB2 = new ListNode(2);
        ListNode headB3 = new ListNode(3);

        headA1.next = headA2;
        headA2.next = headA3;

        headB1.next = headB2;
        // headB2.next = headB3;

        ListNode intersectionNode = getIntersectionNode(headA1, headB1);
        System.out.println(intersectionNode);

    }

}
```

