---
layout: post
title: "Maven 学习"
categories: [Build]
description:
keywords:
---

* content
{:toc}
## Maven

分模块开发, 降低代码冲突

各个模块随意搭配

不用找 jar 包

后期项目升级

## POM

### Maven POM

POM( Project Object Model, 项目对象模型 ) 是 Maven 工程的基本工作单元, 是一个XML文件, 包含了项目的基本信息, 用于描述项目如何构建, 声明项目依赖, 等等. 

执行任务或目标时, Maven 会在当前目录中查找 POM. 它读取 POM, 获取所需的配置信息, 然后执行目标. 

POM 中可以指定以下配置：

- 项目依赖
- 插件
- 执行目标
- 项目构建 profile
- 项目版本
- 项目开发者列表
- 相关邮件列表信息

在创建 POM 之前, 我们首先需要描述项目组 (groupId), 项目的唯一id.

```xml
<project xmlns = "http://maven.apache.org/POM/4.0.0"
    xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation = "http://maven.apache.org/POM/4.0.0
    http://maven.apache.org/xsd/maven-4.0.0.xsd">
 
    <!-- 模型版本 -->
    <modelVersion>4.0.0</modelVersion>
    <!-- 公司或者组织的唯一标志, 并且配置时生成的路径也是由此生成, 如com.companyname. project-group, maven会将该项目打成的jar包放本地路径：/com/miaoqi/maven/ -->
    <groupId>com.miaoqi.maven</groupId>
 
    <!-- 项目的唯一 ID, 一个 groupId 下面可能多个项目, 就是靠 artifactId 来区分的 -->
    <artifactId>project</artifactId>
 
    <!-- 版本号 -->
    <version>1.0</version>
</project>
```

所有 POM 文件都需要 project 元素和三个必需字段：groupId, artifactId, version. 

| 节点         | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| project      | 工程的根标签.                                                |
| modelVersion | 模型版本需要设置为 4. 0.                                     |
| groupId      | 这是工程组的标识. 它在一个组织或者项目中通常是唯一的. 例如, 一个银行组织 com.companyname. project-group 拥有所有的和银行相关的项目. |
| artifactId   | 这是工程的标识. 它通常是工程的名称. 例如, 消费者银行. groupId 和 artifactId 一起定义了 artifact 在仓库中的位置. |
| version      | 这是工程的版本号. 在 artifact 的仓库中, 它用来区分不同的版本. 例如：<br/>`com.company. bank:consumer-banking:1.0`<br/>`com.company. bank:consumer-banking:1.1` |

### 父(Super)POM

父(Super)POM是 Maven 默认的 POM. 所有的 POM 都继承自一个父 POM(无论是否显式定义了这个父 POM). 父 POM 包含了一些可以被继承的默认设置. 因此, 当 Maven 发现需要下载 POM 中的 依赖时, 它会到 Super POM 中配置的默认仓库 http://repo1. maven. org/maven2 去下载. 

Maven 使用 effective pom(Super pom 加上工程自己的配置)来执行相关的目标, 它帮助开发者在 pom.xml 中做尽可能少的配置, 当然这些配置可以被重写. 

使用以下命令来查看 Super POM 默认配置：

```bash
mvn help:effective-pom
```

Maven 将会开始处理并显示 effective-pom(实际的 pom), Effective POM 的结果就像在控制台中显示的一样, 经过继承,插值之后, 使配置生效. 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- ====================================================================== -->
<!--                                                                        -->
<!-- Generated by Maven Help Plugin on 2020-01-13T12:35:23+08:00            -->
<!-- See: http://maven.apache.org/plugins/maven-help-plugin/                -->
<!--                                                                        -->
<!-- ====================================================================== -->
<!-- ====================================================================== -->
<!--                                                                        -->
<!-- Effective POM for project                                              -->
<!-- 'com.miaoqi.maven:maven-helloworld:war:0.0.1-SNAPSHOT'                 -->
<!--                                                                        -->
<!-- ====================================================================== -->
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.miaoqi.maven</groupId>
  <artifactId>maven-helloworld</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>war</packaging>
  <name>maven-helloworld</name>
  <description>maven-helloworld</description>
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.9</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>servlet-api</artifactId>
      <version>2.5</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>jsp-api</artifactId>
      <version>2.0</version>
      <scope>provided</scope>
    </dependency>
  </dependencies>
  <repositories>
    <repository>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <id>central</id>
      <name>Central Repository</name>
      <url>https://repo.maven.apache.org/maven2</url>
    </repository>
  </repositories>
  <pluginRepositories>
    <pluginRepository>
      <releases>
        <updatePolicy>never</updatePolicy>
      </releases>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <id>central</id>
      <name>Central Repository</name>
      <url>https://repo.maven.apache.org/maven2</url>
    </pluginRepository>
  </pluginRepositories>
  <build>
    <sourceDirectory>/Users/miaoqi/Documents/study/language/java/build/maven-helloworld/src/main/java</sourceDirectory>
    <scriptSourceDirectory>/Users/miaoqi/Documents/study/language/java/build/maven-helloworld/src/main/scripts</scriptSourceDirectory>
    <testSourceDirectory>/Users/miaoqi/Documents/study/language/java/build/maven-helloworld/src/test/java</testSourceDirectory>
    <outputDirectory>/Users/miaoqi/Documents/study/language/java/build/maven-helloworld/target/classes</outputDirectory>
    <testOutputDirectory>/Users/miaoqi/Documents/study/language/java/build/maven-helloworld/target/test-classes</testOutputDirectory>
    <resources>
      <resource>
        <directory>/Users/miaoqi/Documents/study/language/java/build/maven-helloworld/src/main/resources</directory>
      </resource>
    </resources>
    <testResources>
      <testResource>
        <directory>/Users/miaoqi/Documents/study/language/java/build/maven-helloworld/src/test/resources</directory>
      </testResource>
    </testResources>
    <directory>/Users/miaoqi/Documents/study/language/java/build/maven-helloworld/target</directory>
    <finalName>maven-helloworld-0.0.1-SNAPSHOT</finalName>
    <pluginManagement>
      <plugins>
        <plugin>
          <artifactId>maven-antrun-plugin</artifactId>
          <version>1.3</version>
        </plugin>
        <plugin>
          <artifactId>maven-assembly-plugin</artifactId>
          <version>2.2-beta-5</version>
        </plugin>
        <plugin>
          <artifactId>maven-dependency-plugin</artifactId>
          <version>2.8</version>
        </plugin>
        <plugin>
          <artifactId>maven-release-plugin</artifactId>
          <version>2.3.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
    <plugins>
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.1</version>
        <executions>
          <execution>
            <id>default-compile</id>
            <phase>compile</phase>
            <goals>
              <goal>compile</goal>
            </goals>
            <configuration>
              <source>1.7</source>
              <target>1.7</target>
              <encoding>UTF-8</encoding>
            </configuration>
          </execution>
          <execution>
            <id>default-testCompile</id>
            <phase>test-compile</phase>
            <goals>
              <goal>testCompile</goal>
            </goals>
            <configuration>
              <source>1.7</source>
              <target>1.7</target>
              <encoding>UTF-8</encoding>
            </configuration>
          </execution>
        </executions>
        <configuration>
          <source>1.7</source>
          <target>1.7</target>
          <encoding>UTF-8</encoding>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.tomcat.maven</groupId>
        <artifactId>tomcat7-maven-plugin</artifactId>
        <version>2.2</version>
        <configuration>
          <port>8088</port>
          <path>/</path>
          <uriEncoding>utf-8</uriEncoding>
        </configuration>
      </plugin>
      <plugin>
        <artifactId>maven-clean-plugin</artifactId>
        <version>2.5</version>
        <executions>
          <execution>
            <id>default-clean</id>
            <phase>clean</phase>
            <goals>
              <goal>clean</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-resources-plugin</artifactId>
        <version>2.6</version>
        <executions>
          <execution>
            <id>default-testResources</id>
            <phase>process-test-resources</phase>
            <goals>
              <goal>testResources</goal>
            </goals>
          </execution>
          <execution>
            <id>default-resources</id>
            <phase>process-resources</phase>
            <goals>
              <goal>resources</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-war-plugin</artifactId>
        <version>2.2</version>
        <executions>
          <execution>
            <id>default-war</id>
            <phase>package</phase>
            <goals>
              <goal>war</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-surefire-plugin</artifactId>
        <version>2.12.4</version>
        <executions>
          <execution>
            <id>default-test</id>
            <phase>test</phase>
            <goals>
              <goal>test</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-install-plugin</artifactId>
        <version>2.4</version>
        <executions>
          <execution>
            <id>default-install</id>
            <phase>install</phase>
            <goals>
              <goal>install</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-deploy-plugin</artifactId>
        <version>2.7</version>
        <executions>
          <execution>
            <id>default-deploy</id>
            <phase>deploy</phase>
            <goals>
              <goal>deploy</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-site-plugin</artifactId>
        <version>3.3</version>
        <executions>
          <execution>
            <id>default-site</id>
            <phase>site</phase>
            <goals>
              <goal>site</goal>
            </goals>
            <configuration>
              <outputDirectory>/Users/miaoqi/Documents/study/language/java/build/maven-helloworld/target/site</outputDirectory>
              <reportPlugins>
                <reportPlugin>
                  <groupId>org.apache.maven.plugins</groupId>
                  <artifactId>maven-project-info-reports-plugin</artifactId>
                </reportPlugin>
              </reportPlugins>
            </configuration>
          </execution>
          <execution>
            <id>default-deploy</id>
            <phase>site-deploy</phase>
            <goals>
              <goal>deploy</goal>
            </goals>
            <configuration>
              <outputDirectory>/Users/miaoqi/Documents/study/language/java/build/maven-helloworld/target/site</outputDirectory>
              <reportPlugins>
                <reportPlugin>
                  <groupId>org.apache.maven.plugins</groupId>
                  <artifactId>maven-project-info-reports-plugin</artifactId>
                </reportPlugin>
              </reportPlugins>
            </configuration>
          </execution>
        </executions>
        <configuration>
          <outputDirectory>/Users/miaoqi/Documents/study/language/java/build/maven-helloworld/target/site</outputDirectory>
          <reportPlugins>
            <reportPlugin>
              <groupId>org.apache.maven.plugins</groupId>
              <artifactId>maven-project-info-reports-plugin</artifactId>
            </reportPlugin>
          </reportPlugins>
        </configuration>
      </plugin>
    </plugins>
  </build>
  <reporting>
    <outputDirectory>/Users/miaoqi/Documents/study/language/java/build/maven-helloworld/target/site</outputDirectory>
  </reporting>
</project>
```

在上面的 pom.xml 中, 你可以看到 Maven 在执行目标时需要用到的默认工程源码目录结构,输出目录,需要的插件,仓库和报表目录. 

Maven 的 pom.xml 文件也不需要手工编写. 

Maven 提供了大量的原型插件来创建工程, 包括工程结构和 pom.xml. 

### POM 标签大全详解

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd">
    <!--父项目的坐标. 如果项目中没有规定某个元素的值, 那么父项目中的对应值即为项目的默认值. 坐标包括group ID, artifact ID和 version -->
    <parent>
        <!--被继承的父项目的构件标识符 -->
        <artifactId/>
        <!--被继承的父项目的全球唯一标识符 -->
        <groupId/>
        <!--被继承的父项目的版本 -->
        <version/>
        <!-- 父项目的pom.xml文件的相对路径. 相对路径允许你选择一个不同的路径. 默认值是../pom.xml. Maven 首先在构建当前项目的地方寻找父项目的pom, 其次在文件系统的这个位置(relativePath位置), 然后在本地仓库, 最后在远程仓库寻找父项目的pom. -->
        <relativePath/>
    </parent>
    <!--声明项目描述符遵循哪一个POM模型版本. 模型本身的版本很少改变, 虽然如此, 但它仍然是必不可少的, 这是为了当Maven引入了新的特性或者其他模型变更的时候, 确保稳定性. -->
    <modelVersion>4.0.0</modelVersion>
    <!--项目的全球唯一标识符, 通常使用全限定的包名区分该项目和其他项目. 并且构建时生成的路径也是由此生成, 如com. mycompany. app生成的相对路径为：/com/mycompany/app -->
    <groupId>asia. banseon</groupId>
    <!-- 构件的标识符, 它和group ID一起唯一标识一个构件. 换句话说, 你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个特定的group ID下, artifact ID也必须是唯一的. 构件是项目产生的或使用的一个东西, Maven为项目产生的构件包括：JARs, 源 码, 二进制发布和WARs等. -->
    <artifactId>banseon-maven2</artifactId>
    <!--项目产生的构件类型, 例如jar,war,ear,pom. 插件可以创建他们自己的构件类型, 所以前面列的不是全部构件类型 -->
    <packaging>jar</packaging>
    <!--项目当前版本, 格式为:主版本. 次版本. 增量版本-限定版本号 -->
    <version>1.0-SNAPSHOT</version>
    <!--项目的名称, Maven产生的文档用 -->
    <name>banseon-maven</name>
    <!--项目主页的URL, Maven产生的文档用 -->
    <url>http://www.baidu.com/banseon</url>
    <!-- 项目的详细描述, Maven 产生的文档用. 当这个元素能够用HTML格式描述时(例如, CDATA中的文本会被解析器忽略, 就可以包含HTML标签), 不鼓励使用纯文本描述. 如果你需要修改产生的web站点的索引页面, 你应该修改你自己的索引页文件, 而不是调整这里的文档. -->
    <description>A maven project to study maven. </description>
    <!--描述了这个项目构建环境中的前提条件. -->
    <prerequisites>
        <!--构建该项目或使用该插件所需要的Maven的最低版本 -->
        <maven/>
    </prerequisites>
    <!--项目的问题管理系统(Bugzilla, Jira, Scarab, 或任何你喜欢的问题管理系统)的名称和URL, 本例为 jira -->
    <issueManagement>
        <!--问题管理系统(例如jira)的名字, -->
        <system>jira</system>
        <!--该项目使用的问题管理系统的URL -->
        <url>http://jira.baidu.com/banseon</url>
    </issueManagement>
    <!--项目持续集成信息 -->
    <ciManagement>
        <!--持续集成系统的名字, 例如continuum -->
        <system/>
        <!--该项目使用的持续集成系统的URL(如果持续集成系统有web接口的话). -->
        <url/>
        <!--构建完成时, 需要通知的开发者/用户的配置项. 包括被通知者信息和通知条件(错误, 失败, 成功, 警告) -->
        <notifiers>
            <!--配置一种方式, 当构建中断时, 以该方式通知用户/开发者 -->
            <notifier>
                <!--传送通知的途径 -->
                <type/>
                <!--发生错误时是否通知 -->
                <sendOnError/>
                <!--构建失败时是否通知 -->
                <sendOnFailure/>
                <!--构建成功时是否通知 -->
                <sendOnSuccess/>
                <!--发生警告时是否通知 -->
                <sendOnWarning/>
                <!--不赞成使用. 通知发送到哪里 -->
                <address/>
                <!--扩展配置项 -->
                <configuration/>
            </notifier>
        </notifiers>
    </ciManagement>
    <!--项目创建年份, 4位数字. 当产生版权信息时需要使用这个值. -->
    <inceptionYear/>
    <!--项目相关邮件列表信息 -->
    <mailingLists>
        <!--该元素描述了项目相关的所有邮件列表. 自动产生的网站引用这些信息. -->
        <mailingList>
            <!--邮件的名称 -->
            <name>Demo</name>
            <!--发送邮件的地址或链接, 如果是邮件地址, 创建文档时, mailto: 链接会被自动创建 -->
            <post>banseon@126.com</post>
            <!--订阅邮件的地址或链接, 如果是邮件地址, 创建文档时, mailto: 链接会被自动创建 -->
            <subscribe>banseon@126.com</subscribe>
            <!--取消订阅邮件的地址或链接, 如果是邮件地址, 创建文档时, mailto: 链接会被自动创建 -->
            <unsubscribe>banseon@126.com</unsubscribe>
            <!--你可以浏览邮件信息的URL -->
            <archive>http:/hi.baidu.com/banseon/demo/dev/</archive>
        </mailingList>
    </mailingLists>
    <!--项目开发者列表 -->
    <developers>
        <!--某个项目开发者的信息 -->
        <developer>
            <!--SCM里项目开发者的唯一标识符 -->
            <id>HELLO WORLD</id>
            <!--项目开发者的全名 -->
            <name>banseon</name>
            <!--项目开发者的email -->
            <email>banseon@126.com</email>
            <!--项目开发者的主页的URL -->
            <url/>
            <!--项目开发者在项目中扮演的角色, 角色元素描述了各种角色 -->
            <roles>
                <role>Project Manager</role>
                <role>Architect</role>
            </roles>
            <!--项目开发者所属组织 -->
            <organization>demo</organization>
            <!--项目开发者所属组织的URL -->
            <organizationUrl>http://hi.baidu.com/banseon</organizationUrl>
            <!--项目开发者属性, 如即时消息如何处理等 -->
            <properties>
                <dept>No</dept>
            </properties>
            <!--项目开发者所在时区, -11到12范围内的整数. -->
            <timezone>-5</timezone>
        </developer>
    </developers>
    <!--项目的其他贡献者列表 -->
    <contributors>
        <!--项目的其他贡献者. 参见developers/developer元素 -->
        <contributor>
            <name/>
            <email/>
            <url/>
            <organization/>
            <organizationUrl/>
            <roles/>
            <timezone/>
            <properties/>
        </contributor>
    </contributors>
    <!--该元素描述了项目所有License列表. 应该只列出该项目的license列表, 不要列出依赖项目的 license列表. 如果列出多个license, 用户可以选择它们中的一个而不是接受所有license. -->
    <licenses>
        <!--描述了项目的license, 用于生成项目的web站点的license页面, 其他一些报表和validation也会用到该元素. -->
        <license>
            <!--license用于法律上的名称 -->
            <name>Apache 2</name>
            <!--官方的license正文页面的URL -->
            <url>http://www.baidu.com/banseon/LICENSE-2.0. txt</url>
            <!--项目分发的主要方式： repo, 可以从Maven库下载 manual, 用户必须手动下载和安装依赖 -->
            <distribution>repo</distribution>
            <!--关于license的补充信息 -->
            <comments>A business-friendly OSS license</comments>
        </license>
    </licenses>
    <!--SCM(Source Control Management)标签允许你配置你的代码库, 供Maven web站点和其它插件使用. -->
    <scm>
        <!--SCM的URL, 该URL描述了版本库和如何连接到版本库. 欲知详情, 请看SCMs提供的URL格式和列表. 该连接只读. -->
        <connection>
            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)
        </connection>
        <!--给开发者使用的, 类似connection元素. 即该连接不仅仅只读 -->
        <developerConnection>
            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk
        </developerConnection>
        <!--当前代码的标签, 在开发阶段默认为HEAD -->
        <tag/>
        <!--指向项目的可浏览SCM库(例如ViewVC或者Fisheye)的URL. -->
        <url>http://svn.baidu.com/banseon</url>
    </scm>
    <!--描述项目所属组织的各种属性. Maven产生的文档用 -->
    <organization>
        <!--组织的全名 -->
        <name>demo</name>
        <!--组织主页的URL -->
        <url>http://www.baidu.com/banseon</url>
    </organization>
    <!--构建项目需要的信息 -->
    <build>
        <!--该元素设置了项目源码目录, 当构建项目的时候, 构建系统会编译目录里的源码. 该路径是相对于pom.xml的相对路径. -->
        <sourceDirectory/>
        <!--该元素设置了项目脚本源码目录, 该目录和源码目录不同：绝大多数情况下, 该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的, 而不是被编译的). -->
        <scriptSourceDirectory/>
        <!--该元素设置了项目单元测试使用的源码目录, 当测试项目的时候, 构建系统会编译目录里的源码. 该路径是相对于pom.xml的相对路径. -->
        <testSourceDirectory/>
        <!--被编译过的应用程序class文件存放的目录. -->
        <outputDirectory/>
        <!--被编译过的测试class文件存放的目录. -->
        <testOutputDirectory/>
        <!--使用来自该项目的一系列构建扩展 -->
        <extensions>
            <!--描述使用到的构建扩展. -->
            <extension>
                <!--构建扩展的groupId -->
                <groupId/>
                <!--构建扩展的artifactId -->
                <artifactId/>
                <!--构建扩展的版本 -->
                <version/>
            </extension>
        </extensions>
        <!--当项目没有规定目标(Maven2 叫做阶段)时的默认值 -->
        <defaultGoal/>
        <!--这个元素描述了项目相关的所有资源路径列表, 例如和项目相关的属性文件, 这些资源被包含在最终的打包文件里. -->
        <resources>
            <!--这个元素描述了项目相关或测试相关的所有资源路径 -->
            <resource>
                <!-- 描述了资源的目标路径. 该路径相对target/classes目录(例如${project.build.outputDirectory}). 举个例子, 如果你想资源在特定的包里(org.apache.maven.messages), 你就必须该元素设置为org/apache/maven /messages. 然而, 如果你只是想把资源放到源码目录结构里, 就不需要该配置. -->
                <targetPath/>
                <!--是否使用参数值代替参数名. 参数值取自properties元素或者文件里配置的属性, 文件在filters元素里列出. -->
                <filtering/>
                <!--描述存放资源的目录, 该路径相对POM路径 -->
                <directory/>
                <!--包含的模式列表, 例如**/*.xml -->
                <includes/>
                <!--排除的模式列表, 例如**/*.xml -->
                <excludes/>
            </resource>
        </resources>
        <!--这个元素描述了单元测试相关的所有资源路径, 例如和单元测试相关的属性文件. -->
        <testResources>
            <!--这个元素描述了测试相关的所有资源路径, 参见build/resources/resource元素的说明 -->
            <testResource>
                <targetPath/>
                <filtering/>
                <directory/>
                <includes/>
                <excludes/>
            </testResource>
        </testResources>
        <!--构建产生的所有文件存放的目录 -->
        <directory/>
        <!--产生的构件的文件名, 默认值是${artifactId}-${version}. -->
        <finalName/>
        <!--当filtering开关打开时, 使用到的过滤器属性文件列表 -->
        <filters/>
        <!--子项目可以引用的默认插件信息. 该插件配置项直到被引用时才会被解析或绑定到生命周期. 给定插件的任何本地配置都会覆盖这里的配置 -->
        <pluginManagement>
            <!--使用的插件列表 -->
            <plugins>
                <!--plugin元素包含描述插件所需要的信息. -->
                <plugin>
                    <!--插件在仓库里的group ID -->
                    <groupId/>
                    <!--插件在仓库里的artifact ID -->
                    <artifactId/>
                    <!--被使用的插件的版本(或版本范围) -->
                    <version/>
                    <!--是否从该插件下载Maven扩展(例如打包和类型处理器), 由于性能原因, 只有在真需要下载时, 该元素才被设置成enabled. -->
                    <extensions/>
                    <!--在构建生命周期中执行一组目标的配置. 每个目标可能有不同的配置. -->
                    <executions>
                        <!--execution元素包含了插件执行需要的信息 -->
                        <execution>
                            <!--执行目标的标识符, 用于标识构建过程中的目标, 或者匹配继承过程中需要合并的执行目标 -->
                            <id/>
                            <!--绑定了目标的构建生命周期阶段, 如果省略, 目标会被绑定到源数据里配置的默认阶段 -->
                            <phase/>
                            <!--配置的执行目标 -->
                            <goals/>
                            <!--配置是否被传播到子POM -->
                            <inherited/>
                            <!--作为DOM对象的配置 -->
                            <configuration/>
                        </execution>
                    </executions>
                    <!--项目引入插件所需要的额外依赖 -->
                    <dependencies>
                        <!--参见dependencies/dependency元素 -->
                        <dependency>
                            ......
                        </dependency>
                    </dependencies>
                    <!--任何配置是否被传播到子项目 -->
                    <inherited/>
                    <!--作为DOM对象的配置 -->
                    <configuration/>
                </plugin>
            </plugins>
        </pluginManagement>
        <!--使用的插件列表 -->
        <plugins>
            <!--参见build/pluginManagement/plugins/plugin元素 -->
            <plugin>
                <groupId/>
                <artifactId/>
                <version/>
                <extensions/>
                <executions>
                    <execution>
                        <id/>
                        <phase/>
                        <goals/>
                        <inherited/>
                        <configuration/>
                    </execution>
                </executions>
                <dependencies>
                    <!--参见dependencies/dependency元素 -->
                    <dependency>
                        ......
                    </dependency>
                </dependencies>
                <goals/>
                <inherited/>
                <configuration/>
            </plugin>
        </plugins>
    </build>
    <!--在列的项目构建profile, 如果被激活, 会修改构建处理 -->
    <profiles>
        <!--根据环境参数或命令行参数激活某个构建处理 -->
        <profile>
            <!--构建配置的唯一标识符. 即用于命令行激活, 也用于在继承时合并具有相同标识符的profile. -->
            <id/>
            <!--自动触发profile的条件逻辑. Activation是profile的开启钥匙. profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定. activation元素并不是激活profile的唯一方式. -->
            <activation>
                <!--profile默认是否激活的标志 -->
                <activeByDefault>true</activeByDefault>
                <!--当匹配的jdk被检测到, profile被激活. 例如, 1.4激活JDK1.4, 1.4.0_2, 而!1.4激活所有版本不是以1.4开头的JDK. -->
                <jdk>1.4</jdk>
                <!--当匹配的操作系统属性被检测到, profile被激活. os元素可以定义一些操作系统相关的属性. -->
                <os>
                    <!--激活profile的操作系统的名字 -->
                    <name>Windows XP</name>
                    <!--激活profile的操作系统所属家族(如 'windows') -->
                    <family>Windows</family>
                    <!--激活profile的操作系统体系结构 -->
                    <arch>x86</arch>
                    <!--激活profile的操作系统版本 -->
                    <version>5.1.2600</version>
                </os>
                <!--如果Maven检测到某一个属性(其值可以在POM中通过${名称}引用), 其拥有对应的名称和值, Profile就会被激活. 如果值 字段是空的, 那么存在属性名称字段就会激活profile, 否则按区分大小写方式匹配属性值字段 -->
                <property>
                    <!--激活profile的属性的名称 -->
                    <name>mavenVersion</name>
                    <!--激活profile的属性的值 -->
                    <value>2.0. 3</value>
                </property>
                <!--提供一个文件名, 通过检测该文件的存在或不存在来激活profile. missing检查文件是否存在, 如果不存在则激活 profile. 另一方面, exists则会检查文件是否存在, 如果存在则激活profile. -->
                <file>
                    <!--如果指定的文件存在, 则激活profile. -->
                    <exists>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/
                    </exists>
                    <!--如果指定的文件不存在, 则激活profile. -->
                    <missing>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/
                    </missing>
                </file>
            </activation>
            <!--构建项目所需要的信息. 参见build元素 -->
            <build>
                <defaultGoal/>
                <resources>
                    <resource>
                        <targetPath/>
                        <filtering/>
                        <directory/>
                        <includes/>
                        <excludes/>
                    </resource>
                </resources>
                <testResources>
                    <testResource>
                        <targetPath/>
                        <filtering/>
                        <directory/>
                        <includes/>
                        <excludes/>
                    </testResource>
                </testResources>
                <directory/>
                <finalName/>
                <filters/>
                <pluginManagement>
                    <plugins>
                        <!--参见build/pluginManagement/plugins/plugin元素 -->
                        <plugin>
                            <groupId/>
                            <artifactId/>
                            <version/>
                            <extensions/>
                            <executions>
                                <execution>
                                    <id/>
                                    <phase/>
                                    <goals/>
                                    <inherited/>
                                    <configuration/>
                                </execution>
                            </executions>
                            <dependencies>
                                <!--参见dependencies/dependency元素 -->
                                <dependency>
                                    ...... 
                                </dependency>
                            </dependencies>
                            <goals/>
                            <inherited/>
                            <configuration/>
                        </plugin>
                    </plugins>
                </pluginManagement>
                <plugins>
                    <!--参见build/pluginManagement/plugins/plugin元素 -->
                    <plugin>
                        <groupId/>
                        <artifactId/>
                        <version/>
                        <extensions/>
                        <executions>
                            <execution>
                                <id/>
                                <phase/>
                                <goals/>
                                <inherited/>
                                <configuration/>
                            </execution>
                        </executions>
                        <dependencies>
                            <!--参见dependencies/dependency元素 -->
                            <dependency>
                                ...... 
                            </dependency>
                        </dependencies>
                        <goals/>
                        <inherited/>
                        <configuration/>
                    </plugin>
                </plugins>
            </build>
            <!--模块(有时称作子项目) 被构建成项目的一部分. 列出的每个模块元素是指向该模块的目录的相对路径 -->
            <modules/>
            <!--发现依赖和扩展的远程仓库列表. -->
            <repositories>
                <!--参见repositories/repository元素 -->
                <repository>
                    <releases>
                        <enabled/>
                        <updatePolicy/>
                        <checksumPolicy/>
                    </releases>
                    <snapshots>
                        <enabled/>
                        <updatePolicy/>
                        <checksumPolicy/>
                    </snapshots>
                    <id/>
                    <name/>
                    <url/>
                    <layout/>
                </repository>
            </repositories>
            <!--发现插件的远程仓库列表, 这些插件用于构建和报表 -->
            <pluginRepositories>
                <!--包含需要连接到远程插件仓库的信息. 参见repositories/repository元素 -->
                <pluginRepository>
                    <releases>
                        <enabled/>
                        <updatePolicy/>
                        <checksumPolicy/>
                    </releases>
                    <snapshots>
                        <enabled/>
                        <updatePolicy/>
                        <checksumPolicy/>
                    </snapshots>
                    <id/>
                    <name/>
                    <url/>
                    <layout/>
                </pluginRepository>
            </pluginRepositories>
            <!--该元素描述了项目相关的所有依赖. 这些依赖组成了项目构建过程中的一个个环节. 它们自动从项目定义的仓库中下载. 要获取更多信息, 请看项目依赖机制 -->
            <dependencies>
                <!--参见dependencies/dependency元素 -->
                <dependency>
                    ...... 
                </dependency>
            </dependencies>
            <!--不赞成使用. 现在Maven忽略该元素. -->
            <reports/>
            <!--该元素包括使用报表插件产生报表的规范. 当用户执行"mvn site", 这些报表就会运行. 在页面导航栏能看到所有报表的链接. 参见reporting元素 -->
            <reporting>
                ...... 
            </reporting>
            <!--参见dependencyManagement元素 -->
            <dependencyManagement>
                <dependencies>
                    <!--参见dependencies/dependency元素 -->
                    <dependency>
                        ...... 
                    </dependency>
                </dependencies>
            </dependencyManagement>
            <!--参见distributionManagement元素 -->
            <distributionManagement>
                ...... 
            </distributionManagement>
            <!--参见properties元素 -->
            <properties/>
        </profile>
    </profiles>
    <!--模块(有时称作子项目) 被构建成项目的一部分. 列出的每个模块元素是指向该模块的目录的相对路径 -->
    <modules/>
    <!--发现依赖和扩展的远程仓库列表 -->
    <repositories>
        <!--包含需要连接到远程仓库的信息 -->
        <repository>
            <!--如何处理远程仓库里发布版本的下载 -->
            <releases>
                <!--true或者false表示该仓库是否为下载某种类型构件(发布版, 快照版)开启. -->
                <enabled/>
                <!--该元素指定更新发生的频率. Maven会比较本地POM和远程POM的时间戳. 这里的选项是：always(一直), daily(默认, 每日), interval：X(这里X是以分钟为单位的时间间隔), 或者never(从不). -->
                <updatePolicy/>
                <!--当Maven验证构件校验文件失败时该怎么做：ignore(忽略), fail(失败), 或者warn(警告). -->
                <checksumPolicy/>
            </releases>
            <!-- 如何处理远程仓库里快照版本的下载. 有了releases和snapshots这两组配置, POM就可以在每个单独的仓库中, 为每种类型的构件采取不同的策略. 例如, 可能有人会决定只为开发目的开启对快照版本下载的支持. 参见repositories/repository/releases元素 -->
            <snapshots>
                <enabled/>
                <updatePolicy/>
                <checksumPolicy/>
            </snapshots>
            <!--远程仓库唯一标识符. 可以用来匹配在settings.xml文件里配置的远程仓库 -->
            <id>banseon-repository-proxy</id>
            <!--远程仓库名称 -->
            <name>banseon-repository-proxy</name>
            <!--远程仓库URL, 按protocol://hostname/path形式 -->
            <url>http://192. 168. 1.169:9999/repository/</url>
            <!-- 用于定位和排序构件的仓库布局类型-可以是default(默认)或者legacy(遗留). Maven 2为其仓库提供了一个默认的布局；然而, Maven 1.x有一种不同的布局. 我们可以使用该元素指定布局是default(默认)还是legacy(遗留). -->
            <layout>default</layout>
        </repository>
    </repositories>
    <!--发现插件的远程仓库列表, 这些插件用于构建和报表 -->
    <pluginRepositories>
        <!--包含需要连接到远程插件仓库的信息. 参见repositories/repository元素 -->
        <pluginRepository>
            ...... 
        </pluginRepository>
    </pluginRepositories>
 
 
    <!--该元素描述了项目相关的所有依赖. 这些依赖组成了项目构建过程中的一个个环节. 它们自动从项目定义的仓库中下载. 要获取更多信息, 请看项目依赖机制. -->
    <dependencies>
        <dependency>
            <!--依赖的group ID -->
            <groupId>org.apache.maven</groupId>
            <!--依赖的artifact ID -->
            <artifactId>maven-artifact</artifactId>
            <!--依赖的版本号. 在Maven 2里, 也可以配置成版本号的范围. -->
            <version>3.8.1</version>
            <!-- 依赖类型, 默认类型是jar. 它通常表示依赖的文件的扩展名, 但也有例外. 一个类型可以被映射成另外一个扩展名或分类器. 类型经常和使用的打包方式对应, 尽管这也有例外. 一些类型的例子：jar, war, ejb-client和test-jar. 如果设置extensions为 true, 就可以在 plugin里定义新的类型. 所以前面的类型的例子不完整. -->
            <type>jar</type>
            <!-- 依赖的分类器. 分类器可以区分属于同一个POM, 但不同构建方式的构件. 分类器名被附加到文件名的版本号后面. 例如, 如果你想要构建两个单独的构件成 JAR, 一个使用Java 1.4编译器, 另一个使用Java 6编译器, 你就可以使用分类器来生成两个单独的JAR构件. -->
            <classifier></classifier>
            <!--依赖范围. 在项目发布过程中, 帮助决定哪些构件被包括进来. 欲知详情请参考依赖机制. 
                - compile ：默认范围, 用于编译 
                - provided：类似于编译, 但支持你期待jdk或者容器提供, 类似于classpath 
                - runtime: 在执行时需要使用 
                - test: 用于test任务时使用 
                - system: 需要外在提供相应的元素. 通过systemPath来取得 
                - systemPath: 仅用于范围为system. 提供相应的路径 -->
            <scope>test</scope>
            <!--仅供system范围使用. 注意, 不鼓励使用这个元素, 并且在新的版本中该元素可能被覆盖掉. 该元素为依赖规定了文件系统上的路径. 需要绝对路径而不是相对路径. 推荐使用属性匹配绝对路径, 例如${java. home}. -->
            <systemPath></systemPath>
            <!--当计算传递依赖时, 从依赖构件列表里, 列出被排除的依赖构件集. 即告诉maven你只依赖指定的项目, 不依赖项目的依赖. 此元素主要用于解决版本冲突问题 -->
            <exclusions>
                <exclusion>
                    <artifactId>spring-core</artifactId>
                    <groupId>org.springframework</groupId>
                </exclusion>
            </exclusions>
            <!--可选依赖, 如果你在项目B中把C依赖声明为可选, 你就需要在依赖于B的项目(例如项目A)中显式的引用对C的依赖. 可选依赖阻断依赖的传递性. -->
            <optional>true</optional>
        </dependency>
    </dependencies>
    <!--不赞成使用. 现在Maven忽略该元素. -->
    <reports></reports>
    <!--该元素描述使用报表插件产生报表的规范. 当用户执行"mvn site", 这些报表就会运行. 在页面导航栏能看到所有报表的链接. -->
    <reporting>
        <!--true, 则, 网站不包括默认的报表. 这包括"项目信息"菜单中的报表. -->
        <excludeDefaults/>
        <!--所有产生的报表存放到哪里. 默认值是${project.build.directory}/site. -->
        <outputDirectory/>
        <!--使用的报表插件和他们的配置. -->
        <plugins>
            <!--plugin元素包含描述报表插件需要的信息 -->
            <plugin>
                <!--报表插件在仓库里的group ID -->
                <groupId/>
                <!--报表插件在仓库里的artifact ID -->
                <artifactId/>
                <!--被使用的报表插件的版本(或版本范围) -->
                <version/>
                <!--任何配置是否被传播到子项目 -->
                <inherited/>
                <!--报表插件的配置 -->
                <configuration/>
                <!--一组报表的多重规范, 每个规范可能有不同的配置. 一个规范(报表集)对应一个执行目标 . 例如, 有1, 2, 3, 4, 5, 6, 7, 8, 9个报表. 1, 2, 5构成A报表集, 对应一个执行目标. 2, 5, 8构成B报表集, 对应另一个执行目标 -->
                <reportSets>
                    <!--表示报表的一个集合, 以及产生该集合的配置 -->
                    <reportSet>
                        <!--报表集合的唯一标识符, POM继承时用到 -->
                        <id/>
                        <!--产生报表集合时, 被使用的报表的配置 -->
                        <configuration/>
                        <!--配置是否被继承到子POMs -->
                        <inherited/>
                        <!--这个集合里使用到哪些报表 -->
                        <reports/>
                    </reportSet>
                </reportSets>
            </plugin>
        </plugins>
    </reporting>
    <!-- 继承自该项目的所有子项目的默认依赖信息. 这部分的依赖信息不会被立即解析, 而是当子项目声明一个依赖(必须描述group ID和 artifact ID信息), 如果group ID和artifact ID以外的一些信息没有描述, 则通过group ID和artifact ID 匹配到这里的依赖, 并使用这里的依赖信息. -->
    <dependencyManagement>
        <dependencies>
            <!--参见dependencies/dependency元素 -->
            <dependency>
                ...... 
            </dependency>
        </dependencies>
    </dependencyManagement>
    <!--项目分发信息, 在执行mvn deploy后表示要发布的位置. 有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库. -->
    <distributionManagement>
        <!--部署项目产生的构件到远程仓库需要的信息 -->
        <repository>
            <!--是分配给快照一个唯一的版本号(由时间戳和构建流水号)? 还是每次都使用相同的版本号? 参见repositories/repository元素 -->
            <uniqueVersion/>
            <id>banseon-maven2</id>
            <name>banseon maven2</name>
            <url>file://${basedir}/target/deploy</url>
            <layout/>
        </repository>
        <!--构件的快照部署到哪里? 如果没有配置该元素, 默认部署到repository元素配置的仓库, 参见distributionManagement/repository元素 -->
        <snapshotRepository>
            <uniqueVersion/>
            <id>banseon-maven2</id>
            <name>Banseon-maven2 Snapshot Repository</name>
            <url>scp://svn.baidu.com/banseon:/usr/local/maven-snapshot</url>
            <layout/>
        </snapshotRepository>
        <!--部署项目的网站需要的信息 -->
        <site>
            <!--部署位置的唯一标识符, 用来匹配站点和settings.xml文件里的配置 -->
            <id>banseon-site</id>
            <!--部署位置的名称 -->
            <name>business api website</name>
            <!--部署位置的URL, 按protocol://hostname/path形式 -->
            <url>
                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web
            </url>
        </site>
        <!--项目下载页面的URL. 如果没有该元素, 用户应该参考主页. 使用该元素的原因是：帮助定位那些不在仓库里的构件(由于license限制). -->
        <downloadUrl/>
        <!--如果构件有了新的group ID和artifact ID(构件移到了新的位置), 这里列出构件的重定位信息. -->
        <relocation>
            <!--构件新的group ID -->
            <groupId/>
            <!--构件新的artifact ID -->
            <artifactId/>
            <!--构件新的版本号 -->
            <version/>
            <!--显示给用户的, 关于移动的额外信息, 例如原因. -->
            <message/>
        </relocation>
        <!-- 给出该构件在远程仓库的状态. 不得在本地项目中设置该元素, 因为这是工具自动更新的. 有效的值有：none(默认), converted(仓库管理员从 Maven 1 POM转换过来), partner(直接从伙伴Maven 2仓库同步过来), deployed(从Maven 2实例部 署), verified(被核实时正确的和最终的). -->
        <status/>
    </distributionManagement>
    <!--以值替代名称, Properties可以在整个POM中使用, 也可以作为触发条件(见settings.xml配置文件里activation元素的说明). 格式是<name>value</name>. -->
    <properties/>
</project>
```



## Maven 配置文件

Maven 的 settings.xml 配置文件是对 Maven 自身的一个描述, 用于配置 Maven 的一些属性, 当我们使用 maven 命令时, 会按照以下顺序去查找配置文件 `USER_HOME/.m2/settings.xml` > `M2_HOME/conf/settings.xml`, M2_HOME 是 maven 的安装目录,  settings.xml 里可以配置仓库的地址, 远端服务的账号密码等一系列信息, 这个顺序也是 gradle 使用 mavenLocal() 时寻找的顺序

```xml
<?xml version="1.0" encoding="UTF-8"?>

<settings xmlns="http://maven.apache.org/SETTINGS/1.0. 0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0. 0 http://maven.apache.org/xsd/settings-1.0. 0.xsd">
    <localRepository>/Users/miaoqi/Documents/maven/repository/</localRepository>

    <!--是否输入参数-->
    <!--<interactiveMode>true</interactiveMode>-->

    <!--离线是否可用-->
    <!--<offline>false</offline>-->

    <!--<pluginGroups>-->
    <!--</pluginGroups>-->

    <!--配置代理-->
    <!--<proxies>-->
    <!--<proxy>-->
    <!--<id>optional</id>-->
    <!--<active>true</active>-->
    <!--<protocol>http</protocol>-->
    <!--<username>proxyuser</username>-->
    <!--<password>proxypass</password>-->
    <!--<host>proxy. host. net</host>-->
    <!--<port>80</port>-->
    <!--<nonProxyHosts>local. net|some. host.com</nonProxyHosts>-->
    <!--</proxy>-->
    <!--</proxies>-->

    <!-- 配置打包地址, 要在项目的 pom 文件中配置 -->
    <!--<distributionManagement>-->
        <!--<repository>-->
            <!--<id>releases</id>-->
            <!--<url>http://localhost:8081/nexus/content/repositories/releases/</url>-->
        <!--</repository>-->
        <!--<snapshotRepository>-->
            <!--<id>snapshots</id>-->
            <!--<url>http://localhost:8081/nexus/content/repositories/snapshots/</url>-->
        <!--</snapshotRepository>-->
    <!--</distributionManagement>-->

    <!--服务器认证-->
    <servers>
        <server>
            <id>miaoqi-nexus</id>
            <username>admin</username>
            <password>admin123</password>
            <!--<privateKey>/path/to/private/key</privateKey>-->
            <!--<passphrase>optional; leave empty if not used. </passphrase>-->
        </server>
        <server>
            <id>releases</id>
            <username>admin</username>
            <password>admin123</password>
            <!--[><privateKey>/path/to/private/key</privateKey><]-->
            <!--[><passphrase>optional; leave empty if not used. </passphrase><]-->
        </server>
        <server>
            <id>snapshots</id>
            <username>admin</username>
            <password>admin123</password>
            <!--<privateKey>/path/to/private/key</privateKey>-->
            <!--<passphrase>optional; leave empty if not used. </passphrase>-->
        </server>
    </servers>

    <!--镜像-->
    <!--<mirrors>-->
    <!--<mirror>-->
    <!--<id>mirrorId</id>-->
    <!--<mirrorOf>repositoryId</mirrorOf>-->
    <!--<name>Human Readable Name for this Mirror. </name>-->
    <!--<url>http://my. repository.com/repo/path</url>-->
    <!--</mirror>-->
    <!--</mirrors>-->

    <profiles>
        <profile>
            <id>dev</id>
            <!--配置下载的仓库组-->
            <repositories>
                <repository>
                    <!--仓库id, repositories可以配置多个仓库, 保证id不重复-->
                    <id>miaoqi-nexus</id>
                    <!--仓库地址, 即nexus仓库组的地址-->
                    <url>http://localhost:8081/nexus/content/groups/public/</url>
                    <!--是否下载releases构件-->
                    <releases>
                        <enabled>true</enabled>
                    </releases>
                    <!--是否下载snapshots构件-->
                    <snapshots>
                        <enabled>true</enabled>
                    </snapshots>
                </repository>
            </repositories>
            <pluginRepositories>
                <!--插件仓库, maven的运行依赖插件, 也需要从私服下载插件 -->
                <pluginRepository>
                    <!--插件仓库的id不允许重复, 如果重复后边配置会覆盖前边-->
                    <id>miaoqi-nexus</id>
                    <name>Public Repositories</name>
                    <url>http://localhost:8081/nexus/content/groups/public/</url>
                </pluginRepository>
            </pluginRepositories>
            <activation>
                <activeByDefault>true</activeByDefault>
                <jdk>1.8</jdk>
            </activation>
            <properties>
                <maven.compiler.source>1.8</maven.compiler.source>
                <maven.compiler.target>1.8</maven.compiler.target>
                <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
            </properties>
        </profile>
    </profiles>
    <!--默认激活的配置-->
    <activeProfiles>
        <activeProfile>dev</activeProfile>
    </activeProfiles>
</settings>
```



## Maven 构建生命周期

清理-编译-测试-报告-打包-部署, 整个过程都交给 maven 进行管理, 这个过程称为构建

Maven 构建生命周期定义了一个项目构建跟发布的过程. 

一个典型的 Maven 构建(build)生命周期是由以下几个阶段的序列组成的：

![https://www.miaomiaoqi.github.io/images/build/maven/maven_3.png](https://www.miaomiaoqi.github.io/images/build/maven/maven_3.png)

|     阶段      |   处理   |                           描述                           |
| :-----------: | :------: | :------------------------------------------------------: |
| 验证 validate | 验证项目 |          验证项目是否正确且所有必须信息是可用的          |
| 编译 compile  | 执行编译 |                  源代码编译在此阶段完成                  |
|   测试 Test   |   测试   |        使用适当的单元测试框架(例如JUnit)运行测试.        |
| 包装 package  |   打包   |         创建JAR/WAR包如在 pom.xml 中定义提及的包         |
|  检查 verify  |   检查   |         对集成测试的结果进行检查, 以保证质量达标         |
| 安装 install  |   安装   |        安装打包的项目到本地仓库, 以供其他项目使用        |
|  部署 deploy  |   部署   | 拷贝最终的工程包到远程仓库中, 以共享给其他开发人员和工程 |

为了完成 default 生命周期, 这些阶段(包括其他未在上面罗列的生命周期阶段)将被按顺序地执行. 

Maven 有以下三个标准的生命周期：

- **clean**：项目清理的处理
- **default(或 build)**：项目部署的处理
- **site**：项目站点文档创建的处理

### Clean声明周期

当我们执行 mvn post-clean 命令时, Maven 调用 clean 生命周期, 它包含以下阶段：

- pre-clean：执行一些需要在clean之前完成的工作
- clean：移除所有上一次构建生成的文件
- post-clean：执行一些需要在clean之后立刻完成的工作

mvn clean 中的 clean 就是上面的 clean, 在一个生命周期中, 运行某个阶段的时候, 它之前的所有阶段都会被运行, 也就是说, 如果执行 mvn clean 将运行以下两个生命周期阶段：

```bash
pre-clean, clean
```

如果我们运行 mvn post-clean , 则运行以下三个生命周期阶段

```bash
pre-clean, clean, post-clean
```

我们可以通过在上面的 clean 生命周期的任何阶段定义目标来修改这部分的操作行为. 

在下面的例子中, 我们将 maven-antrun-plugin:run 目标添加到 pre-clean,clean 和 post-clean 阶段中. 这样我们可以在 clean 生命周期的各个阶段显示文本信息. 

```xml
<plugins>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-antrun-plugin</artifactId>
        <version>1.1</version>
        <executions>
            <execution>
                <id>id.pre-clean</id>
                <phase>pre-clean</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <echo>pre-clean phase</echo>
                    </tasks>
                </configuration>
            </execution>
            <execution>
                <id>id.clean</id>
                <phase>clean</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <echo>clean phase</echo>
                    </tasks>
                </configuration>
            </execution>
            <execution>
                <id>id.post-clean</id>
                <phase>post-clean</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <echo>post-clean phase</echo>
                    </tasks>
                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
```

现在打开命令控制台, 跳转到 pom.xml 所在目录, 并执行下面的 mvn 命令

Maven 将会开始处理并显示 clean 生命周期的所有阶段. 

### Default (Build) 生命周期

这是 Maven 的主要生命周期, 被用于构建应用, 包括下面的 23 个阶段：

| 生命周期阶段                              | 描述                                                         |
| :---------------------------------------- | :----------------------------------------------------------- |
| validate(校验)                            | 校验项目是否正确并且所有必要的信息可以完成项目的构建过程.    |
| initialize(初始化)                        | 初始化构建状态, 比如设置属性值.                              |
| generate-sources(生成源代码)              | 生成包含在编译阶段中的任何源代码.                            |
| process-sources(处理源代码)               | 处理源代码, 比如说, 过滤任意值.                              |
| generate-resources(生成资源文件)          | 生成将会包含在项目包中的资源文件.                            |
| process-resources (处理资源文件)          | 复制和处理资源到目标目录, 为打包阶段最好准备.                |
| compile(编译)                             | 编译项目的源代码.                                            |
| process-classes(处理类文件)               | 处理编译生成的文件, 比如说对Java class文件做字节码改善优化.  |
| generate-test-sources(生成测试源代码)     | 生成包含在编译阶段中的任何测试源代码.                        |
| process-test-sources(处理测试源代码)      | 处理测试源代码, 比如说, 过滤任意值.                          |
| generate-test-resources(生成测试资源文件) | 为测试创建资源文件.                                          |
| process-test-resources(处理测试资源文件)  | 复制和处理测试资源到目标目录.                                |
| test-compile(编译测试源码)                | 编译测试源代码到测试目标目录.                                |
| process-test-classes(处理测试类文件)      | 处理测试源码编译生成的文件.                                  |
| test(测试)                                | 使用合适的单元测试框架运行测试(Juint是其中之一).             |
| prepare-package(准备打包)                 | 在实际打包之前, 执行任何的必要的操作为打包做准备.            |
| package(打包)                             | 将编译后的代码打包成可分发格式的文件, 比如JAR,WAR或者EAR文件. |
| pre-integration-test(集成测试前)          | 在执行集成测试前进行必要的动作. 比如说, 搭建需要的环境.      |
| integration-test(集成测试)                | 处理和部署项目到可以运行集成测试环境中.                      |
| post-integration-test(集成测试后)         | 在执行集成测试完成后进行必要的动作. 比如说, 清理集成测试环境. |
| verify (验证)                             | 运行任意的检查来验证项目包有效且达到质量标准.                |
| install(安装)                             | 安装项目包到本地仓库, 这样项目包可以用作其他本地项目的依赖.  |
| deploy(部署)                              | 将最终的项目包复制到远程仓库中与其他开发者和项目共享.        |

有一些与 Maven 生命周期相关的重要概念需要说明：

当一个阶段通过 Maven 命令调用时, 例如 mvn compile, 只有该阶段之前以及包括该阶段在内的所有阶段会被执行. 

不同的 maven 目标将根据打包的类型(JAR / WAR / EAR), 被绑定到不同的 Maven 生命周期阶段. 

在下面的例子中, 我们将 maven-antrun-plugin:run 目标添加到 Build 生命周期的一部分阶段中. 这样我们可以显示生命周期的文本信息. 

```xml
<plugins>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-antrun-plugin</artifactId>
        <version>1.1</version>
        <executions>
            <execution>
                <id>id.validate</id>
                <phase>validate</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <echo>validate phase</echo>
                    </tasks>
                </configuration>
            </execution>
            <execution>
                <id>id.compile</id>
                <phase>compile</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <echo>compile phase</echo>
                    </tasks>
                </configuration>
            </execution>
            <execution>
                <id>id.test</id>
                <phase>test</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <echo>test phase</echo>
                    </tasks>
                </configuration>
            </execution>
            <execution>
                <id>id.package</id>
                <phase>package</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <echo>package phase</echo>
                    </tasks>
                </configuration>
            </execution>
            <execution>
                <id>id.deploy</id>
                <phase>deploy</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <echo>deploy phase</echo>
                    </tasks>
                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
```

现在打开命令控制台, 跳转到 pom.xml 所在目录, 并执行以下 mvn 命令. 

```
mvn compile
```

Maven 将会开始处理并显示直到编译阶段的构建生命周期的各个阶段. 

在开发环境中, 使用下面的命令去构建,安装工程到本地仓库

`mvn install`

这个命令在执行 install 阶段前, 按顺序执行了 default 生命周期的阶段 (validate, compile, package, 等等), 我们只需要调用最后一个阶段, 如这里是 install. 

在构建环境中, 使用下面的调用来纯净地构建和部署项目到共享仓库中

`mvn clean deploy`

这行命令也可以用于多模块的情况下, 即包含多个子项目的项目, Maven 会在每一个子项目执行 clean 命令, 然后再执行 deploy 命令. 

### Site 生命周期

Maven Site 插件一般用来创建新的报告文档,部署站点等. 

- pre-site：执行一些需要在生成站点文档之前完成的工作
- site：生成项目的站点文档
- post-site： 执行一些需要在生成站点文档之后完成的工作, 并且为部署做准备
- site-deploy：将生成的站点文档部署到特定的服务器上

这里经常用到的是 site 阶段和 site-deploy 阶段, 用以生成和发布 Maven 站点, 这可是 Maven 相当强大的功能, Manager 比较喜欢, 文档及统计数据自动生成, 很好看. 在下面的例子中, 我们将 maven-antrun-plugin:run 目标添加到 Site 生命周期的所有阶段中. 这样我们可以显示生命周期的所有文本信息. 

```xml
<plugins>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-antrun-plugin</artifactId>
        <version>1.1</version>
        <executions>
            <execution>
                <id>id.pre-site</id>
                <phase>pre-site</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <echo>pre-site phase</echo>
                    </tasks>
                </configuration>
            </execution>
            <execution>
                <id>id.site</id>
                <phase>site</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <echo>site phase</echo>
                    </tasks>
                </configuration>
            </execution>
            <execution>
                <id>id.post-site</id>
                <phase>post-site</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <echo>post-site phase</echo>
                    </tasks>
                </configuration>
            </execution>
            <execution>
                <id>id.site-deploy</id>
                <phase>site-deploy</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <echo>site-deploy phase</echo>
                    </tasks>
                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
```

现在打开命令控制台, 跳转到 pom.xml 所在目录, 并执行以下 mvn 命令. 

Maven 将会开始处理并显示直到 site 阶段的 site 生命周期的各个阶段. 

### 常用 phase

`mvn clean` 清理 target 目录

`mvn compile` 将 . java 编译成 . class

`mvn test` 执行单元测试类

`mvn package` 打包到target目录下

`mvn install` 安装到本地仓库

`mvn deploy` 部署, 解决多个人使用同一个 jar 包的问题

`mvn clean package -Pqa -U -Dmaven.test.skip=true` 打包命令



## Maven 插件

Maven 有以下三个标准的生命周期：

- **clean**：项目清理的处理
- **default(或 build)**：项目部署的处理
- **site**：项目站点文档创建的处理

每个生命周期中都包含着一系列的阶段(phase). 这些 phase 就相当于 Maven 提供的统一的接口, 然后这些 phase 的实现由 Maven 的插件来完成. 

我们在输入 mvn 命令的时候 比如 **mvn clean**, clean 对应的就是 Clean 生命周期中的 clean 阶段. 但是 clean 的具体操作是由 **maven-clean-plugin** 来实现的. 

所以说 Maven 生命周期的每一个阶段的具体实现都是由 Maven 插件实现的. 

Maven 实际上是一个依赖插件执行的框架, 每个任务实际上是由插件完成. Maven 插件通常被用来：

- 创建 jar 文件
- 创建 war 文件
- 编译代码文件
- 代码单元测试
- 创建工程文档
- 创建工程报告

插件通常提供了一个目标的集合, 并且可以使用下面的语法执行：

`mvn [plugin-name]:[goal-name]`

例如, 一个 Java 工程可以使用 maven-compiler-plugin 的 compile-goal 编译, 使用以下命令：

`mvn compiler:compile`

### 插件类型

Maven 提供了下面两种类型的插件：

| 类型              | 描述                                              |
| :---------------- | :------------------------------------------------ |
| Build plugins     | 在构建时执行, 并在 pom.xml 的 元素中配置.         |
| Reporting plugins | 在网站生成过程中执行, 并在 pom.xml 的 元素中配置. |

下面是一些常用插件的列表：

| 插件     | 描述                                              |
| :------- | :------------------------------------------------ |
| clean    | 构建之后清理目标文件. 删除目标目录                |
| compiler | 编译 Java 源文件                                  |
| surefile | 运行 JUnit 单元测试. 创建测试报告                 |
| jar      | 从当前工程中构建 JAR 文件                         |
| war      | 从当前工程中构建 WAR 文件                         |
| javadoc  | 为工程生成 Javadoc                                |
| antrun   | 从构建过程的任意一个阶段中运行一个 ant 任务的集合 |

我们已经在我们的例子中大量使用了 **maven-antrun-plugin** 来输出数据到控制台上, 让我们用一种更好的方式理解这部分内容

```xml
<plugins>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-antrun-plugin</artifactId>
        <version>1.1</version>
        <executions>
            <execution>
                <id>id.clean</id>
                <phase>clean</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <echo>clean phase</echo>
                    </tasks>
                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
```

接下来, 打开命令终端跳转到 pom.xml 所在的目录, 并执行下面的 mvn 命令

`mvn clean`

Maven 将开始处理并显示 clean 生命周期的 clean 阶段

上面的例子展示了以下关键概念

- 插件是在 pom.xml 中使用 plugins 元素定义的. 
- 每个插件可以有多个目标. 
- 你可以定义阶段, 插件会使用它的 phase 元素开始处理. 我们已经使用了 **clean** 阶段. 
- 你可以通过绑定到插件的目标的方式来配置要执行的任务. 我们已经绑定了 **echo** 任务到 maven-antrun-plugin 的 **run** 目标. 
- 就是这样, Maven 将处理剩下的事情. 它将下载本地仓库中获取不到的插件, 并开始处理. 



## Maven 依赖管理

Maven 一个核心的特性就是依赖管理. 当我们处理多模块的项目(包含成百上千个模块或者子项目), 模块间的依赖关系就变得非常复杂, 管理也变得很困难. 针对此种情形, Maven 提供了一种高度控制的方法. 

### 可传递性依赖发现

一种相当常见的情况, 比如说 A 依赖于其他库 B. 如果, 另外一个项目 C 想要使用 A , 那么 C 项目也需要使用库 B. 

Maven 可以避免去搜索所有所需库的需求. Maven 通过读取项目文件(pom.xml), 找出它们项目之间的依赖关系. 

我们需要做的只是在每个项目的 pom 中定义好直接的依赖关系. 其他的事情 Maven 会帮我们搞定. 

通过可传递性的依赖, 所有被包含的库的图形会快速的增长. 当有重复库时, 可能出现的情形将会持续上升. Maven 提供一些功能来控制可传递的依赖的程度. 

| 功能     | 功能描述                                                     |
| :------- | :----------------------------------------------------------- |
| 依赖调节 | 决定当多个手动创建的版本同时出现时, 哪个依赖版本将会被使用. <br/>如果两个依赖版本在依赖树里的深度是一样的时候, 第一个被声明的依赖将会被使用 |
| 依赖管理 | 直接的指定手动创建的某个版本被使用. <br/>例如当一个工程 C 在自己的依赖管理模块包含工程 B, 即 B 依赖于 A, 那么 A 即可指定在 B 被引用时所使用的版本 |
| 依赖范围 | 包含在构建过程每个阶段的依赖                                 |
| 依赖排除 | 任何可传递的依赖都可以通过 "exclusion" 元素被排除在外<br/>举例说明, A 依赖 B, B 依赖 C, 因此 A 可以标记 C 为 "被排除的" |
| 依赖可选 | 任何可传递的依赖可以被标记为可选的, 通过使用 "optional" 元素<br/>例如：A 依赖 B, B 依赖 C. 因此, B 可以标记 C 为可选的, 这样 A 就可以不再使用 C |

### 依赖范围

传递依赖发现可以通过使用如下的依赖范围来得到限制

| 范围               | 描述                                                         |
| :----------------- | :----------------------------------------------------------- |
| 编译阶段(compile)  | 该范围表明相关依赖是只在项目的类路径下有效. 默认取值.        |
| 供应阶段(provided) | 该范围表明相关依赖是由运行时的 JDK 或者 网络服务器提供的.    |
| 运行阶段(runtime)  | 该范围表明相关依赖在编译阶段不是必须的,但是在执行阶段是必须的. |
| 测试阶段(test)     | 该范围表明相关依赖只在测试编译阶段和执行阶段.                |
| 系统阶段(system)   | 该范围表明你需要提供一个系统路径.                            |
| 导入阶段(import)   | 该范围只在依赖是一个 pom 里定义的依赖时使用. <br/>同时,当前项目的POM 文件的 部分定义的依赖关系可以取代某特定的 POM. |

### 依赖管理

通常情况下,在一个共通的项目下,有一系列的项目. 在这种情况下,我们可以创建一个公共依赖的 pom 文件,该 pom 包含所有的公共的依赖关系,我们称其为其他子项目 pom 的 pom 父. 接下来的一个例子可以帮助你更好的理解这个概念. 

![https://www.miaomiaoqi.github.io/images/build/maven/maven_4.png](https://www.miaomiaoqi.github.io/images/build/maven/maven_4.png)

接下来是上面依赖图的详情说明

- App-UI-WAR 依赖于 App-Core-lib 和 App-Data-lib. 
- Root 是 App-Core-lib 和 App-Data-lib 的父项目. 
- Root 在它的依赖部分定义了 Lib1,lib2 和 Lib3 作为依赖. 

现在当我们构建 App-UI-WAR 项目时, Maven 将通过遍历依赖关系图找到所有的依赖关系,并且构建该应用程序. 

通过上面的例子,我们可以学习到以下关键概念：

- 公共的依赖可以使用 pom 父的概念被统一放在一起. App-Data-lib 和 App-Core-lib 项目的依赖在 Root 项目里列举了出来(参考 Root 的包类型,它是一个 POM)
- 没有必要在 App-UI-W 里声明 Lib1, lib2, Lib3 是它的依赖. Maven 通过使用可传递的依赖机制来实现该细节. 



### 传递依赖冲突

A 依赖 B, B 依赖 C(1.1v), C 称为 A 的传递依赖

A 依赖 D, D 依赖 C(1. 2v)

C 就存在版本冲突的问题

* maven 本身调节原则    
    1. 第一声明者优先原则, 谁先导进来的就用谁的传递依赖
    2. 路径近者优先原则, 将传递依赖变为直接依赖

* 排除依赖
    1. 将不需要的项目排除
* **版本锁定**
    1. 指定本项目使用jar包版本



## Maven 仓库

在 Maven 中, 任何一个依赖, 插件或者项目构建的输出, 都可以称之为构件. 

Maven 在某个统一的位置存储所有项目的共享的构件, 这个统一的位置, 我们就称之为仓库. (仓库就是存放依赖和插件的地方)

任何的构件都有唯一的坐标, Maven 根据这个坐标定义了构件在仓库中的唯一存储路径. 

### 本地仓库

顾名思义, 就是 Maven 在本地存储构件的地方. 

maven 的本地仓库, 在安装maven后并不会创建, 它是在第一次执行maven命令的时候才被创建

maven 本地仓库的默认位置: 无论是 Windows 还是 Linux, 在用户的目录下都有一个 . m2/repository/ 的仓库目录, 这就是 Maven 仓库的默认位置

如何更改 maven 默认的本地仓库的位置: 这里要引入一个新的元素: localRepository, 它是存在于 maven 的 settings.xml 文件中

```xml
<settings xmlns="http://maven.apache.org/SETTINGS/1.0. 0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0. 0 http://maven.apache.org/xsd/settings-1.0.0.xsd">
  <!-- localRepository
   | The path to the local repository maven will use to store artifacts. 
   |
   | Default: ${user.home}/.m2/repository-->
  <localRepository>D:/myworkspace/maven_repository</localRepository>
</settings>
```

这时候, maven 的本地仓库地址就变成了 D:\maven_new_repository

**注: 此时配置的 maven 的本地仓库是属于用户范围的**

### 远程仓库

#### 中央仓库

说到远程仓库先从最核心的中央仓库开始, 中央仓库是默认的远程仓库, maven 在安装的时候, 自带的就是中央仓库的配置

在 maven 的聚合与继承中我们说过, 所有的 maven 项目都会继承超级 pom, 具体的说, 包含了下面配置的 pom 我们就称之为超级pom

```xml
<repositories>  
    <repository>  
      <id>central</id>  
      <name>Central Repository</name>  
      <url>http://repo.maven.apache.org/maven2</url>  
      <layout>default</layout>  
      <snapshots>  
        <enabled>false</enabled>  
      </snapshots>  
    </repository>  
</repositories>
```
超级 pom 文件存放位置

apache-maven-3.3.9\lib\maven-model-builder-3.3.9. jar\org\apache\maven\model\pom-4.0.0.xml

从超级 pom.xml 来看, 能看到 mavne 的 convention 和默认的中央仓库

#### 私服

私服是一种特殊的远程仓库, 它是架设在局域网内的仓库服务, 私服代理广域网上的远程仓库, 供局域网内的 Maven 用户使用. 当**Maven 需要下载构件的时候, 它从私服请求, 如果私服上不存在该构件, 则从外部的远程仓库下载, 缓存在私服上之后, 再为 Maven 的下载请求提供服务. 我们还可以把一些无法从外部仓库下载到的构件上传到私服上. ** 

Maven私服的特性: 

* 节省自己的外网带宽: 减少重复请求造成的外网带宽消耗

* 加速 Maven 构件: 如果项目配置了很多外部远程仓库的时候, 构建速度就会大大降低

* 部署第三方构件: 有些构件无法从外部仓库获得的时候, 我们可以把这些构件部署到内部仓库(私服)中, 供内部 maven 项目使用

* 提高稳定性, 增强控制: Internet 不稳定的时候, maven 构建也会变的不稳定, 一些私服软件还提供了其他的功能

* 降低中央仓库的负荷: maven 中央仓库被请求的数量是巨大的, 配置私服也可以大大降低中央仓库的压力

* 当前主流的 maven 私服: 

    Apache 的 Archiva

    JFrog 的 Artifactory

    **Sonatype 的 Nexus**

    1. 下载

        登录[https://www.sonatype.com/download-oss-sonatype](https://www.sonatype.com/download-oss-sonatype)下载对应系统的 nexus

        我是 mac 使用的是 `brew install nexus` 安装的

    1. 启动

        bin/nexus start

    1. 浏览器输入http://localhost:8081/nexus, 初始账号/密码: admin/admin123
    

**我这里介绍的是 Sonatype 的 Nexus**

![https://www.miaomiaoqi.github.io/images/build/maven/maven_1.png](https://www.miaomiaoqi.github.io/images/build/maven/maven_1.png)

**Apache Snapshots:** http://repository. apache. org/snapshots/

**Central:** https://repo1. maven. org/maven2/

一般用到的仓库种类是 hosted,proxy. Hosted 代表宿主仓库, 用来发布一些第三方不允许的组件, 比如 oracle 驱动,比如商业软件jar包. Proxy 代表代理远程的仓库, 最典型的就是 Maven 官方中央仓库,JBoss 仓库等等. 如果构建的 Maven 项目本地仓库没有依赖包, 那么就会去这个代理站点去下载, 那么如果代理站点也没有此依赖包, 就回去远程中央仓库下载依赖, 这些中央仓库就是 proxy. 代理站点下载成功后再下载至本机. 

-  **hosted: 类型的仓库, 内部项目的发布仓库**
- **releases: 内部的模块中release模块的发布仓库**
- **snapshots: 发布内部的SNAPSHOT模块的仓库**
- **3rd party: 第三方依赖的仓库, 这个数据通常是由内部人员自行下载之后发布上去**
- **proxy: 类型的仓库, 从远程中央仓库中寻找数据的仓库**
- **group: 类型的仓库, 组仓库用来方便我们开发人员进行设置的仓库**



![https://www.miaomiaoqi.github.io/images/build/maven/maven_2.png](https://www.miaomiaoqi.github.io/images/build/maven/maven_2.png)

* Repository ID: 文件系统中的唯一名字
* Repository Name: 页面展示名字
* Repository Type: 仓库类型



**新搭建的 neuxs 环境只是一个空的仓库, 需要手动和远程中心库进行同步, nexus 默认是关闭远程索引下载, 最重要的一件事情就是开启远程索引下载. 登陆 nexus 系统, 默认用户名密码为 admin/admin123. 点击左边 Views/Repositories 菜单下面的 Repositories, 找到右边仓库列表中的三个仓库 Apache Snapshots, Codehaus Snapshots 和 Central, 然后再没有仓库的 Configuration 下把 Download Remote Indexes 修改为 true. 然后在这三个仓库上分别右键, 选择 Repari Index, 这样Nexus 就会去下载远程的索引文件**

**Nexus 中仓库组的概念是 Maven 没有的, 在 Maven 看来, 不管你是 hosted 也好, proxy 也好, 或者 group 也好, 对我都是一样的, 我只管根据 groupId, artifactId, version 等信息向你要构件. 为了方便 Maven 的配置, Nexus 能够将多个仓库, hosted 或者 proxy 合并成一个 group, 这样 Maven 只需要依赖于一个 group, 便能使用所有该 group 包含的仓库的内容**

 **Neuxs 中默认自带了一个名为 “Public Repositories” 组, 点击该组可以对他保护的仓库进行调整, 这样就不需要再在 maven 中明确指定内部仓库的地址了**



#### 误删库恢复

1. 首先登陆到 nexus 所在的机器, 找到 sonatype-work 这个目录, 这个是 nexus 的数据目录, 所以有 jar 包和索引等都存放在这里. 在 mac 使用 brew 安装的路径是 `/usr/local/var/nexus`
2. 切换到 `nexus/trash` 这个目录, 就可以看到你刚才删除的仓库名字了, 比如我刚才删除的是 3rd party, 这里会显示一个thirdparty, 这个是仓库的ID, 创建的时候要用到的. 
3. 把 thirdparty 这个目录移到 `nexus/storage/` 里面, 移之前确认一下 storage 里面是不是还有 thirdparty 这个目录, 如果有, 删除掉之后再移. 
4. 在页面上新建仓库, 仓库 ID 填写 thirdparty, 这个 ID 就是前面你删除的, 在 trash 目录里的那个文件夹名字. 



#### 远程仓库(私服)配置

在平时的开发中, 我们往往不会使用默认的中央仓库, 默认的中央仓库访问的速度比较慢, 访问的人或许很多, 有时候也无法满足我们项目的需求, 可能项目需要的某些构件中央仓库中是没有的, 而在其他远程仓库中有, 如 JBoss Maven 仓库. 这时, 可以在settings.xml 中配置该仓库, 代码如下: 

```xml
<!-- 配置下载 jar 包路径 -->
<repositories>  
    <repository>  
        <id>jboss</id>  
        <name>JBoss Repository</name>  
        <url>http://repository.jboss.com/maven2/</url>  
        <releases>  
            <updatePolicy>daily</updatePolicy><!-- never, always, interval n -->  
            <enabled>true</enabled>  
            <checksumPolicy>warn</checksumPolicy><!-- fail, ignore -->  
        </releases>  
        <snapshots>  
            <enabled>false</enabled>  
        </snapshots>  
        <layout>default</layout>  
    </repository>  
</repositories>
```

**repository**: 在 repositories 元素下, 可以使用 repository 子元素声明一个或者多个远程仓库. 

**id: 仓库声明的唯一 id, 尤其需要注意的是, Maven 自带的中央仓库使用的 id 为 central, 如果其他仓库声明也使用该 id, 就会覆盖中央仓库的配置** 

**name**: 仓库的名称, 让我们直观方便的知道仓库是哪个, 暂时没发现其他太大的含义. 

**url**: 指向了仓库的地址, 一般来说, 该地址都基于 http 协议, Maven 用户都可以在浏览器中打开仓库地址浏览构件. 

**releases** 和 **snapshots**: 用来控制 Maven 对于发布版构件和快照版构件的下载权限. 需要注意的是 enabled 子元素, 该例中releases 的 enabled 值为 true, 表示开启 JBoss 仓库的发布版本下载支持, 而 snapshots 的 enabled 值为 false, 表示关闭 JBoss 仓库的快照版本的下载支持. 根据该配置, Maven 只会从 JBoss 仓库下载发布版的构件, 而不会下载快照版的构件. 

**layout**: 元素值 default 表示仓库的布局是 Maven2 及 Maven3 的默认布局, 而不是 Maven1 的布局. 基本不会用到 Maven1 的布局

其他: 对于 releases 和 snapshots 来说, 除了 enabled, 它们还包含另外两个子元素 updatePolicy 和 checksumPolicy

元素 updatePolicy 用来配置 Maven 从远处仓库检查更新的频率, 默认值是 daily, 表示 Maven 每天检查一次. 其他可用的值包括: never-从不检查更新; always-每次构建都检查更新; interval: X-每隔 X 分钟检查一次更新(X为任意整数). 

元素 checksumPolicy 用来配置 Maven 检查校验和文件的策略. 当构建被部署到 Maven 仓库中时, 会同时部署对应的检验和文件. 在下载构件的时候, Maven 会验证校验和文件, 如果校验和验证失败, 当 checksumPolicy 的值为默认的 warn 时, Maven 会在执行构建时输出警告信息, 其他可用的值包括: fail-Maven 遇到校验和错误就让构建失败; ignore-使 Maven 完全忽略校验和错误. 

大部分公共的远程仓库无须认证就可以直接访问, 但我们在平时的开发中往往会架设自己的 Maven 远程仓库, 出于安全方面的考虑, 我们需要提供认证信息才能访问这样的远程仓库. 配置认证信息和配置远程仓库不同, 远程仓库可以直接在 pom.xml 中配置, **但是认证信息必须配置在 settings.xml 文件中. 这是因为 pom 往往是被提交到代码仓库中供所有成员访问的, 而 settings.xml 一般只存在于本机. 因此, 在 settings.xml 中配置认证信息更为安全**

```xml
<!-- servers 标签就是配置用户名密码的 -->
<servers>  
    <server>  
        <id>same with repository id in pom</id>  
        <username>username</username>  
        <password>pwd</password>  
    </server>  
</servers>
```

上面代码我们配置了一个 id 为 releases 的远程仓库认证信息. Maven 使用 settings.xml 文件中的 servers 元素及其子元素 server配置仓库认证信息. 认证用户名为 admin, 认证密码为 admin123. 这里的关键是 id 元素, **settings.xml 中 server 元素的 id 必须与 pom.xml 中需要认证的 repository 元素的 id 完全一致. 正是这个 id 将认证信息与仓库配置联系在了一起**

#### 部署项目到远程仓库

我们使用自己的远程仓库的目的就是在远程仓库中部署我们自己项目的构件以及一些无法从外部仓库直接获取的构件. 这样才能在开发时, 供其他对团队成员使用. 

Maven 除了能对项目进行编译,测试,打包之外, 还能将项目生成的构件部署到远程仓库中. **首先, 需要编辑项目的 pom.xml 文件. ** 配置 distributionManagement 元素, 代码如下: 

```xml
<!-- 配置 deploy 路径 -->
<distributionManagement>
    <repository>
        <id>releases</id>
        <name>public</name>
        <url>http://127.0.0.1:8081/nexus/content/repositories/releases</url>
    </repository>
    <snapshotRepository>
        <id>snapshots</id>
        <name>Snapshots</name>
        <url>http://127.0.0.1:8081/nexus/content/repositories/snapshots</url>
    </snapshotRepository>
</distributionManagement>
```

distributionManagement 包含 repository 和 snapshotRepository 子元素, 前者表示发布版本(稳定版本)构件的仓库, 后者表示快照版本(开发测试版本)的仓库. **这两个元素都需要配置 id,name和url, id 为远程仓库的唯一标识, name 是为了方便人阅读, 关键的 url 表示该仓库的地址. ** 

往远程仓库部署构件的时候, 往往需要认证, 配置认证的方式同上. 

**配置正确后, 运行命令 `mvn clean deploy`, Maven 就会将项目构建输出的构件部署到配置对应的远程仓库, 如果项目当前的版本是快照版本, 则部署到快照版本的仓库地址, 否则就部署到发布版本的仓库地址**

* 快照版本和发布版本

    在使用maven过程中, 我们在开发阶段经常性的会有很多公共库处于不稳定状态, 随时需要修改并发布, 可能一天就要发布一次, 遇到bug时, 甚至一天要发布N次. 我们知道, maven 的依赖管理是基于版本管理的, 对于发布状态的artifact, 如果版本号相同, 即使我们内部的镜像服务器上的组件比本地新, maven 也不会主动下载的. 如果我们在开发阶段都是基于正式发布版本来做依赖管理, 那么遇到这个问题, 就需要升级组件的版本号, 可这样就明显不符合要求和实际情况了. 但是, 如果是基于快照版本, 那么问题就自热而然的解决了, 而 maven 已经为我们准备好了这一切. 

    maven中的仓库分为两种, snapshot快照仓库和release发布仓库. snapshot快照仓库用于保存开发过程中的不稳定版本, release正式仓库则是用来保存稳定的发行版本. 定义一个组件/模块为快照版本, 只需要在pom文件中在该模块的版本号后加上-SNAPSHOT即可(注意这里必须是大写), 如下: 
    
    ```xml
    <groupId>cc.mzone</groupId>
    <artifactId>m1</artifactId>
    <version>0.1-SNAPSHOT</version>
    <packaging>jar</packaging>
    ```
    

**maven2 会根据模块的版本号(pom文件中的version)中是否带有 -SNAPSHOT 来判断是快照版本还是正式版本. 如果是快照版本, 那么在 mvn deploy 时会自动发布到快照版本库中, 会覆盖老的快照版本, 而在使用快照版本的模块, 在不更改版本号的情况下, 直接编译打包时, maven  会自动从镜像服务器上下载最新的快照版本. 如果是正式发布版本, 那么在 mvn deploy 时会自动发布到正式版本库中, 而使用正式版本的模块, 在不更改版本号的情况下, 编译打包时如果本地已经存在该版本的模块则不会主动去镜像服务器上下载**

所以, 我们在开发阶段, 可以将公用库的版本设置为快照版本, 而被依赖组件则引用快照版本进行开发, 在公用库的快照版本更新后, 我们也不需要修改 pom 文件提示版本号来下载新的版本, 直接 mvn 执行相关编译,打包命令即可重新下载最新的快照库了, 从而也方便了我们进行开发. 

#### 配置远程仓库的镜像

如果仓库X可以提供仓库 Y 存储的所有内容, 那么就可以认为 X 是 Y 的一个镜像. 换句话说, 任何一个可以从仓库 Y 获得的构件, 都能够从它的镜像中获取. 举个例子, http://maven.oschina.net/content/groups/public/ 是中央仓库 http://repo1.maven.org/maven2/  在中国的镜像, 由于地理位置的因素, 该镜像往往能够提供比中央仓库更快的服务. 因此, 可以配置 Maven 使用该镜像来替代中央仓库. 编辑 settings.xml, 代码如下:

```xml
<mirrors>
  <mirror>
    <id>maven.oschina.net</id>
    <name>maven mirror in China</name>
    <url>http://maven.oschina.net/content/groups/public/</url>
    <mirrorOf>central</mirrorOf>
  </mirror>
</mirrors>
```

该例中, mirrorOf 的值为 central(超级 pom 中配置), 表示该配置为中央仓库的镜像, 任何对于中央仓库的请求都会转至该镜像, 用户也可以使用同样的方法配置其他仓库的镜像. id 表示镜像的唯一标识符, name 表示镜像的名称, url 表示镜像的地址. 

关于镜像的一个更为常见的用法是结合私服. 由于私服可以代理任何外部的公共仓库(包括中央仓库), 因此, 对于组织内部的 Maven用户来说, 使用一个私服地址就等于使用了所有需要的外部仓库, 这可以将配置集中到私服, 从而简化 Maven 本身的配置. 在这种情况下, 任何需要的构件都可以从私服获得, 私服就是所有仓库的镜像. 这时, 可以配置这样的一个镜像: 

```xml
<!--配置私服镜像-->
<mirrors> 
    <mirror>  
        <id>nexus</id>  
        <name>internal nexus repository</name>  
        <url>http://183.238.2.182:8081/nexus/content/groups/public/</url>  
        <mirrorOf>*</mirrorOf>  
    </mirror>  
</mirrors>
```

该例中 \<mirrorOf\> 的值为星号, 表示该配置是所有 Maven 仓库的镜像, 任何对于远程仓库的请求都会被转至 http://127.0.0.1:8081/nexus/content/groups/public/ **如果该镜像仓库需要认证, 则配置一个 id 为 nexus 的认证信息即可** 

**需要注意的是, 由于镜像仓库完全屏蔽了被镜像仓库, 当镜像仓库不稳定或者停止服务的时候, Maven仍将无法访问被镜像仓库, 因而将无法下载构件**


以下是我的完整配置

```xml
<?xml version="1.0" encoding="UTF-8"?>

<settings xmlns="http://maven.apache.org/SETTINGS/1.0. 0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0. 0 http://maven.apache.org/xsd/settings-1.0. 0.xsd">
    <localRepository>/Users/miaoqi/Documents/maven/repository/</localRepository>

    <!--是否输入参数-->
    <!--<interactiveMode>true</interactiveMode>-->

    <!--离线是否可用-->
    <!--<offline>false</offline>-->

    <!--<pluginGroups>-->
    <!--</pluginGroups>-->

    <!--配置代理-->
    <!--<proxies>-->
    <!--<proxy>-->
    <!--<id>optional</id>-->
    <!--<active>true</active>-->
    <!--<protocol>http</protocol>-->
    <!--<username>proxyuser</username>-->
    <!--<password>proxypass</password>-->
    <!--<host>proxy. host. net</host>-->
    <!--<port>80</port>-->
    <!--<nonProxyHosts>local. net|some. host.com</nonProxyHosts>-->
    <!--</proxy>-->
    <!--</proxies>-->

    <!-- 配置打包地址, 要在项目的 pom 文件中配置 -->
    <!--<distributionManagement>-->
        <!--<repository>-->
            <!--<id>releases</id>-->
            <!--<url>http://localhost:8081/nexus/content/repositories/releases/</url>-->
        <!--</repository>-->
        <!--<snapshotRepository>-->
            <!--<id>snapshots</id>-->
            <!--<url>http://localhost:8081/nexus/content/repositories/snapshots/</url>-->
        <!--</snapshotRepository>-->
    <!--</distributionManagement>-->

    <!--服务器认证-->
    <servers>
        <server>
            <id>miaoqi-nexus</id>
            <username>admin</username>
            <password>admin123</password>
            <!--<privateKey>/path/to/private/key</privateKey>-->
            <!--<passphrase>optional; leave empty if not used. </passphrase>-->
        </server>
        <server>
            <id>releases</id>
            <username>admin</username>
            <password>admin123</password>
            <!--[><privateKey>/path/to/private/key</privateKey><]-->
            <!--[><passphrase>optional; leave empty if not used. </passphrase><]-->
        </server>
        <server>
            <id>snapshots</id>
            <username>admin</username>
            <password>admin123</password>
            <!--<privateKey>/path/to/private/key</privateKey>-->
            <!--<passphrase>optional; leave empty if not used. </passphrase>-->
        </server>
    </servers>

    <!--镜像-->
    <!--<mirrors>-->
    <!--<mirror>-->
    <!--<id>mirrorId</id>-->
    <!--<mirrorOf>repositoryId</mirrorOf>-->
    <!--<name>Human Readable Name for this Mirror. </name>-->
    <!--<url>http://my. repository.com/repo/path</url>-->
    <!--</mirror>-->
    <!--</mirrors>-->

    <profiles>
        <profile>
            <id>dev</id>
            <!--配置下载的仓库组-->
            <repositories>
                <repository>
                    <!--仓库id, repositories可以配置多个仓库, 保证id不重复-->
                    <id>miaoqi-nexus</id>
                    <!--仓库地址, 即nexus仓库组的地址-->
                    <url>http://localhost:8081/nexus/content/groups/public/</url>
                    <!--是否下载releases构件-->
                    <releases>
                        <enabled>true</enabled>
                    </releases>
                    <!--是否下载snapshots构件-->
                    <snapshots>
                        <enabled>true</enabled>
                    </snapshots>
                </repository>
            </repositories>
            <pluginRepositories>
                <!--插件仓库, maven的运行依赖插件, 也需要从私服下载插件 -->
                <pluginRepository>
                    <!--插件仓库的id不允许重复, 如果重复后边配置会覆盖前边-->
                    <id>miaoqi-nexus</id>
                    <name>Public Repositories</name>
                    <url>http://localhost:8081/nexus/content/groups/public/</url>
                </pluginRepository>
            </pluginRepositories>
            <activation>
                <activeByDefault>true</activeByDefault>
                <jdk>1.8</jdk>
            </activation>
            <properties>
                <maven.compiler.source>1.8</maven.compiler.source>
                <maven.compiler.target>1.8</maven.compiler.target>
                <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
            </properties>
        </profile>
    </profiles>
    <!--默认激活的配置-->
    <activeProfiles>
        <activeProfile>dev</activeProfile>
    </activeProfiles>
</settings>
```



## Maven 环境隔离

在我们开发时候, 开发环境要连接开发环境的数据库, 到了测试和生产还会有各自的数据库地址, 如果每次上线都手动去修改难免出现纰漏, maven 提供了很好的解决方式

我们需要在 pom.xml 文件中配置多环境的配置, 在 maven 执行编译打包命令时, 指定要打包的环境即可加载对应环境的配置文件

**首先来看下 pom.xml**

```xml
<profiles>
    <profile>
        <id>dev</id>
        <activation>
            <activeByDefault>true</activeByDefault>
        </activation>
        <properties>
            <build.profile.id>dev</build.profile.id>
        </properties>
    </profile>
    <profile>
        <id>test</id>
        <activation>
        </activation>
        <properties>
            <build.profile.id>test</build.profile.id>
        </properties>
    </profile>
</profiles>

<build>
    <resources>
        <resource>
            <directory>config/${build.profile.id}</directory>
            <excludes>
                <exclude>*.jsp</exclude>
            </excludes>
        </resource>
        <resource>
            <directory>src/main/resources</directory>
        </resource>
    </resources>
</build>
```

resource 节点指定了 maven 资源文件的路径, 其中 src/main/resources 是 maven 的默认资源文件路径, config/${build.profile.id} 是我们要动态指定加载的路径

profiles 标签配置了不同的 id, 每个 profile 中配置了环境的信息, dev/test

在项目目录下创建 config 文件夹, config 文件夹下分别创建 dev, test 文件夹

在打包的时候使用命令 `mvn clean package -Dmaven.test.skip=true -Pdev` -P 参数指定要激活的 profile, 那么 resource 标签中的路径就会变为 config/dev 作为资源文件路径, 后续的配置就会引用 config/dev 下的资源文件, 等要发布生产时, 就指定 prod 环境, 这样就可以起到隔离配置的效果了



## Maven 内置属性

Maven 共有 6 类属性可以供我们在 pom 文件中应用

### **内置属性**

Maven 预定义, 用户可以直接使用

`${basedir}` 表示项目根目录, 即包含pom.xml文件的目录

`${version}` 表示项目版本

`${roject.basedir}` 同 `${basedir}`

`${roject.baseUri}` 表示项目文件地址;

`${maven.build.timestamp}` 表示项目构件开始时间;

`${maven.build.timestamp.format}` 表示属性 `${maven.build.timestamp}` 的展示格式, 默认值为 yyyyMMdd-HHmm, 可自定义其格式, 其类型可参考 java. text. SimpleDateFormat. 用法如下:

```xml
<properties>
	<maven.build.timestamp.format>yyyy-MM-dd HH:mm:ss</maven.build.timestamp.format>
</properties>
```

### **POM属性**

使用 pom 属性可以引用到 pom.xml 文件对应元素的值

`${project.build.sourceDirectory}`: 项目的主源码目录, 默认为 src/main/java

`${project.build.testSourceDirectory}`: 项目的测试源码目录, 默认为 src/test/java

`${project.build.directory}`: 项目构件输出目录, 默认为 target/

`${project.outputDirectory}`: 项目主代码编译输出目录, 默认为 target/classes/

`${project.testOutputDirectory}`: 项目测试代码编译输出目录, 默认为 target/test-classes/

`${project.groupId}`: 项目的 groupId　　　

`${project.artifactId}`: 项目的 artifactId　

`${project.version}`: 项目的 version 与 `${version}` 等价

`${project.build.sourceEncoding}`: 表示主源码的编码格式

`${project.build.fianlName}`: 项目打包输出文件的名称. 默认为 `${project.artifactId}-${project.version}`

### **自定义属性**

在 pom.xml 文件的 `<properties>` 标签下定义的 Maven 属性

```xml
<project>
    <properties>
        <my.pro>abc</my.pro>
    </properties>
</project>
```

在其他地方使用 ${my. pro} 使用该属性值. 

### **settings.xml文件属性**

与 pom 属性同理, 用户使用以 settings. 开头的属性引用 settings.xml 文件中的 XML 元素值

`${settings.localRepository}`: 表示本地仓库的地址

### **Java系统属性**

所有的 Java 系统属性都可以使用 Maven 属性引用

**使用 `mvn help:system` 命令可查看所有的 Java 系统属性**

`${user.home}`: 表示用户目录

### **环境变量属性**

所有的环境变量都可以用以 env. 开头的 Maven 属性引用

**使用 `mvn help:system` 命令可查看所有环境变量**

`${env.JAVA_HOME}`: 表示 JAVA_HOME 环境变量的值

## Maven 插件

maven 提供了一些非常好用的插件, 所有的插件均在 <http://maven.apache.org/components/plugins/> 可自行查看

### maven-compile-plugin

这个插件的功能是设置 maven 项目编译器的版本, 具体配置如下

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>2.3.2</version>
            <configuration>
                <source>1.8</source>
                <target>1.8</target>
            </configuration>
        </plugin>
    </plugins>
</build>
```

### maven-resources-plugin

#### 指定源文件编译的字符编码

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-resources-plugin</artifactId>
            <version>3.1.0</version>
            <configuration>
                <encoding>UTF-8</encoding>
            </configuration>
        </plugin>
    </plugins>
</build>
```

#### 指定自定义的 resources 路径

maven 默认使用 src/main/resources/ 作为资源路径, 不会加载其他地方的资源, 但我们编写 mapper 文件时会将 xml 文件放在 src/main/java 目录中, 这时候就会导致 xml 文件不被打包, 可以指定自定义资源路径, 默认的路径也要指定上, `<includes>` 可以指定只加载哪些资源文件, `<excludes>` 指定不加载哪些内容, 不指定的话默认都加载

```xml
<build>
    <resources>
        <resource>
            <directory>src/main/java</directory>
            <filtering>true</filtering>
            <includes>
                <include>**/*Mapper.xml</include>
            </includes>
        </resource>
        <resource>
            <directory>src/main/resources</directory>
            <filtering>true</filtering>
            <includes>
                <include>**/*.xml</include>
            </includes>
        </resource>
    </resources>
</build>
```

#### 是否启动筛选

> Variables can be included in your resources. These variables, denoted by the ${…} delimiters, can come from the system properties, your project properties, from your filter resources and from the command line. 

**变量可以包含在您的资源中. 这些变量由 $ {…} 分隔符表示, 可以来自系统属性, 项目属性, 过滤器资源和命令行**

假如我们有一个资源文件 src/main/resource/hello. txt 内容如下

```
Hello ${name}
```

在 pom 中我们定义一个`<name>`标签内容

```xml
<project>
    <name>maven-demo-plugin-web</name>
    <build>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <!--<filtering>true</filtering>-->
            </resource>
        </resources>
    </build>
</project>
```

执行命令 mvn resources:resources, 我们可以看到 target/classes/hello. txt 中的内容还是 hello ${name}

接下来我们打开 `<filtering>` 标签的注释, 再次执行 `mvn resources:resources` 命令

这次我们可以看到 hello. txt 的内容变为了 **hello maven-demo-plugin-web**

**开启了 filter 过滤后则会取 resources 下属性为 name 的 value**

**我们也可以在命令行中指定变量名称**

`mvn resources:resources -Dname="world"`

#### yaml 文件中使用

在开发 springcloud 项目时, 我们会编写 yml 配置文件, 在配置文件中可以获取到 pom 文件中的内容

首先配置该插件

```xml
<build>
    <resources>
        <resource>
            <directory>src/main/resources</directory>
            <filtering>true</filtering>
        </resource>
    </resources>
    <plugins>
        <plugin>
            <!-- 资源文件过滤插件 -->
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-resources-plugin</artifactId>
            <version>2.7</version>
            <configuration>
                <delimiters>
                    <!-- 表示取resources中以$*$的信息 -->
                    <delimit>$</delimit>
                </delimiters>
                <encoding>UTF-8</encoding>
            </configuration>
        </plugin>
    </plugins>
</build>
<properties>
    <my.java.version>2222</my.java.version>
</properties>
```

在 yml 文件中通过 $$ 符号获取 pom 文件中的内容

```yaml
info:
  maven:
    java:
      version: $my.java.version$
```

在编译后的代码中, 我们可以看到此处变为 2222 了

### maven-dependency-plugin

1. 我们需要将源代码编译打包. 这个时候的一个问题就是如果我们引用的库很多的话, 我们希望能够把他们统一打包到一个目录下, 比如 lib 文件夹. 这样部署执行的时候只需要将编译生成的程序 jar 包和依赖包文件夹拷到特定目录去执行. 

2. 需要某个特殊的 jar 包, 但是又不能直接通过 maven 依赖获取, 或者说在其他环境的 maven 仓库内不存在, 那么如何将我们所需要的 jar 包打入我们的生产 jar 包中. 

3. 某个 jar 包内部包含的文件是我们所需要的, 或者是我们希望将它提取出来放入指定的位置 , 那么除了复制粘贴, 如何通过maven 插件实现呢 

**dependency**  插件我们最常用到的是 [dependency:copy](http://maven.apache.org/components/plugins/maven-dependency-plugin/copy-mojo. html)  [dependency:copy-dependencies](http://maven.apache.org/components/plugins/maven-dependency-plugin/copy-dependencies-mojo. html)  及[dependency:unpack](http://maven.apache.org/components/plugins/maven-dependency-plugin/unpack-mojo. html)  [dependency:unpack-dependencies](http://maven.apache.org/components/plugins/maven-dependency-plugin/unpack-dependencies-mojo. html)

dependency:copy: Goal that copies a list of artifacts from the repository to defined locations. 

dependency:copy-dependencies: Goal that copies the project dependencies from the repository to a defined location. 

dependency:unpack: Goal that retrieves a list of artifacts from the repository and unpacks them in a defined location. 

dependency:unpack-dependencies: Goal that unpacks the project dependencies from the repository to a defined location. 

将 junit, slf4j-log4j12 在 package 生命周期打包到指定的目录中

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-dependency-plugin</artifactId>
    <version>3.0.1</version>
    <executions>
        <execution>
            <id>copy</id>
            <!-- 阶段 -->
            <phase>package</phase>
            <goals>
            	  <!-- 插件类型 -->
                <goal>copy</goal>
            </goals>
            <configuration>
                <artifactItems>
                    <artifactItem>
                        <groupId>junit</groupId>
                        <artifactId>junit</artifactId>
                        <version>4.11</version>
                        <outputDirectory>${project.build.directory}/lib/lib1</outputDirectory>
                    </artifactItem>
                    <artifactItem>
                        <groupId>org.slf4j</groupId>
                        <artifactId>slf4j-log4j12</artifactId>
                        <version>1.7.7</version>
                        <outputDirectory>${project.build.directory}/lib/lib1</outputDirectory>
                    </artifactItem>
                </artifactItems>
            </configuration>
        </execution>
    </executions>
</plugin>
```

打个比方, dubbo 的一个 jar 包封装了启动命令脚本, 现在我们要上生产了, 我们希望生产环境利用这个启动命令进行项目的启动, 那么在 jar 包就肯定不行了, 那么我们怎么将这些提取出来呢, 当然只能打开了

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-dependency-plugin</artifactId>
    <executions>
        <execution>
            <id>unpack</id>
            <phase>package</phase>
            <goals>
                <goal>unpack</goal>
            </goals>
            <configuration>
                <artifactItems>
                    <artifactItem>
                        <groupId>com.alibaba</groupId>
                        <artifactId>dubbo</artifactId>
                        <outputDirectory>${project.build.directory}/dubbo</outputDirectory>
                        <includes>META-INF/assembly/**</includes>
                    </artifactItem>
                </artifactItems>
            </configuration>
        </execution>
    </executions>
</plugin>
```

拷贝全部 jar 包到指定目录, 排除不需要拷贝的 jar, 因为 service 会被我们聚合到一个 jar 包中, 所以我们不需要将 service 复制到第三方库目录下, 使用 `excludeArtifactIds` 进行排除

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-dependency-plugin</artifactId>
    <executions>
        <execution>
            <!-- 拷贝全部依赖 -->
            <id>copy-dependencies</id>
            <phase>package</phase>
            <goals>
                <goal>copy-dependencies</goal>
            </goals>
            <configuration>
                <outputDirectory>${project.build.directory}/lib</outputDirectory>
                <excludeArtifactIds>
                    maven-demo-plugin-service
                </excludeArtifactIds>
            </configuration>
        </execution>
    </executions>
</plugin>
```

**总结一下 copy 与 unpack 都是针对指定的 artifactId 需要配置 `<artifactItems>` 来指定我们需要的 jar 包, copy-dependencies 与 unpack-dependencies 是针对全部的依赖进行操作需要使用 `<excludeArtifactIds>` 来指定我们需要排除的依赖**



### maven-assembly-plugin

> The Assembly Plugin for Maven is primarily intended to allow users to aggregate the project output along with its dependencies, modules, site documentation, and other files into a single distributable archive. 

Maven-assembly-plugin 是 maven 中针对打包任务而提供的标准插件, 可以实现自定义打包. 

默认情况下, 打 `jar` 包时, 只有在类路径上的文件资源会被打包到 `jar` 中, 并且文件名是 `${artifactId}-${version}. jar`, 下面看看怎么用 `maven-assembly-plugin` 插件来定制化打包. 

要使用 maven-assembly-plugin, 需要指定至少一个要使用的 assembly descriptor 文件. 默认情况下, maven-assembly-plugin 内置了几个可以用的 assembly descriptor(不建议使用)

- bin : 类似于默认打包, 会将 bin 目录下的文件打到包中
- jar-with-dependencies: 会将所有依赖都解压打包到生成物中
- src: 只将源码目录下的文件打包
- project: 将整个 project 资源打包.

添加插件依赖

```xml
<plugins>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-assembly-plugin</artifactId>
        <executions>
            <execution>
                <id>make-assembly</id>
                <!-- 绑定到 package 生命周期 -->
                <phase>package</phase>
                <goals>
                    <!-- 只执行一次 -->
                    <goal>single</goal>
                </goals>
                <configuration>
                    <!-- <finalName>demo</finalName> -->
                    <archive>
                        <manifest>
                            <!-- 指定程序的主入口 -->
                            <mainClass>com.miaoqi.maven.plugin.Application</mainClass>
                        </manifest>
                    </archive>
                    <descriptors>
                        <!-- 指定描述器文件 -->
                        <descriptor>src/main/assembly/assembly.xml</descriptor>
                    </descriptors>
                    <!-- 内置描述器
                    <descriptorRefs>
                        <descriptorRef>jar-with-dependencies</descriptorRef>
                    </descriptorRefs>
                    -->
                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
```

添加自定义描述器

```xml
<assembly>
    <id>deploy</id>
    <formats>
        <format>zip</format>
    </formats>
    <fileSets>
        <fileSet>
            <directory>target/maven-demo-plugin. deploy</directory>
            <outputDirectory>/</outputDirectory>
        </fileSet>
    </fileSets>
</assembly>
```

**format**: maven-assembly-plugin 支持的打包格式有zip,tar,tar.gz (or tgz),tar.bz2 (or tbz2),jar,dir,war, 可以同时指定多个打包格式

**includeBaseDirectory**: 指定是否包含打包层目录(比如 `finalName` 是 `maven-demo-plugin-assembly-1.0-SNAPSHOT`, 当值为 `true`, 所有文件被放在  `maven-demo-plugin-assembly-1.0-SNAPSHOT` 目录下, 否则直接放在包的根目录下), 建议为 true

**fileSets**: 指定要包含的文件集, 可以定义多个 `fileSet`

**directory**: 指定要打包文件的目录

**outputDirectory**: 指定当前要包含的目录的目的地, 如果指定 outputDirectory 为 xxx, 则 directory 目录下的内容在打包时会在上层生成 xxx 目录, 一般不指定

**接下来我们执行 mvn clean package 命令会生成一个 `maven-demo-plugin-assembly-1.0-SNAPSHOT-deploy. zip` 文件在目录 `output` 下, 其中前一个 `maven-demo-plugin-assembly-1.0-SNAPSHOT` 来自`finalName`, finalName 默认是 `${project.artifactId}-${project.version}`, 后一个 `deploy` 来自assembly descriptor 中的 `id`, 其中的内容就是 directory 目录指定的内容**

如果只想有 finalName, 则增加配置: 

```xml
<appendAssemblyId>false</appendAssemblyId>
```

接下来我们可以使用命令

```bash
nohup java -DServerName=mavenplugin -classpath core/*:lib/* com.miaoqi.maven.plugin.Application &
```

执行我们 zip 包中的内容, 启动 java 主程序

**该插件一般结合 maven-dependency-plugin 插件使用, dependency 插件将我们依赖的三方包拷贝的指定目录中, 再使用 assembly 插件将指定目录中的内容打成我们想要的格式**



### maven-release-plugin

maven-release-plugin 主要有三个目标,他们分别为:

**release:prepare**

这条命令主要是做打包前的准备. 

**输入对应的 release 需要打包的版本等信息, 如果不输入有默认的内容 将需要记录和准备的内容缓存到 pom.xml 目录下的 release.properties 文件中 在本地和远程库的 GIT 中打上对应版本的 tag**

在准备过程中还会 run 单元测试等 phase, 如果没有异常的话可以继续最后一步. 

准备版本发布, 依次执行下列操作:

1. 检查项目是否有未提交的代码. 
2. 检查项目是否有快照版本依赖. 
3. 根据用户的输入将快照版本升级为发布版. 
4. 将POM中的SCM信息更新为标签地址. 
5. 基于修改后的POM执行Maven构建. 
6. 提交POM变更. 
7. 基于用户输入为代码打标签. 
8. 将代码从发布版升级为新的快照版. 
9. 提交POM变更. 

**release:rollback**

回退release:prepare所执行的操作. 将POM回退至release:prepare之前的状态, 并提交. 需要注意的是, 该步骤不会删除release:prepare生成的标签, 因此用户需要手动删除. 

如果在准备阶段发生错误, 或者需要修改某些地方的话. 就需要到这个命令了, 这个命令执行以后会做以下这些事

删除线上git库tag, 但是本地库tag没有被删除, 需要手动使用git tag -d XXX进行删除. 如果不将本地库中的tag删除将会导致prepare失败.  删除之前缓存在pom.xml统一目录下的配置

**release:perform**

如果确认无误了以后, 就可以执行perform命令了. 这个命令干了以下这些事：

验证代码合法性 将你之前的1.0-SNAPSHOT改为1.1-SNAPSHOT 将1.0版本deploy至scm配置的nexus release库中 将代码source. jar版本 javacode. jar打包上传至nexus库

恭喜, 你已经把你的1.0-SNAPSHOT成功的打包成1.0的release版本了. 同时你会发现你的pom.xml文件会自动的变成1.1-SNAPSHOT版本. 虽然这一系列操作都可以通过手动完成. 但是有这个工具的存在, 免去了很多步骤. 也规范了流程, 何乐而不为呢. 



要为项目发布版本, 首先需要为其添加正确的版本控制系统信息, 这是因为Maven Release Plugin需要知道版本控制系统的主干, 标签等地址信息后才能执行相关的操作. 一般配置项目的SCM信息如下:

```xml
<project>
    <scm>
        <connection>scm:git:http://项目git地址</connection>
        <url>项目git地址（不加'.git后缀'）</url>
        <developerConnection>scm:项目git地址</developerConnection>
    </scm>
</project>
```

该配置只告诉Maven当前代码的位置(主干), 而版本发布还要涉及标签操作. 因此还需要配置maven-release-plugin告诉其标签的基础目录, 如下:

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-release-plugin</artifactId>
    <version>2.5.3</version>
    <configuration>
        <tagNameFormat>v@{project.version}</tagNameFormat>
        <autoVersionSubmodules>true</autoVersionSubmodules>
    </configuration>
</plugin>
```

在执行release:prepare之前还有两个注意点：第一系统必须提供svn命令行工具, Maven需要svn命令行工具执行相关操作, 而无法使用图形化的工具；第二, POM必须配置了可用的部署仓库, 因为release:perform会执行deploy操作将构件发布到仓库中. 一切就绪之后, 在项目跟目录下运行如下命令:

```bash
mvn release:prepare
```

如果需要跳过单元测试, 可以加入参数 -Darguments="-DskipTests", 直接使用-Dmaven.test.skip=true是无效的. 

maven-release-plugin 开始准备发布版本, 如果它检测到项目有为提交的代码或者项目有快照的依赖, 则会提示出错. 如果一切都没有问题, 则会提示用户输入想要发布的版本号, 标签的名称以及新的快照版本号. 

至此 release:prepare 的工作完成. 如果这时你发现了一些问题, 例如将标签名称配置错了, 则可以使用 release:rollback 命令回退发布, maven-release-plugin会将POM的配置回到release:prepare之前的状态. 但需要注意的是, 版本控制系统中的标签并不会被删除, 也就是说用户需要手动执行版本控制系统命令删除该标签. 

在多模块项目中执行 release:prepare 的时候, 默认maven-release-plugin会提示用户设定每个模块发布版本号及新的开发版本号(如在xxx-parent模块中配置). 但是很多情况下我们希望所有模块的发布版本以及新的SNAPSHOT开发版本都保持一致. 为了避免重复确认, maven-release-plugin提供了autoVersionSubmodules参数, 运行下面命令后, maven-release-plugin就会自动为所有子模块使用与父模块一致的发布版本和新的SNAPSHOT版本:

```bash
mvn release:prepare -DautoVersionSubmodules=true
```

如果检查下来 release:prepare 的结果没有问题, 标签和新的开发版本都是正确的, 可以执行如下发布执命令:

```bash
mvn release:perform
```

如果你所发布项目的打包类型为 jar, 在执行 release:perform 之后, 不仅项目的主构件会被生成并发布到仓库中, 基于该主构件的-sources.jar 和 -javadoc.jar 也会生成并发布. 在执行 mvn release:perform 时默认会生成api文档, 如果默写注释不符合规范的话会造成构建失败, 可以加参数-DuseReleaseProfile=false取消构建api文档, 或则需要根据规范书写注释. 

**自动化创建分支**: 用的不多以后再补. 