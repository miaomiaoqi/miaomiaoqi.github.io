---
layout: post
title: Redis 底层结构
categories: [NoSql]
description: 
keywords: 
---


* content
{:toc}




## 对象类型和编码

Redis 一共有 5 大种数据类型, 但是在 Redis 中, 这几种数据类型底层是由什么数据结构构造的呢？我们可以使用`OBJECT ENCODING key`查看 5 大数据类型

Redis 使用对象来存储键和值的, 在Redis中, 每个对象都由 redisObject 结构表示。redisObject 主要的信息包括数据类型(type), 编码方式(encoding), 数据指针(ptr), 虚拟内存(vm)等.type代表一个value对象具体是何种数据类型(应用结构), encoding是不同数据类型在 redis 内部式(底层结构).

```c
typedef struct redisObject {  
  
    // 类型  
    unsigned type: 4;          

    // 编码方式  
    unsigned encoding: 4;  
  
    // 引用计数  
    int refcount;  
  
    // 指向底层实现数据结构的指针
    void *ptr
    
    // 虚拟内存和其他信息等.....
  
} robj; 
```

<img src="http://www.milky.show/images/redis/redis_4.png" alt="http://www.milky.show/images/redis/redis_4.png" style="zoom:50%;" />

**其中 type 属性记录了对象的类型。对于 Redis 来说, 键对象总是字符串类型, 值对象可以是任意支持的类型。因此, 当我们说 Redis 键采用哪种对象类型的时候, 指的是对应的值采用哪种对象类型。5 大种数据结构对应的 type 值**

| 类型常量     | 对象的名称   | type值 |
| ------------ | ------------ | ------ |
| REDIS_STRING | 字符串对象   | string |
| REDIS_LIST   | 列表对象     | list   |
| REDIS_HASH   | 哈希对象     | hash   |
| REDIS_SET    | 集合对象     | set    |
| REDIS_ZSET   | 有序集合对象 | zset   |

**\*ptr 属性指向了对象的底层数据结构, 而这些数据结构由 encoding 属性决定。Redis 一共有 8 种底层数据结构对应 redisObject 的 encoding:**

| 编码常量                  | 编码所对应的底层数据结构            |
| :------------------------ | :---------------------------------- |
| REDIS_ENCODING_INT        | long 类型的整数                     |
| REDIS_ENCODING_EMBSTR     | embstr编码的SDS(简单动态字符串对象) |
| REDIS_ENCODING_RAW        | row编码的SDS                        |
| REDIS_ENCODING_LINKEDLIST | 双端链表                            |
| REDIS_ENCODING_HT         | 字典                                |
| REDIS_ENCODING_SKIPLIST   | 跳跃表和字典                        |
| REDIS_ENCODING_INTSET     | 整数集合                            |
| REDIS_ENCODING_ZIPLIST    | 压缩列表                            |

之所以由 encoding 属性来决定对象的底层数据结构, 是为了实现同一对象类型, 支持不同的底层实现。这样就能在不同场景下, 使用不同的底层数据结构, 进而极大提升Redis的灵活性和效率。



## 字符串对象(String)

字符串是我们日常工作中用得最多的对象类型, 它对应的编码可以是 int、raw 和 embstr。

如果一个字符串对象保存的是不超过 long 类型的整数值, 此时编码类型即为 int, 其底层数据结构直接就是 long 类型。例如执行 set number 10086, 就会创建 int 编码的字符串对象作为 number 键的值。

<img src="http://www.milky.show/images/redis/redis_96.png" alt="http://www.milky.show/images/redis/redis_96.png" style="zoom:33%;" />

```c
#define REDIS_ENCODING_EMBSTR_SIZE_LIMIT 44  
robj *createStringObject(char *ptr,  size_t len) {  
    if (len <= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)  
        return createEmbeddedStringObject(ptr, len);  
    else  
        return createRawStringObject(ptr, len);  
}  
```

如果字符串对象保存的是一个长度大于 39 字节的字符串, 此时编码类型即为 raw, 其底层数据结构是简单动态字符串(SDS)；如果长度小于等于 39 个字节, 编码类型则为 embstr, 底层数据结构就是 embstr 编码 SDS。下面, 我们详细理解下什么是简单动态字符串。



### 简单动态字符串(embstr, raw)

字符串是我们日常工作中用得最多的对象类型, 它对应的编码可以是 int、raw 和 embstr。字符串对象相关命令可参考:Redis命令-Strings。

如果一个字符串对象保存的是不超过 long 类型的整数值, 此时编码类型即为 int, 其底层数据结构直接就是 long 类型。例如执行 set number 10086, 就会创建 int 编码的字符串对象作为 number 键的值。

<img src="http://www.milky.show/images/redis/redis_90.png" alt="http://www.milky.show/images/redis/redis_90.png" style="zoom: 50%;" />

如果字符串对象保存的是一个长度大于 39 字节的字符串, 此时编码类型即为 raw, 其底层数据结构是简单动态字符串(SDS)；如果长度小于等于 39 个字节, 编码类型则为 embstr, 底层数据结构就是 embstr 编码 SDS。下面, 我们详细理解下什么是简单动态字符串。



Redis 没有直接使用 C 语言传统的字符串表示(以空字符结尾的字符数组, 以下简称 C 字符串), 而是自己构建了一种名为简单动态字符串(simple dynamic string, SDS)的抽象类型, 并将 SDS 用作 Redis 的默认字符串表示.

在 Redis 里面, C 字符串只会作为字符串字面量(string literal), 用在一些无须对字符串值进行修改的地方, 比如打印日志: 

```java
redisLog(REDIS_WARNING, "Redis is now ready to exit,  bye bye...");
```

当 Redis 需要的不仅仅是一个字符串字面量, 而是一个可以被修改的字符串值时, Redis 就会使用 SDS 来表示字符串值:  比如在 Redis 的数据库里面, 包含字符串值的键值对在底层都是由 SDS 实现的.

举个例子, 如果客户端执行命令: 

```bash
redis> SET msg "hello world"
OK
```

那么 Redis 将在数据库中创建了一个新的键值对, 其中: 

键值对的键是一个字符串对象, 对象的底层实现是一个保存着字符串 "msg" 的 SDS .
键值对的值也是一个字符串对象, 对象的底层实现是一个保存着字符串 "hello world" 的 SDS .
又比如说, 如果客户端执行命令: 

```bash
redis> RPUSH fruits "apple" "banana" "cherry"
(integer) 3
```

那么 Redis 将在数据库中创建一个新的键值对, 其中: 

键值对的键是一个字符串对象, 对象的底层实现是一个保存了字符串 "fruits" 的 SDS .键值对的值是一个列表对象, 列表对象包含了三个字符串对象, 这三个字符串对象分别由三个 SDS 实现:  第一个 SDS 保存着字符串 "apple" , 第二个 SDS 保存着字符串 "banana" , 第三个 SDS 保存着字符串 "cherry" .除了用来保存数据库中的字符串值之外, SDS 还被用作缓冲区(buffer):  AOF 模块中的 AOF 缓冲区, 以及客户端状态中的输入缓冲区, 都是由 SDS 实现的, 在之后介绍 AOF 持久化和客户端状态的时候, 我们会看到 SDS 在这两个模块中的应用.

**SDS 的定义:**

```c
struct sdshdr{

     //记录buf数组中已使用字节的数量
     //等于 SDS 保存字符串的长度
     int len;

     //记录 buf 数组中未使用字节的数量
     int free;

     //字节数组,  用于保存字符串
     char buf[];
}
```

SDS 遵循了 C 字符串以空字符结尾的惯例, 保存空字符的 1 字节不会计算在 len 属性里面。例如, Redis 这个字符串在 SDS 里面的数据可能是如下形式:

<img src="http://www.milky.show/images/redis/redis_91.png" alt="http://www.milky.show/images/redis/redis_91.png" style="zoom: 50%;" />

我们看上面对于 SDS 数据类型的定义: 

- free 属性的值为 0, 表示这个 SDS 没有分配任何未使用空间.
- len 属性的值为 5, 表示这个 SDS 保存了一个五字节长的字符串.
- buf 属性是一个 char 类型的数组, 数组的前五个字节分别保存了 'R', 'e', 'd', 'i', 's' 五个字符, 而最后一个字节则保存了空字符 '\0' .



C 语言使用长度为 N+1 的字符数组来表示长度为N的字符串, 并且字符串的最后一个元素是空字符 \0。Redis 采用 SDS 相对于 C 字符串有如下几个优势:

1. 常数复杂度获取字符串长度；
2. 杜绝缓冲区溢出；
3. 减少修改字符串时带来的内存重分配次数；
4. 二进制安全。

上面的定义相对于 C 语言对于字符串的定义, 多出了 len 属性以及 free 属性.为什么不使用C语言字符串实现, 而是使用 SDS呢？这样实现有什么好处？

1. **常数复杂度获取字符串长度**

    因为 C 字符串并不记录自身的长度信息, 所以为了获取字符串的长度, 必须遍历整个字符串, 时间复杂度是 **O(N**)。而 SDS 使用 len 属性记录了字符串的长度, 因此获取 SDS字符串长度的时间复杂度是 **O(1)**。

    由于 len 属性的存在, 我们获取 SDS 字符串的长度只需要读取 len 属性, 时间复杂度为 O(1) .而对于 C 语言, 获取字符串的长度通常是经过遍历计数来实现的, 时间复杂度为 O(n).**通过 strlen key 命令可以获取 key 的字符串长度.**

    设置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的, 使用 SDS 无须进行任何手动修改长度的工作. 

    通过使用 SDS 而不是 C 字符串, Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1)  , 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈.

    比如说, 因为字符串键在底层使用 SDS 来实现, 所以即使我们对一个非常长的字符串键反复执行 STRLEN 命令, 也不会对系统性能造成任何影响, 因为 STRLEN 命令的复杂度仅为 O(1)  .

2. **杜绝缓冲区溢出**

    除了获取字符串长度的复杂度高之外, C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出(buffer overflow).

    举个例子, <string.h>/strcat 函数可以将 src 字符串中的内容拼接到 dest 字符串的末尾: 

    ```c
    char *strcat(char *dest,  const char *src);
    ```

    因为 C 字符串不记录自身的长度, 所以 strcat 假定用户在执行这个函数时, 已经为 dest 分配了足够多的内存, 可以容纳 src 字符串中的所有内容, 而一旦这个假定不成立时, 就会产生缓冲区溢出.

    举个例子, 假设程序里有两个在内存中紧邻着的 C 字符串 s1 和 s2 , 其中 s1 保存了字符串 "Redis" , 而 s2 则保存了字符串 "MongoDB"

    <img src="http://www.milky.show/images/redis/redis_19.png" alt="http://www.milky.show/images/redis/redis_19.png" style="zoom: 33%;" />

    如果一个程序员决定通过执行: 

    ```C
    strcat(s1,  " Cluster");
    ```

    将 s1 的内容修改为 "Redis Cluster" , 但粗心的他却忘了在执行 strcat 之前为 s1 分配足够的空间, 那么在 strcat 函数执行之后, s1 的数据将溢出到 s2 所在的空间中, 导致 s2 保存的内容被意外地修改, 如图 2-8 所示.

    <img src="http://www.milky.show/images/redis/redis_20.png" alt="http://www.milky.show/images/redis/redis_20.png" style="zoom:33%;" />

    与 C 字符串不同, SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性:  当 SDS API 需要对 SDS 进行修改时, API 会先检查 SDS 的空间是否满足修改所需的要求, 如果不满足的话, API 会自动将 SDS 的空间扩展至执行修改所需的大小, 然后才执行实际的修改操作, 所以使用 SDS 既不需要手动修改 SDS 的空间大小, 也不会出现前面所说的缓冲区溢出问题.

    举个例子, SDS 的 API 里面也有一个用于执行拼接操作的 sdscat 函数, 它可以将一个 C 字符串拼接到给定 SDS 所保存的字符串的后面, 但是在执行拼接操作之前, sdscat 会先检查给定 SDS 的空间是否足够, 如果不够的话, sdscat 就会先扩展 SDS 的空间, 然后才执行拼接操作.

    比如说, 如果我们执行: 

    ```c
    sdscat(s,  " Cluster");
    ```

    其中 SDS 值 s 如图 2-9 所示, 那么 sdscat 将在执行拼接操作之前检查 s 的长度是否足够, 在发现 s 目前的空间不足以拼接 " Cluster" 之后, sdscat 就会先扩展 s 的空间, 然后才执行拼接 " Cluster" 的操作, 如图所示.

    <img src="http://www.milky.show/images/redis/redis_17.png" alt="http://www.milky.show/images/redis/redis_17.png" style="zoom: 50%;" />

    <img src="http://www.milky.show/images/redis/redis_18.png" alt="http://www.milky.show/images/redis/redis_18.png" style="zoom: 33%;" />

    **sdscat 不仅对这个 SDS 进行了拼接操作, 它还为 SDS 分配了 13 字节的未使用空间, 并且拼接之后的字符串也正好是 13 字节长, 这种现象既不是 bug 也不是巧合, 它和 SDS 的空间分配策略有关.**

3. **减少修改字符串的内存重新分配次数**

    因为 C 字符串并不记录自身的长度, 所以对于一个包含了 N 个字符的 C 字符串来说, 这个 C 字符串的底层实现总是一个 N+1 个字符长的数组(额外的一个字符空间用于保存空字符).

    因为 C 字符串的长度和底层数组的长度之间存在着这种关联性, 所以每次增长或者缩短一个 C 字符串, 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作: 

    - 如果程序执行的是增长字符串的操作, 比如拼接操作(append), 那么在执行这个操作之前, 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出.
    - 如果程序执行的是缩短字符串的操作, 比如截断操作(trim), 那么在执行这个操作之后, 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏.

    因为内存重分配涉及复杂的算法, 并且可能需要执行系统调用, 所以它通常是一个比较耗时的操作: 

    - 在一般程序中, 如果修改字符串长度的情况不太常出现, 那么每次修改都执行一次内存重分配是可以接受的.
    - 但是 Redis 作为数据库, 经常被用于速度要求严苛, 数据被频繁修改的场合, 如果每次修改字符串的长度都需要执行一次内存重分配的话, 那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分, 如果这种修改频繁地发生的话, 可能还会对性能造成影响.

    **而对于SDS, 由于len属性和free属性的存在, 对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略: **

    - **空间预分配: **空间预分配用于优化 SDS 的字符串增长操作:  当 SDS 的 API 对一个 SDS 进行修改, 并且需要对 SDS 进行空间扩展的时候, 程序不仅会为 SDS 分配修改所必须要的空间, 还会为 SDS 分配额外的未使用空间.其中, 额外分配的未使用空间数量由以下公式决定: 

        - 如果对 SDS 进行修改之后, SDS 的长度(也即是 len 属性的值)将小于 1 MB , 那么程序分配和 len 属性同样大小的未使用空间, 这时 SDS len 属性的值将和 free 属性的值相同. 举个例子, 如果进行修改之后, SDS 的 len 将变成 13 字节, 那么程序也会分配 13 字节的未使用空间, SDS 的 buf 数组的实际长度将变成 13 + 13 + 1 = 27 字节(额外的一字节用于保存空字符).
        - 如果对 SDS 进行修改之后, SDS 的长度将大于等于 1 MB , 那么程序会分配 1 MB 的未使用空间. 举个例子, 如果进行修改之后, SDS 的 len 将变成 30 MB , 那么程序会分配 1 MB 的未使用空间, SDS 的 buf 数组的实际长度将为 30 MB + 1 MB + 1 byte.

        通过空间预分配策略, Redis 可以减少连续执行字符串增长操作所需的内存重分配次数.

    - **惰性空间释放: **对字符串进行缩短操作时, 程序不立即使用内存重新分配来回收缩短后多余的字节, 而是使用 free 属性将这些字节的数量记录下来, 等待后续使用.(当然SDS也提供了相应的API, 当我们有需要时, 也可以手动释放这些未使用的空间.)

4. **二进制安全**

    C 字符串中的字符必须符合某种编码(比如 ASCII), 并且除了字符串的末尾之外, 字符串里面不能包含空字符, 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据, 而不能保存像图片, 音频, 视频, 压缩文件这样的二进制数据.

    虽然数据库一般用于保存文本数据, 但使用数据库来保存二进制数据的场景也不少见, 因此, 为了确保 Redis 可以适用于各种不同的使用场景, SDS 的 API 都是二进制安全的(binary-safe):  所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据, 程序不会对其中的数据做任何限制, 过滤, 或者假设 —— 数据在写入时是什么样的, 它被读取时就是什么样. SDS 是以 len 属性表示的长度来判断字符串是否结束

    这也是我们将 SDS 的 buf 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符, 而是用它来保存一系列二进制数据.

5. **兼容部分 C 字符串函数**

    虽然 SDS 的 API 都是二进制安全的, 但它们一样遵循 C 字符串以空字符结尾的惯例:  这些 API 总会将 SDS 保存的数据的末尾设置为空字符, 并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符, 这是为了让那些保存文本数据的 SDS 可以重用一部分 <string.h> 库定义的函数.

| C 字符串                                     | SDS                                          |
| -------------------------------------------- | -------------------------------------------- |
| 获取字符串长度的复杂度为 O(N)                | 获取字符串长度的复杂度为O(1)                 |
| API 是不安全的, 可能会造成缓冲区溢出         | API 是安全的, 不会造成溢出                   |
| 修改字符串 N 次**必然**需要执行 N 次内存分配 | 修改字符串 N 次**最多**需要执行 N 次内存分配 |
| 只能保存文本数据                             | 可以保存文本或者二进制数据                   |
| 可以使用所有<string.h>库中的函数             | 可以使用一部分<string.h>库中的函数           |



### raw 和 embstr 编码的 SDS 区别

我们在前面讲过, 长度大于 39 字节的字符串, 编码类型为 raw, 底层数据结构是简单动态字符串(SDS)。这个很好理解, 比如当我们执行 set story "Long, long, long ago there lived a king ..."(长度大于39)之后, Redis 就会创建一个 raw 编码的 String 对象。

数据结构如下:

<img src="http://www.milky.show/images/redis/redis_92.png" alt="http://www.milky.show/images/redis/redis_92.png" style="zoom: 50%;" />

长度小于等于 39 个字节的字符串, 编码类型为 embstr, 底层数据结构则是 embstr 编码 SDS。embstr 编码是专门用来保存短字符串的, 它和 raw 编码最大的不同在于:raw 编码会调用两次内存分配分别创建 redisObject 结构和 sdshdr 结构；而 embstr 编码则是只调用一次内存分配, 在一块连续的空间上同时包含 redisObject 结构和 sdshdr 结构。

<img src="http://www.milky.show/images/redis/redis_93.png" alt="http://www.milky.show/images/redis/redis_93.png" style="zoom: 50%;" />

### 编码转换

int 编码和 embstr 编码的字符串对象在条件满足的情况下会自动转换为 raw 编码的字符串对象。 

对于 int 编码来说, 当我们修改这个字符串为不再是整数值的时候, 此时字符串对象的编码就会从 int 变为 raw。

对于 embstr 编码来说, 只要我们修改了字符串的值, 此时字符串对象的编码就会从 embstr 变为 raw。

embstr 编码的字符串对象可以认为是只读的, 因为 Redis 为其编写任何修改程序。当我们要修改 embstr 编码字符串时, 都是先将转换为 raw 编码, 然后再进行修改。



embstr的好处有如下几点: 

1. embstr的创建只需分配一次内存, 而raw为两次(一次为[`sds`](https://github.com/antirez/redis/blob/unstable/src/sds.h)分配对象, 另一次为objet分配对象, embstr省去了第一次).
2. 相对地, 释放内存的次数也由两次变为一次.
3. embstr的objet和sds放在一起, 更好地利用缓存带来的优势.
4. 但redis不集成对embstr的操作, 因此执行命令时, 会自动将embstr转换为row编码

raw 和 embstr 的区别可以用下面两幅图所示: 

**raw 编码的字符串对象:**

<img src="http://www.milky.show/images/redis/redis_11.png" alt="http://www.milky.show/images/redis/redis_11.png" style="zoom:33%;" />

**embstr 编码的字符串对象:**

<img src="http://www.milky.show/images/redis/redis_12.png" alt="http://www.milky.show/images/redis/redis_12.png" style="zoom:33%;" />

**当字符串对象是由整数构成时, 采用整数值作为底层结构; 当对象有字符串构成, 且值小于32字节, 此时用embstr编码的SDS, 否则采用row编码的SDS.**



**重点回顾**

- Redis 只会使用 C 字符串作为字面量, 在大多数情况下, Redis 使用 SDS (Simple Dynamic String, 简单动态字符串)作为字符串表示.
- 比起 C 字符串, SDS 具有以下优点:  
    1. 常数复杂度获取字符串长度.
    2. 杜绝缓冲区溢出.
    3. 减少修改字符串长度时所需的内存重分配次数.
    4. 二进制安全.
    5. 兼容部分 C 字符串函数.





## 列表对象(List)

列表对象的编码可以是 linkedlist 或者 ziplist, 对应的底层数据结构是链表和压缩列表。列表对象相关命令可参考:Redis 命令-List。

默认情况下, 当列表对象保存的所有字符串元素的长度都小于 64 字节, 且元素个数小于 512 个时, 列表对象采用的是 ziplist 编码, 否则使用 linkedlist 编码。

可以通过配置文件修改该上限值。



### 双端链表(linkedlist)

链表提供了高效的节点重排能力, 以及顺序性的节点访问方式, 并且可以通过增删节点来灵活地调整链表的长度.

作为一种常用数据结构, 链表内置在很多高级的编程语言里面, 因为 Redis 使用的 C 语言并没有内置这种数据结构, 所以 Redis 构建了自己的链表实现.

链表在 Redis 中的应用非常广泛, 比如列表键的底层实现之一就是链表:  **当一个列表键包含了数量比较多的元素, 又或者列表中包含的元素都是比较长的字符串时, Redis 就会使用链表作为列表键的底层实现**.

**链表节点定义**

```c
typedef struct listNode {
    // 前置节点
    struct listNode *prev;
    // 后置节点
    struct listNode *next;
    // 节点的值
    void *value;
} listNode;
```

**通过多个 listNode 结构就可以组成链表, 这是一个双端链表, Redis还提供了操作链表的数据结构: **

<img src="http://www.milky.show/images/redis/redis_94.png" alt="http://www.milky.show/images/redis/redis_94.png" style="zoom: 33%;" />

为了操作起来比较方便, Redis 使用了 list 结构持有链表。

```c
typedef struct list {
    // 表头节点
    listNode *head;
    // 表尾节点
    listNode *tail;
    // 链表所包含的节点数量
    unsigned long len;
    // 节点值复制函数
    void *(*dup)(void *ptr);
    // 节点值释放函数
    void (*free)(void *ptr);
    // 节点值对比函数
    int (*match)(void *ptr,  void *key);
} list;
```

list 结构为链表提供了表头指针 head , 表尾指针 tail , 以及链表长度计数器 len , 而 dup ,  free 和 match 成员则是用于实现多态链表所需的类型特定函数: 

- dup 函数用于复制链表节点所保存的值; 
- free 函数用于释放链表节点所保存的值; 
- match 函数则用于对比链表节点所保存的值和另一个输入值是否相等.

<img src="http://www.milky.show/images/redis/redis_95.png" alt="http://www.milky.show/images/redis/redis_95.png" style="zoom: 33%;" />

Redis 的链表实现的特性可以总结如下: 

- 双端:  链表节点带有 prev 和 next 指针, 获取某个节点的前置节点和后置节点的复杂度都是 O(1)  .
- 无环:  表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL , 对链表的访问以 NULL 为终点.
- 带表头指针和表尾指针:  通过 list 结构的 head 指针和 tail 指针, 程序获取链表的表头节点和表尾节点的复杂度为 O(1)  .
- 带链表长度计数器:  程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数, 程序获取链表中节点数量的复杂度为 O(1)  .
- 多态:  链表节点使用 void* 指针来保存节点值, 并且可以通过 list 结构的 dup ,  free ,  match 三个属性为节点值设置类型特定函数, 所以链表可以用于保存各种不同类型的值.

**重点回顾**

- 链表被广泛用于实现 Redis 的各种功能, 比如列表键, 发布与订阅, 慢查询, 监视器, 等等.
- 每个链表节点由一个 listNode 结构来表示, 每个节点都有一个指向前置节点和后置节点的指针, 所以 Redis 的链表实现是双端链表.
- 每个链表使用一个 list 结构来表示, 这个结构带有表头节点指针, 表尾节点指针, 以及链表长度等信息.
- 因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL , 所以 Redis 的链表实现是无环链表.
- 通过为链表设置不同的类型特定函数, Redis 的链表可以用于保存各种不同类型的值.



### 压缩列表(ziplist)

压缩列表(ziplist)是列表键和哈希键的底层实现之一.

压缩列表也是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。

压缩列表主要目的是为了节约内存, 是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点, 每个节点可以保存一个字节数组或者一个整数值。

**当一个列表键只包含少量列表项, 并且每个列表项要么就是小整数值, 要么就是长度比较短的字符串, 那么 Redis 就会使用压缩列表来做列表键的底层实现. 比如说, 执行以下命令将创建一个压缩列表实现的列表键:** 

```bash
redis> RPUSH lst 1 3 5 10086 "hello" "world"
(integer) 6

redis> OBJECT ENCODING lst
"ziplist"
```

因为列表键里面包含的都是 1, 3, 5, 10086 这样的小整数值, 以及 "hello","world" 这样的短字符串.

**另外, 当一个哈希键只包含少量键值对, 并且每个键值对的键和值要么就是小整数值, 要么就是长度比较短的字符串, 那么 Redis 就会使用压缩列表来做哈希键的底层实现.**

**压缩列表的构成**

压缩列表是 Redis 为了节约内存而开发的, 由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构. 一个压缩列表可以包含任意多个节点(entry), 每个节点可以保存一个字节数组或者一个整数值.

**压缩列表并不是对数据利用某种算法进行压缩, 而是将数据按照一定规则编码在一块连续的内存区域, 目的是节省内存.**

<img src="http://www.milky.show/images/redis/redis_9.png" alt="http://www.milky.show/images/redis/redis_9.png" style="zoom: 33%;" />

如上图所示, 压缩列表记录了各组成部分的类型、长度以及用途。

| 属性    | 类型     | 长度   | 用途                                                         |
| ------- | -------- | ------ | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4字节  | 记录整个压缩列表占用的内存字节数: 再对压缩列表进行内存重分配, 或者计算zlend的位置时使用 |
| zltail  | uint32_t | 4 字节 | 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节: 通过这个偏移量, 程序无需遍历整个压缩列表就可以确定表尾节点的地址 |
| zllen   | uint16_t | 2 字节 | 记录了压缩列表包含的节点数据: 当这个属性的值小于uint16_max(65535)时, 这个属性的值就是压缩列表包含节点的数量;当这个值等于uint16_max 时, 节点的真实数量需要遍历整个压缩列表才能计算得出 |
| entryX  | 列表节点 | 不定   | 压缩列表包含的各个节点, 节点的长度由节点保存的内容决定       |
| zlend   | uint8_t  | 1 字节 | 特殊值0xFF(十进制 255), 用于标记压缩列表的末端               |



一个压缩列表示例: 

- 列表 zlbytes 属性的值为 0x50 (十进制 80), 表示压缩列表的总长为 80 字节.
- 列表 zltail 属性的值为 0x3c (十进制 60), 这表示如果我们有一个指向压缩列表起始地址的指针 p , 那么只要用指针 p 加上偏移量 60 , 就可以计算出表尾节点 entry3 的地址.
- 列表 zllen 属性的值为 0x3 (十进制 3), 表示压缩列表包含三个节点.

<img src="http://www.milky.show/images/redis/redis_52.png" alt="http://www.milky.show/images/redis/redis_52.png" style="zoom:50%;" />

另一个压缩列表示例: 

- 列表 zlbytes 属性的值为 0xd2 (十进制 210), 表示压缩列表的总长为 210 字节.
- 列表 zltail 属性的值为 0xb3 (十进制 179), 这表示如果我们有一个指向压缩列表起始地址的指针 p , 那么只要用指针 p 加上偏移量 179 , 就可以计算出表尾节点 entry5 的地址.
- 列表 zllen 属性的值为 0x5 (十进制 5), 表示压缩列表包含五个节点.

<img src="http://www.milky.show/images/redis/redis_53.png" alt="http://www.milky.show/images/redis/redis_53.png" style="zoom: 50%;" />



**压缩列表的每个节点构成如下: **

<img src="http://www.milky.show/images/redis/redis_10.png" alt="http://www.milky.show/images/redis/redis_10.png" style="zoom:50%;" />

- previous_entry_ength: 记录压缩列表前一个字节的长度.previous_entry_ength的长度可能是1个字节或者是5个字节, 如果上一个节点的长度小于254, 则该节点只需要一个字节就可以表示前一个节点的长度了, 如果前一个节点的长度大于等于254, 则previous length的第一个字节为254, 后面用四个字节表示当前节点前一个节点的长度.利用此原理即当前节点位置减去上一个节点的长度即得到上一个节点的起始位置, 压缩列表可以从尾部向头部遍历.这么做很有效地减少了内存的浪费.
- encoding: 节点的encoding保存的是节点的content的内容类型以及长度, encoding类型一共有两种, 一种字节数组一种是整数, encoding区域长度为1字节, 2字节或者5字节长.
- content: content区域用于保存节点的内容, 节点内容类型和长度由encoding决定.

**连锁更新**

前面说过, 每个节点的 previous_entry_length 属性都记录了前一个节点的长度: 

如果前一节点的长度小于 254 字节, 那么 previous_entry_length 属性需要用 1 字节长的空间来保存这个长度值.
如果前一节点的长度大于等于 254 字节, 那么 previous_entry_length 属性需要用 5 字节长的空间来保存这个长度值.
现在, 考虑这样一种情况:  在一个压缩列表中, 有多个连续的, 长度介于 250 字节到 253 字节之间的节点 e1 至 eN 

<img src="http://www.milky.show/images/redis/redis_54.png" alt="http://www.milky.show/images/redis/redis_54.png" style="zoom:50%;" />

因为 e1 至 eN 的所有节点的长度都小于 254 字节, 所以记录这些节点的长度只需要 1 字节长的 previous_entry_length 属性, 换句话说, e1 至 eN 的所有节点的 previous_entry_length 属性都是 1 字节长的.

这时, 如果我们将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的表头节点, 那么 new 将成为 e1 的前置节点, 

<img src="http://www.milky.show/images/redis/redis_55.png" alt="http://www.milky.show/images/redis/redis_55.png" style="zoom: 50%;" />

因为 e1 的 previous_entry_length 属性仅长 1 字节, 它没办法保存新节点 new 的长度, 所以程序将对压缩列表执行空间重分配操作, 并将 e1 节点的 previous_entry_length 属性从原来的 1 字节长扩展为 5 字节长.

现在, 麻烦的事情来了 —— e1 原本的长度介于 250 字节至 253 字节之间, 在为 previous_entry_length 属性新增四个字节的空间之后, e1 的长度就变成了介于 254 字节至 257 字节之间, 而这种长度使用 1 字节长的 previous_entry_length 属性是没办法保存的.

因此, 为了让 e2 的 previous_entry_length 属性可以记录下 e1 的长度, 程序需要再次对压缩列表执行空间重分配操作, 并将 e2 节点的 previous_entry_length 属性从原来的 1 字节长扩展为 5 字节长.

正如扩展 e1 引发了对 e2 的扩展一样, 扩展 e2 也会引发对 e3 的扩展, 而扩展 e3 又会引发对 e4 的扩展……为了让每个节点的 previous_entry_length 属性都符合压缩列表对节点的要求, 程序需要不断地对压缩列表执行空间重分配操作, 直到 eN 为止.

Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”(cascade update)

<img src="http://www.milky.show/images/redis/redis_56.png" alt="http://www.milky.show/images/redis/redis_56.png" style="zoom: 33%;" />

**除了添加新节点可能会引发连锁更新之外, 删除节点也可能会引发连锁更新.**

考虑图 7-14 所示的压缩列表, 如果 e1 至 eN 都是大小介于 250 字节至 253 字节的节点, big 节点的长度大于等于 254 字节(需要 5 字节的 previous_entry_length 来保存), 而 small 节点的长度小于 254 字节(只需要 1 字节的 previous_entry_length 来保存), 那么当我们将 small 节点从压缩列表中删除之后, 为了让 e1 的 previous_entry_length 属性可以记录 big 节点的长度, 程序将扩展 e1 的空间, 并由此引发之后的连锁更新.

<img src="http://www.milky.show/images/redis/redis_57.png" alt="http://www.milky.show/images/redis/redis_57.png" style="zoom: 50%;" />

因为连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作, 而每次空间重分配的最坏复杂度为 O(N) , 所以连锁更新的最坏复杂度为 O(N^2) .

要注意的是, 尽管连锁更新的复杂度较高, 但它真正造成性能问题的几率是很低的: 

- 首先, 压缩列表里要恰好有多个连续的, 长度介于 250 字节至 253 字节之间的节点, 连锁更新才有可能被引发, 在实际中, 这种情况并不多见; 
- 其次, 即使出现连锁更新, 但只要被更新的节点数量不多, 就不会对性能造成任何影响:  比如说, 对三五个节点进行连锁更新是绝对不会影响性能的; 

因为以上原因, ziplistPush 等命令的平均复杂度仅为 O(N) , 在实际中, 我们可以放心地使用这些函数, 而不必担心连锁更新会影响压缩列表的性能.

**重点回顾**

- 压缩列表是一种为节约内存而开发的顺序型数据结构.
- 压缩列表被用作列表键和哈希键的底层实现之一.
- 压缩列表可以包含多个节点, 每个节点可以保存一个字节数组或者整数值.
- 添加新节点到压缩列表, 或者从压缩列表中删除节点, 可能会引发连锁更新操作, 但这种操作出现的几率并不高.









## 哈希对象(Map)

字典, 又称符号表(symbol table), 关联数组(associative array)或者映射(map), 是一种用于保存键值对(key-value pair)的抽象数据结构.

在字典中, 一个键(key)可以和一个值(value)进行关联(或者说将键映射为值), 这些关联的键和值就被称为键值对.

字典中的每个键都是独一无二的, 程序可以在字典中根据键查找与之关联的值, 或者通过键来更新值, 又或者根据键来删除整个键值对, 等等.

字典经常作为一种数据结构内置在很多高级编程语言里面, 但 Redis 所使用的 C 语言并没有内置这种数据结构, 因此 Redis 构建了自己的字典实现.

字典在 Redis 中的应用相当广泛, 比如 Redis 的数据库就是使用字典来作为底层实现的, 对数据库的增, 删, 查, 改操作也是构建在对字典的操作之上的.

举个例子, 当我们执行命令

```bash
redis> SET msg "hello world"
OK
```

在数据库中创建一个键为 "msg" , 值为 "hello world" 的键值对时, 这个键值对就是保存在代表数据库的字典里面的.

除了用来表示数据库之外, 字典还是哈希键的底层实现之一:  当一个哈希键包含的键值对比较多, 又或者键值对中的元素都是比较长的字符串时, Redis 就会使用字典作为哈希键的底层实现.



哈希对象的底层实现可以是ziplist或者hashtable.

**hash-ziplist**

ziplist 底层使用的是压缩列表实现, 上文已经详细介绍了压缩列表的实现原理。每当有新的键值对要加入哈希对象时, 先把保存了键的节点推入压缩列表表尾, 然后再将保存了值的节点推入压缩列表表尾。比如, 我们执行如下三条 HSET 命令:

```bash
HSET profile name "tom"
HSET profile age 25
HSET profile career "Programmer"
```

如果此时使用 ziplist 编码, 那么该 Hash 对象在内存中的结构如下:

<img src="http://www.milky.show/images/redis/redis_97.png" alt="http://www.milky.show/images/redis/redis_97.png" style="zoom:33%;" />

ziplist中的哈希对象是按照key1, value1, key2, value2这样的顺序存放来存储的.当对象数目不多且内容不大时, 这种方式效率是很高的.



**hash-hashtable**

hashtable 编码的哈希对象使用**字典**作为底层实现。字典是一种用于保存键值对的数据结构, Redis 的字典使用哈希表作为底层实现, 一个哈希表里面可以有多个哈希表节点, 每个哈希表节点保存的就是一个键值对。

hash 对象中的 hashtable

```bash
HSET profile name "tom"
HSET profile age 25
HSET profile career "Programmer"
```

还是上述三条命令, 保存数据到 Redis 的哈希对象中, 如果采用 hashtable 编码保存的话, 那么该 Hash 对象在内存中的结构如下:

<img src="http://www.milky.show/images/redis/redis_99.png" alt="http://www.milky.show/images/redis/redis_99.png" style="zoom:33%;" />

当哈希对象保存的所有键值对的键和值的字符串长度都小于 64 个字节, 并且数量小于 512 个时, 使用 ziplist 编码, 否则使用 hashtable 编码。

可以通过配置文件修改该上限值。



### 字典(ht)

Redis 字典由 dict 结构表示:

```c
typedef struct dict {
    // 类型特定函数
    dictType *type;

    // 私有数据
    void *privdata;

    // 哈希表
    dictht ht[2];

    // rehash 索引
    // 当 rehash 不在进行时,  值为 -1
    int rehashidx;
}
```

type 属性和 privdata 属性是针对不同类型的键值对, 为创建多态字典而设置的: 

**type** 属性是一个指向 dictType 结构的指针, 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数, Redis 会为用途不同的字典设置不同的类型特定函数.

**privdata** 属性则保存了需要传给那些类型特定函数的可选参数.

```c
typedef struct dictType {

    // 计算哈希值的函数
    unsigned int (*hashFunction)(const void *key);

    // 复制键的函数
    void *(*keyDup)(void *privdata,  const void *key);

    // 复制值的函数
    void *(*valDup)(void *privdata,  const void *obj);

    // 对比键的函数
    int (*keyCompare)(void *privdata,  const void *key1,  const void *key2);

    // 销毁键的函数
    void (*keyDestructor)(void *privdata,  void *key);

    // 销毁值的函数
    void (*valDestructor)(void *privdata,  void *obj);

} dictType;
```

ht 是大小为 2, 且每个元素都指向 dictht 哈希表。一般情况下, 字典只会使用 ht[0] 哈希表, ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。除了 ht[1] 之外, 另一个和 rehash 有关的属性就是 rehashidx :  它记录了 rehash 目前的进度, 如果目前没有在进行 rehash , 那么它的值为 -1 .



dicht[0] 是用于真正存放数据, dicht[1]一般在哈希表元素过多进行rehash的时候用于中转数据.
dictht中的table用语真正存放元素了, 每个key/value对用一个dictEntry表示, 放在dictEntry数组中.

<img src="http://www.milky.show/images/redis/redis_15.png" alt="http://www.milky.show/images/redis/redis_15.png" style="zoom:33%;" />



**一个普通状态下(没有进行 rehash)的字典: **

<img src="http://www.milky.show/images/redis/redis_23.png" alt="http://www.milky.show/images/redis/redis_23.png" style="zoom:33%;" />





**哈希算法: **

当要将一个新的键值对添加到字典里面时, 程序需要先根据键值对的键计算出哈希值和索引值, 然后再根据索引值, 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面.

Redis 计算哈希值和索引值的方法如下: 

```bash
# 使用字典设置的哈希函数, 计算键 key 的哈希值
hash = dict->type->hashFunction(key);

# 使用哈希表的 sizemask 属性和哈希值, 计算出索引值
# 根据情况不同, ht[x] 可以是 ht[0] 或者 ht[1]
index = hash & dict->ht[x].sizemask;
```

如果我们要将一个键值对 k0 和 v0 添加到字典里面, 那么程序会先使用语句: 

```bash
hash = dict->type->hashFunction(k0);
```

计算键 k0 的哈希值.

假设计算得出的哈希值为 8 , 那么程序会继续使用语句: 

```bash
index = hash & dict->ht[0].sizemask = 8 & 3 = 0;
```

计算出键 k0 的索引值 0 , 这表示包含键值对 k0 和 v0 的节点应该被放置到哈希表数组的索引 0 位置上



![http://www.milky.show/images/redis_24.png](http://www.milky.show/images/redis_24.png)

当字典被用作数据库的底层实现, 或者哈希键的底层实现时, Redis 使用 MurmurHash2 算法来计算键的哈希值.

MurmurHash 算法最初由 Austin Appleby 于 2008 年发明, 这种算法的优点在于, 即使输入的键是有规律的, 算法仍能给出一个很好的随机分布性, 并且算法的计算速度也非常快.



**解决哈希冲突: **

当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时, 我们称这些键发生了冲突(collision).

Redis 的哈希表使用链地址法(separate chaining)来解决键冲突:  每个哈希表节点都有一个 next 指针, 多个哈希表节点可以用 next 指针构成一个单向链表, 被分配到同一个索引上的多个节点可以用这个单向链表连接起来, 这就解决了键冲突的问题.

举个例子, 假设程序要将键值对 k2 和 v2 添加到图 4-6 所示的哈希表里面, 并且计算得出 k2 的索引值为 2 , 那么键 k1 和 k2 将产生冲突, 而解决冲突的办法就是使用 next 指针将键 k2 和 k1 所在的节点连接起来

<img src="http://www.milky.show/images/redis/redis_25.png" alt="http://www.milky.show/images/redis/redis_25.png" style="zoom:33%;" />

因为 dictEntry 节点组成的链表没有指向链表表尾的指针, 所以为了速度考虑, 程序总是将新节点添加到链表的表头位置(复杂度为 O(1) ), 排在其他已有节点的前面.



**rehash:**

为了使 hash 表的负载因子 (ht[0]).used/ht[0]).size) 维持在一个合理范围, 当哈希表保存的元素过多或者过少时, 程序需要对 hash 表进行相应的扩展和收缩。

随着操作的不断执行, 哈希表保存的键值对会逐渐地增多或者减少, 为了让哈希表的负载因子(load factor)维持在一个合理的范围之内, 当哈希表保存的键值对数量太多或者太少时, 程序需要对哈希表的大小进行相应的扩展或者收缩.

扩展和收缩哈希表的工作可以通过执行 rehash (重新散列)操作来完成, Redis 对字典的哈希表执行 rehash 的步骤如下: 

1. 为字典的 ht[1] 哈希表分配空间, 这个哈希表的空间大小取决于要执行的操作, 以及 ht[0] 当前包含的键值对数量 (也即是 ht[0].used 属性的值):  
    - 如果执行的是**扩展操作**, 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n (2 的 n 次方幂); 
    - 如果执行的是**收缩操作**, 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n .
2. 将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面:  rehash 指的是重新计算键的哈希值和索引值, 然后将键值对放置到 ht[1] 哈希表的指定位置上.
3. 当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 (ht[0] 变为空表), 释放 ht[0] , 将 ht[1] 设置为 ht[0] , 并在 ht[1] 新创建一个空白哈希表, 为下一次 rehash 做准备.

举个例子, 假设程序要对图 4-8 所示字典的 ht[0] 进行扩展操作, 那么程序将执行以下步骤: 

1. ht[0].used 当前的值为 4 , 4 * 2 = 8 , 而 8 (2^3)恰好是第一个大于等于 4 的 2 的 n 次方, 所以程序会将 ht[1] 哈希表的大小设置为 8 . 图 4-9 展示了 ht[1] 在分配空间之后, 字典的样子.
2. 将 ht[0] 包含的四个键值对都 rehash 到 ht[1] , 如图 4-10 所示.
3. 释放 ht[0] , 并将 ht[1] 设置为 ht[0] , 然后为 ht[1] 分配一个空白哈希表, 如图 4-11 所示.

至此, 对哈希表的扩展操作执行完毕, 程序成功将哈希表的大小从原来的 4 改为了现在的 8 .

1. 执行 rehash 之前的字典

    <img src="http://www.milky.show/images/redis/redis_32.png" alt="http://www.milky.show/images/redis/redis_32.png" style="zoom:33%;" />

2. 为字典的 ht[1] 哈希表分配空间

    <img src="http://www.milky.show/images/redis/redis_33.png" alt="http://www.milky.show/images/redis/redis_33.png" style="zoom:33%;" />

3. ht[0] 的所有键值对都已经被迁移到 ht[1]

    <img src="http://www.milky.show/images/redis/redis_34.png" alt="http://www.milky.show/images/redis/redis_34.png" style="zoom:33%;" />

4. 完成 rehash 之后的字典

    <img src="http://www.milky.show/images/redis/redis_35.png" alt="http://www.milky.show/images/redis/redis_35.png" style="zoom:33%;" />









**扩容和收缩: **

当哈希表保存的键值对太多或者太少时, 就要通过 rerehash(重新散列)来对哈希表进行相应的扩展或者收缩.具体步骤: 

1. 如果执行扩展操作, 会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表(也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表).相反如果执行的是收缩操作, 每次收缩是根据已使用空间缩小一倍创建一个新的哈希表.
2. 重新利用上面的哈希算法, 计算索引值, 然后将键值对放到新的哈希表位置上.
3. 所有键值对都迁徙完毕后, 释放原哈希表的内存空间.



**哈希表的扩展和收缩时机**

- 当服务器没有执行 BGSAVE 或者 BGREWRITEAOF 命令时, 负载因子大于等于 1 触发哈希表的扩展操作；

- 当服务器在执行 BGSAVE 或者 BGREWRITEAOF 命令, 负载因子大于等于 5 触发哈希表的扩展操作；

- 当哈希表负载因子小于 0.1, 触发哈希表的收缩操作。

- 负载因子 = 哈希表已保存节点数量 / 哈希表大小.

    ```bash
    # 负载因子 = 哈希表已保存节点数量 / 哈希表大小
    load_factor = ht[0].used / ht[0].size
    ```

    比如说, 对于一个大小为 `4` , 包含 `4` 个键值对的哈希表来说, 这个哈希表的负载因子为: 

    ```bash
    load_factor = 4 / 4 = 1
    ```

    又比如说, 对于一个大小为 `512` , 包含 `256` 个键值对的哈希表来说, 这个哈希表的负载因子为: 

    ```bash
    load_factor = 256 / 512 = 0.5
    ```

    根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行, 服务器执行扩展操作所需的负载因子并不相同, 这是因为在执行 BGSAVE命令或 BGREWRITEAOF 命令的过程中, Redis 需要创建当前服务器进程的子进程, 而大多数操作系统都采用写时复制([copy-on-write](http://en.wikipedia.org/wiki/Copy-on-write))技术来优化子进程的使用效率, 所以在子进程存在期间, 服务器会提高执行扩展操作所需的负载因子, 从而尽可能地避免在子进程存在期间进行哈希表扩展操作, 这可以避免不必要的内存写入操作, 最大限度地节约内存.

    另一方面, 当哈希表的负载因子小于 `0.1` 时, 程序自动开始对哈希表执行收缩操作.









**渐进式 rehash**

前面讲过, 扩展或者收缩需要将 ht[0] 里面的元素全部 rehash 到 ht[1] 中, 如果 ht[0] 元素很多, 显然一次性 rehash 成本会很大, 从影响到 Redis 性能。

为了解决上述问题, Redis 使用了渐进式 rehash 技术, 具体来说就是分多次, 渐进式地将 ht[0] 里面的元素慢慢地 rehash 到 ht[1] 中。

下面是渐进式 rehash 的详细步骤:

1. 为 ht[1] 分配空间；
2. 在字典中维持一个索引计数器变量 rehashidx, 并将它的值设置为 0, 表示 rehash 正式开始；
3. 在 rehash 进行期间, 每次对字典执行添加、删除、查找或者更新时, 除了会执行相应的操作之外, 还会顺带将 ht[0] 在 rehashidx 索引位上的所有键值对 rehash 到 ht[1] 中, rehash 完成之后, rehashidx 值加 1；
4. 随着字典操作的不断进行, 最终会在啊某个时刻迁移完成, 此时将 rehashidx 值置为 -1, 表示 rehash 结束。

**渐进式 rehash 一次迁移一个桶上所有的数据**。设计上采用**分而治之**的思想, **将原本集中式的操作分散到每个添加、删除、查找和更新操作上**, 从而避免集中式 rehash 带来的庞大计算。

因为在渐进式 rehash 时, 字典会同时使用 ht[0] 和 ht[1] 两张表, 所以此时对字典的删除、查找和更新操作都可能会在两个哈希表进行。比如, 如果要查找某个键时, 先在 ht[0] 中查找, 如果没找到, 则继续到 ht[1] 中查找。



**渐近式 rehash**

扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面, 如果 ht[0] 元素很多, 显然一次性 rehash 成本会很大, 从影响到 Redis 性能。为了解决上述问题, Redis 使用了渐进式 rehash 技术, 具体来说就是分多次, 渐进式地将 ht[0] 里面的元素慢慢地 rehash 到 ht[1] 中。

这样做的原因在于, 如果 ht[0] 里只保存着四个键值对, 那么服务器可以在瞬间就将这些键值对全部 rehash 到 ht[1] ;  但是, 如果哈希表里保存的键值对数量不是四个, 而是四百万, 四千万甚至四亿个键值对, 那么要一次性将这些键值对全部 rehash 到 ht[1] 的话, 庞大的计算量可能会导致服务器在一段时间内停止服务.

因此, 为了避免 rehash 对服务器性能造成影响, 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] , 而是分多次, 渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] .

以下是哈希表渐进式 rehash 的详细步骤: 

1. 为 ht[1] 分配空间, 让字典同时持有 ht[0] 和 ht[1] 两个哈希表.
2. 在字典中维持一个索引计数器变量 rehashidx , 并将它的值设置为 0 , 表示 rehash 工作正式开始.
3. 在 rehash 进行期间, 每次对字典执行添加, 删除, 查找或者更新操作时, 程序除了执行指定的操作以外, 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] , 当 rehash 工作完成之后, 程序将 rehashidx 属性的值增一.
4. 随着字典操作的不断执行, 最终在某个时间点上, ht[0] 的所有键值对都会被 rehash 至 ht[1] , 这时程序将 rehashidx 属性的值设为 -1 , 表示 rehash 操作已完成.

渐进式 rehash 的好处在于它采取分而治之的方式, 将 rehash 键值对所需的计算工作均滩到对字典的每个添加, 删除, 查找和更新操作上, 从而避免了集中式 rehash 而带来的庞大计算量.

**渐进式 rehash 一次迁移一个桶上所有的数据**。设计上采用**分而治之**的思想, **将原本集中式的操作分散到每个添加、删除、查找和更新操作上**, 从而避免集中式 rehash 带来的庞大计算。

一次完整的渐进式 rehash 过程, 注意观察在整个 rehash 过程中, 字典的 rehashidx 属性是如何变化的

1. 准备开始rehash

    <img src="http://www.milky.show/images/redis/redis_26.png" alt="http://www.milky.show/images/redis/redis_26.png" style="zoom:33%;" />

2. rehash 索引 0 上的键值对

    <img src="http://www.milky.show/images/redis/redis_27.png" alt="http://www.milky.show/images/redis/redis_27.png" style="zoom:33%;" />

3. rehash 索引 1 上的键值对

    <img src="http://www.milky.show/images/redis/redis_28.png" alt="http://www.milky.show/images/redis/redis_28.png" style="zoom:33%;" />

4. rehash 索引 2 上的键值对

    <img src="http://www.milky.show/images/redis/redis_29.png" alt="http://www.milky.show/images/redis/redis_29.png" style="zoom:33%;" />

5. rehash 索引 3 上的键值对

    <img src="http://www.milky.show/images/redis/redis_30.png" alt="http://www.milky.show/images/redis/redis_30.png" style="zoom:33%;" />

6. rehash 完毕

    <img src="http://www.milky.show/images/redis/redis_31.png" alt="http://www.milky.show/images/redis/redis_31.png" style="zoom: 33%;" />

**因为在进行渐进式 rehash 的过程中, 字典会同时使用 ht[0] 和 ht[1] 两个哈希表, 所以在渐进式 rehash 进行期间, 字典的删除(delete), 查找(find), 更新(update)等操作会在两个哈希表上进行:  比如说, 要在字典里面查找一个键的话, 程序会先在 ht[0] 里面进行查找, 如果没找到的话, 就会继续到 ht[1] 里面进行查找, 诸如此类.**

**另外, 在渐进式 rehash 执行期间, 新添加到字典的键值对一律会被保存到 ht[1] 里面, 而 ht[0] 则不再进行任何添加操作:  这一措施保证了 ht[0] 包含的键值对数量会只减不增, 并随着 rehash 操作的执行而最终变成空表.**

**重点回顾**

- 字典被广泛用于实现 Redis 的各种功能, 其中包括数据库和哈希键.
- Redis 中的字典使用哈希表作为底层实现, 每个字典带有两个哈希表, 一个用于平时使用, 另一个仅在进行 rehash 时使用.
- 当字典被用作数据库的底层实现, 或者哈希键的底层实现时, Redis 使用 MurmurHash2 算法来计算键的哈希值.
- 哈希表使用链地址法来解决键冲突, 被分配到同一个索引上的多个键值对会连接成一个单向链表.
- 在对哈希表进行扩展或者收缩操作时, 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面, 并且这个 rehash 过程并不是一次性地完成的, 而是渐进式地完成的.





### 哈希表(hashtable)

Redis 使用的哈希表由 dictht 结构定义:

```c
typedef struct dictht{
    // 哈希表数组
    dictEntry **table;

    // 哈希表大小
    unsigned long size;

    // 哈希表大小掩码, 用于计算索引值
    // 总是等于 size-1
    unsigned long sizemask;

    // 该哈希表已有节点数量
    unsigned long used;
} dictht
```

**table** 属性是一个数组, 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针, 每个 dictEntry 结构保存着一个键值对.

**size** 属性记录了哈希表的大小, 也即是 table 数组的大小, 而 used 属性则记录了哈希表目前已有节点(键值对)的数量.

**sizemask** 属性的值总是等于 size - 1 , 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面.

比如下图展示了一个大小为 4 的空哈希表。

<img src="http://www.milky.show/images/redis/redis_98.png" alt="http://www.milky.show/images/redis/redis_98.png" style="zoom:33%;" />



#### 哈希表节点

**哈希表是由数组 table 组成, table 中每个元素都是指向 dict.h/dictEntry 结构, dictEntry 结构定义如下**

哈希表节点使用 dictEntry 结构表示, 每个 dictEntry 结构都保存着一个键值对:

```c
typedef struct dictEntry {
    // 键
    void *key;

    // 值
    union {
        void *val;
        unit64_t u64;
        nit64_t s64;
    } v;

    // 指向下一个哈希表节点, 形成链表
    struct dictEntry *next;
} dictEntry;
```

**key** 属性保存着键值对中的键

**v** 属性则保存着键值对中的值, 其中键值对的值可以是一个指针, 或者是一个 uint64_t 整数, 又或者是一个 int64_t 整数.

**next** 属性是指向另一个哈希表节点的指针, 这个指针可以将多个哈希值相同的键值对连接在一次, 以此来解决键冲突(collision)的问题.

举个例子, 图 4-2 就展示了如何通过 next 指针, 将两个索引值相同的键 k1 和 k0 连接在一起.

注意这里还有一个指向下一个哈希表节点的指针, 我们知道哈希表最大的问题是存在哈希冲突, 如何解决哈希冲突, 有开放地址法和链地址法.**这里采用的便是链地址法**, 通过next这个指针可以将多个哈希值相同的键值对连接在一起, 用来解决**哈希冲突**.

<img src="http://www.milky.show/images/redis/redis_6.png" alt="http://www.milky.show/images/redis/redis_6.png" style="zoom: 33%;" />





## 集合对象(Set)

集合对象的编码可以是 intset 或者 hashtable。当集合对象保存的元素都是整数, 并且个数不超过 512 个时, 使用 intset 编码, 否则使用 hashtable 编码。

**4.1 set-intset**

intset 编码的集合对象底层使用整数集合实现。

整数集合(intset)是 Redis 用于保存整数值的集合抽象数据结构, 它可以保存类型为 int16_t、int32_t 或者 int64_t 的整数值, 并且保证集合中的数据不会重复。Redis 使用 intset 结构表示一个整数集合。

```c
typedef struct intset {
    // 编码方式
    uint32_t encoding;
    // 集合包含的元素数量
    uint32_t length;
    // 保存元素的数组
    int8_t contents[];
} intset;
```

contents 数组是整数集合的底层实现:整数集合的每个元素都是 contents 数组的一个数组项, 各个项在数组中按值大小从小到大有序排列, 并且数组中不包含重复项。

虽然 contents 属性声明为 int8_t 类型的数组, 但实际上, contents 数组不保存任何 int8_t 类型的值, 数组中真正保存的值类型取决于 encoding。

如果 encoding 属性值为 INTSET_ENC_INT16, 那么 contents 数组就是 int16_t 类型的数组, 以此类推。

当新插入元素的类型比整数集合现有类型元素的类型大时, 整数集合必须先升级, 然后才能将新元素添加进来。这个过程分以下三步进行:

1. 根据新元素类型, 扩展整数集合底层数组空间大小；
2. 将底层数组现有所有元素都转换为与新元素相同的类型, 并且维持底层数组的有序性；
3. 将新元素添加到底层数组里面。

还有一点需要注意的是, **整数集合不支持降级**。一旦对数组进行了升级, 编码就会一直保持升级后的状态。

举个例子, 当执行 SADD numbers 1 3 5 向集合对象插入数据时, 该集合对象在内存的结构如下:

<img src="http://www.milky.show/images/redis/redis_100.png" alt="http://www.milky.show/images/redis/redis_100.png" style="zoom: 33%;" />



**4.2 set-hashtable**

hashtable 编码的集合对象使用字典作为底层实现。字典的每个键都是一个字符串对象, 每个字符串对象对应一个集合元素, 字典的值都是 NULL。

当我们执行 SADD fruits "apple" "banana" "cherry" 向集合对象插入数据时, 该集合对象在内存的结构如下:

<img src="http://www.milky.show/images/redis/redis_101.png" alt="http://www.milky.show/images/redis/redis_101.png" style="zoom: 33%;" />



### 整数集合(intset)

整数集合(intset)是集合键的底层实现之一:  它可以保存类型为int16_t, int32_t 或者int64_t 的整数值, 并且保证集合中不会出现重复元素.当一个集合只包含整数值元素, 并且这个集合的元素数量不多时, Redis 就会使用整数集合作为集合键的底层实现.

举个例子, 如果我们创建一个只包含五个元素的集合键, 并且集合中的所有元素都是整数值, 那么这个集合键的底层实现就会是整数集合: 

```bash
redis> SADD numbers 1 3 5 7 9
(integer) 5

redis> OBJECT ENCODING numbers
"intset"
```

**每个 intset.h/intset 结构表示一个整数集合: 整数集合定义如下:**

```c
typedef struct intset {

    // 编码方式
    uint32_t encoding;

    // 集合包含的元素数量
    uint32_t length;

    // 保存元素的数组
    int8_t contents[];

} intset;
```

contents 数组是整数集合的底层实现:  整数集合的每个元素都是 contents 数组的一个数组项(item), 各个项在数组中按值的大小从小到大有序地排列, 并且数组中不包含任何重复项.

length 属性记录了整数集合包含的元素数量, 也即是 contents 数组的长度.

虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组, 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值: 

- 如果 encoding 属性的值为 INTSET_ENC_INT16 , 那么 contents 就是一个 int16_t 类型的数组, 数组里的每个项都是一个 int16_t 类型的整数值 (最小值为 -32, 768 , 最大值为 32, 767 ).
- 如果 encoding 属性的值为 INTSET_ENC_INT32 , 那么 contents 就是一个 int32_t 类型的数组, 数组里的每个项都是一个 int32_t 类型的整数值 (最小值为 -2, 147, 483, 648 , 最大值为 2, 147, 483, 647 ).
- 如果 encoding 属性的值为 INTSET_ENC_INT64 , 那么 contents 就是一个 int64_t 类型的数组, 数组里的每个项都是一个 int64_t 类型的整数值 (最小值为 -9, 223, 372, 036, 854, 775, 808 , 最大值为 9, 223, 372, 036, 854, 775, 807 ).

展示了一个整数集合示例: 

- encoding 属性的值为 INTSET_ENC_INT16 , 表示整数集合的底层实现为 int16_t 类型的数组, 而集合保存的都是 int16_t 类型的整数值.
- length 属性的值为 5 , 表示整数集合包含五个元素.
- contents 数组按从小到大的顺序保存着集合中的五个元素.
- 因为每个集合元素都是 int16_t 类型的整数值, 所以 contents 数组的大小等于 sizeof(int16_t) * 5 = 16 * 5 = 80 位.

<img src="http://www.milky.show/images/redis/redis_42.png" alt="http://www.milky.show/images/redis/redis_42.png" style="zoom:50%;" />	

展示了另一个整数集合示例: 

- encoding 属性的值为 INTSET_ENC_INT64 , 表示整数集合的底层实现为 int64_t 类型的数组, 而数组中保存的都是 int64_t 类型的整数值.
- length 属性的值为 4 , 表示整数集合包含四个元素.
- contents 数组按从小到大的顺序保存着集合中的四个元素.
- 因为每个集合元素都是 int64_t 类型的整数值, 所以 contents 数组的大小为 sizeof(int64_t) * 4 = 64 * 4 = 256 位.

<img src="http://www.milky.show/images/redis/redis_43.png" alt="http://www.milky.show/images/redis/redis_43.png" style="zoom: 50%;" />	

虽然 contents 数组保存的四个整数值中, 只有 -2675256175807981027 是真正需要用 int64_t 类型来保存的, 而其他的 1 ,  3 ,  5 三个值都可以用 int16_t 类型来保存, 不过根据整数集合的升级规则, 当向一个底层为 int16_t 数组的整数集合添加一个 int64_t 类型的整数值时, 整数集合已有的所有元素都会被转换成 int64_t 类型, 所以 contents 数组保存的四个整数值都是 int64_t 类型的, 不仅仅是 -2675256175807981027 .



**升级**

当我们新增的元素类型比原集合元素类型的长度要大时, 需要对整数集合进行升级, 才能将新元素放入整数集合中.

1. 根据新元素类型, 扩展整数集合底层数组的大小, 并为新元素分配空间.
2. 将底层数组现有的所有元素都转成与新元素相同类型的元素, 并将转换后的元素放到正确的位置, 放置过程中, 维持整个元素顺序都是有序的.
3. 将新元素添加到整数集合中(保证有序).

　　升级能极大地节省内存.

举个例子, 假设现在有一个 INTSET_ENC_INT16 编码的整数集合, 集合中包含三个 int16_t 类型的元素

<img src="http://www.milky.show/images/redis/redis_44.png" alt="http://www.milky.show/images/redis/redis_44.png" style="zoom: 33%;" />	

因为每个元素都占用 16 位空间, 所以整数集合底层数组的大小为 3 * 16 = 48 位, 图 6-4 展示了整数集合的三个元素在这 48 位里的位置.

<img src="http://www.milky.show/images/redis/redis_45.png" alt="http://www.milky.show/images/redis/redis_45.png" style="zoom: 33%;" />	

现在, 假设我们要将类型为 int32_t 的整数值 65535 添加到整数集合里面, 因为 65535 的类型 int32_t 比整数集合当前所有元素的类型都要长, 所以在将 65535 添加到整数集合之前, 程序需要先对整数集合进行升级. 

升级首先要做的是, 根据新类型的长度, 以及集合元素的数量(包括要添加的新元素在内), 对底层数组进行空间重分配.

整数集合目前有三个元素, 再加上新元素 65535 , 整数集合需要分配四个元素的空间, 因为每个 int32_t 整数值需要占用 32 位空间, 所以在空间重分配之后, 底层数组的大小将是 32 * 4 = 128 位, 如图 6-5 所示.

<img src="http://www.milky.show/images/redis/redis_46.png" alt="http://www.milky.show/images/redis/redis_46.png" style="zoom: 33%;" />

虽然程序对底层数组进行了空间重分配, 但数组原有的三个元素 1 ,  2 ,  3 仍然是 int16_t 类型, 这些元素还保存在数组的前 48 位里面, 所以程序接下来要做的就是将这三个元素转换成 int32_t 类型, 并将转换后的元素放置到正确的位上面, 而且在放置元素的过程中, 需要维持底层数组的有序性质不变.

首先, 因为元素 3 在 1 ,  2 ,  3 ,  65535 四个元素中排名第三, 所以它将被移动到 contents 数组的索引 2 位置上, 也即是数组 64 位至 95 位的空间内, 如图 6-6 所示.

<img src="http://www.milky.show/images/redis/redis_47.png" alt="http://www.milky.show/images/redis/redis_47.png" style="zoom: 50%;" />

接着, 因为元素 2 在 1 ,  2 ,  3 ,  65535 四个元素中排名第二, 所以它将被移动到 contents 数组的索引 1 位置上, 也即是数组的 32 位至 63 位的空间内, 如图 6-7 所示.

<img src="http://www.milky.show/images/redis/redis_48.png" alt="http://www.milky.show/images/redis/redis_48.png" style="zoom: 33%;" />

之后, 因为元素 1 在 1 ,  2 ,  3 ,  65535 四个元素中排名第一, 所以它将被移动到 contents 数组的索引 0 位置上, 也即是数组的 0 位至 31 位的空间内, 如图 6-8 所示.

<img src="http://www.milky.show/images/redis/redis_49.png" alt="http://www.milky.show/images/redis/redis_49.png" style="zoom: 33%;" />

然后, 因为元素 65535 在 1 ,  2 ,  3 ,  65535 四个元素中排名第四, 所以它将被添加到 contents 数组的索引 3 位置上, 也即是数组的 96 位至 127 位的空间内, 如图 6-9 所示.

<img src="http://www.milky.show/images/redis/redis_50.png" alt="http://www.milky.show/images/redis/redis_50.png" style="zoom: 33%;" />

最后, 程序将整数集合 encoding 属性的值从 INTSET_ENC_INT16 改为 INTSET_ENC_INT32 , 并将 length 属性的值从 3 改为 4 , 设置完成之后的整数集合如图 6-10 所示.

<img src="http://www.milky.show/images/redis/redis_51.png" alt="http://www.milky.show/images/redis/redis_51.png" style="zoom: 50%;" />

因为每次向整数集合添加新元素都可能会引起升级, 而每次升级都需要对底层数组中已有的所有元素进行类型转换, 所以向整数集合添加新元素的时间复杂度为 O(N) . 

其他类型的升级操作, 比如从 INTSET_ENC_INT16 编码升级为 INTSET_ENC_INT64 编码, 或者从 INTSET_ENC_INT32 编码升级为 INTSET_ENC_INT64 编码, 升级的过程都和上面展示的升级过程类似.

**升级之后新元素的摆放位置**
 因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大, 所以这个新元素的值要么就大于所有现有元素, 要么就小于所有现有元素

- 在新元素小于所有现有元素的情况下, 新元素会被放置在底层数组的最开头(索引 0 ); 
- 在新元素大于所有现有元素的情况下, 新元素会被放置在底层数组的最末尾(索引 length-1 ).

**升级的好处:**

- ##### 提升灵活性

    因为 C 语言是静态类型语言, 为了避免类型错误, 我们通常不会将两种不同类型的值放在同一个数据结构里面.

    比如说, 我们一般只使用 int16_t 类型的数组来保存 int16_t 类型的值, 只使用 int32_t 类型的数组来保存 int32_t 类型的值, 诸如此类.

    但是, 因为整数集合可以通过自动升级底层数组来适应新元素, 所以我们可以随意地将 int16_t ,  int32_t 或者 int64_t 类型的整数添加到集合中, 而不必担心出现类型错误, 这种做法非常灵活.

- ##### 节约内存

    当然, 要让一个数组可以同时保存 int16_t ,  int32_t ,  int64_t 三种类型的值, 最简单的做法就是直接使用 int64_t 类型的数组作为整数集合的底层实现. 不过这样一来, 即使添加到整数集合里面的都是 int16_t 类型或者 int32_t 类型的值, 数组都需要使用 int64_t 类型的空间去保存它们, 从而出现浪费内存的情况.

    而整数集合现在的做法既可以让集合能同时保存三种不同类型的值, 又可以确保升级操作只会在有需要的时候进行, 这可以尽量节省内存.

    比如说, 如果我们一直只向整数集合添加 int16_t 类型的值, 那么整数集合的底层实现就会一直是 int16_t 类型的数组, 只有在我们要将 int32_t 类型或者 int64_t 类型的值添加到集合时, 程序才会对数组进行升级.



**降级**

整数集合不支持降级操作, 一旦对数组进行了升级, 编码就会一直保持升级后的状态.

举个例子, 对于图 6-11 所示的整数集合来说, 即使我们将集合里唯一一个真正需要使用 int64_t 类型来保存的元素 4294967295 删除了, 整数集合的编码仍然会维持 INTSET_ENC_INT64 , 底层数组也仍然会是 int64_t 类型的, 



**重点回顾**

- 整数集合是集合键的底层实现之一.
- 整数集合的底层实现为数组, 这个数组以有序, 无重复的方式保存集合元素, 在有需要时, 程序会根据新添加元素的类型, 改变这个数组的类型.
- 升级操作为整数集合带来了操作上的灵活性, 并且尽可能地节约了内存.
- 整数集合只支持升级操作, 不支持降级操作.









## 有序集合对象(ZSet)



有序集合的编码可以是 ziplist 或者 skiplist。当有序集合保存的元素个数小于 128 个, 且所有元素成员长度都小于 64 字节时, 使用 ziplist 编码, 否则使用 skiplist 编码。

**zset-ziplist**

ziplist 编码的有序集合使用压缩列表作为底层实现。每个集合元素使用两个紧挨着一起的两个压缩列表节点表示, 第一个节点保存元素的成员(member), 第二个节点保存元素的分值(score)。

压缩列表内的集合元素按照分值从小到大排列。如果我们执行 ZADD price 8.5 apple 5.0 banana 6.0 cherry 命令向有序集合插入元素, 该有序集合在内存中的结构如下:

<img src="http://www.milky.show/images/redis/redis_102.png" alt="http://www.milky.show/images/redis/redis_102.png" style="zoom: 50%;" />

**zset-skiplist**

skiplist 编码的有序集合对象使用 zset 结构作为底层实现, 一个 zset 结构同时包含一个字典和一个跳跃表。

```c
typedef struct zset {
    zskiplist *zs1;
    dict *dict;
}
```

继续介绍之前, 我们先了解一下什么是跳跃表。



### 跳跃表(skiplist)

跳跃表(skiplist)是一种有序的数据结构, 它通过在每个节点中维持多个指向其他节点的指针, 从而达到快速访问节点的目的。

Redis 的跳跃表由 zskiplistNode 和 zskiplist 两个结构定义。zskiplistNode 结构表示跳跃表节点, zskiplist 保存跳跃表节点相关信息, 比如节点的数量, 以及指向表头和表尾节点的指针等。

跳跃表支持平均 O(log N) 最坏 O(N) 复杂度的节点查找, 还可以通过顺序性操作来批量处理节点.

**在大部分情况下, 跳跃表的效率可以和平衡树相媲美, 并且因为跳跃表的实现比平衡树要来得更为简单, 所以有不少程序都使用跳跃表来代替平衡树.**

Redis 使用跳跃表作为有序集合键的底层实现之一:  如果一个有序集合包含的元素数量比较多, 又或者有序集合中元素的成员(member)是比较长的字符串时, Redis 就会使用跳跃表来作为有序集合键的底层实现.

具有如下性质: 

1. 由很多层结构组成; 
2. 每一层都是一个有序的链表, 排列顺序为由高层到底层, 都至少包含两个链表节点, 分别是前面的head节点和后面的nil节点; 
3. 最底层的链表包含了所有的元素; 
4. 如果一个元素出现在某一层的链表中, 那么在该层之下的链表也全都会出现(上一层的元素是当前层的元素的子集); 
5. 链表中的每个节点都包含两个指针, 一个指向同一层的下一个链表节点, 另一个指向下一层的同一个链表节点; 

举个例子, fruit-price 是一个有序集合键, 这个有序集合以水果名为成员, 水果价钱为分值, 保存了 130 款水果的价钱: 

```bash
redis> ZRANGE fruit-price 0 2 WITHSCORES
1) "banana"
2) "5"
3) "cherry"
4) "6.5"
5) "apple"
6) "8"

redis> ZCARD fruit-price
(integer) 130
```

`fruit-price` 有序集合的所有数据都保存在一个跳跃表里面, 其中每个跳跃表节点(node)都保存了一款水果的价钱信息, 所有水果按价钱的高低从低到高在跳跃表里面排序: 

- 跳跃表的第一个元素的成员为 `"banana"` , 它的分值为 `5` ; 
- 跳跃表的第二个元素的成员为 `"cherry"` , 它的分值为 `6.5` ; 
- 跳跃表的第三个元素的成员为 `"apple"` , 它的分值为 `8` ; 

和链表, 字典等数据结构被广泛地应用在 Redis 内部不同, Redis 只在两个地方用到了跳跃表, 一个是实现有序集合键, 另一个是在集群节点中用作内部数据结构, 除此之外, 跳跃表在 Redis 里面没有其他用途.



Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义, 其中 zskiplistNode 结构用于表示跳跃表节点, 而 zskiplist 结构则用于保存跳跃表节点的相关信息, 比如节点的数量, 以及指向表头节点和表尾节点的指针, 等等.

<img src="http://www.milky.show/images/redis/redis_8.png" alt="http://www.milky.show/images/redis/redis_8.png" style="zoom: 33%;" />

位于图片最左边的是 zskiplist 结构, 该结构包含以下属性: 

- header : 指向跳跃表的表头节点.
- tail : 指向跳跃表的表尾节点.
- level : 记录目前跳跃表内, 层数最大的那个节点的层数(表头节点的层数不计算在内).
- length : 记录跳跃表的长度, 也即是, 跳跃表目前包含节点的数量(表头节点不计算在内).

位于 zskiplist 结构右方的是四个 zskiplistNode 结构, 该结构包含以下属性: 

- 层(level): 节点中用 L1 ,  L2 ,  L3 等字样标记节点的各个层, L1 代表第一层, L2 代表第二层, 以此类推.每个层都带有两个属性: 前进指针和跨度.前进指针用于访问位于表尾方向的其他节点, 而跨度则记录了前进指针所指向节点和当前节点的距离.在上面的图片中, 连线上带有数字的箭头就代表前进指针, 而那个数字就是跨度.当程序从表头向表尾进行遍历时, 访问会沿着层的前进指针进行.
- 后退(backward)指针: 节点中用 BW 字样标记节点的后退指针, 它指向位于当前节点的前一个节点.后退指针在程序从表尾向表头遍历时使用.
- 分值(score): 各个节点中的 1.0 ,  2.0 和 3.0 是节点所保存的分值.在跳跃表中, 节点按各自所保存的分值从小到大排列.
- 成员对象(obj): 各个节点中的 o1 ,  o2 和 o3 是节点所保存的成员对象.

注意表头节点和其他节点的构造是一样的:  表头节点也有后退指针, 分值和成员对象, 不过表头节点的这些属性都不会被用到, 所以图中省略了这些部分, 只显示了表头节点的各个层.



**跳跃表节点: 跳跃表节点的实现由 redis.h/zskiplistNode 结构定义**

```c
typedef struct zskiplistNode {

    // 后退指针
    struct zskiplistNode *backward;

    // 分值
    double score;

    // 成员对象
    robj *obj;

    // 层
    struct zskiplistLevel {

        // 前进指针
        struct zskiplistNode *forward;

        // 跨度
        unsigned int span;

    } level[];

} zskiplistNode;
```

下图是一个层高为 5, 包含 4 个跳跃表节点(1 个表头节点和 3 个数据节点)组成的跳跃表:

<img src="http://www.milky.show/images/redis/redis_103.png" alt="http://www.milky.show/images/redis/redis_103.png" style="zoom: 50%;" />

**层**

跳跃表节点的 `level` 数组可以包含多个元素, 每个元素都包含一个指向其他节点的指针, 程序可以通过这些层来加快访问其他节点的速度, 一般来说, 层的数量越多, 访问其他节点的速度就越快.

每次创建一个新跳跃表节点的时候, 程序都根据幂次定律 ([power law](http://en.wikipedia.org/wiki/Power_law), 越大的数出现的概率越小) 随机生成一个介于 `1` 和 `32` 之间的值作为 `level` 数组的大小, 这个大小就是层的“高度”.

分别展示了三个高度为 `1` 层,  `3` 层和 `5` 层的节点, 因为 C 语言的数组索引总是从 `0` 开始的, 所以节点的第一层是 `level[0]` , 而第二层是 `level[1]` , 以此类推.

<img src="http://www.milky.show/images/redis/redis_36.png" alt="http://www.milky.show/images/redis/redis_36.png" style="zoom: 40%;" />

**前进指针**

每个层都有一个指向表尾方向的前进指针(`level[i].forward` 属性), 用于从表头向表尾方向访问节点.

虚线表示出了程序从表头向表尾方向, 遍历跳跃表中所有节点的路径: 

1. 迭代程序首先访问跳跃表的第一个节点(表头), 然后从第四层的前进指针移动到表中的第二个节点.
2. 在第二个节点时, 程序沿着第二层的前进指针移动到表中的第三个节点.
3. 在第三个节点时, 程序同样沿着第二层的前进指针移动到表中的第四个节点.
4. 当程序再次沿着第四个节点的前进指针移动时, 它碰到一个 `NULL` , 程序知道这时已经到达了跳跃表的表尾, 于是结束这次遍历.

<img src="http://www.milky.show/images/redis/redis_37.png" alt="http://www.milky.show/images/redis/redis_37.png" style="zoom: 40%;" />

**跨度**

层的跨度(`level[i].span` 属性)用于记录两个节点之间的距离: 

- 两个节点之间的跨度越大, 它们相距得就越远.
- 指向 `NULL` 的所有前进指针的跨度都为 `0` , 因为它们没有连向任何节点.

初看上去, 很容易以为跨度和遍历操作有关, 但实际上并不是这样 —— 遍历操作只使用前进指针就可以完成了, 跨度实际上是用来计算排位(rank)的:  在查找某个节点的过程中, 将沿途访问过的所有层的跨度累计起来, 得到的结果就是目标节点在跳跃表中的排位.

举个例子, 虚线标记了在跳跃表中查找分值为 `3.0` ,  成员对象为 `o3` 的节点时, 沿途经历的层:  查找的过程只经过了一个层, 并且层的跨度为 `3` , 所以目标节点在跳跃表中的排位为 `3` .

<img src="http://www.milky.show/images/redis/redis_38.png" alt="http://www.milky.show/images/redis/redis_38.png" style="zoom:33%;" />

再举个例子, 用虚线标记了在跳跃表中查找分值为 2.0 ,  成员对象为 o2 的节点时, 沿途经历的层:  在查找节点的过程中, 程序经过了两个跨度为 1 的节点, 因此可以计算出, 目标节点在跳跃表中的排位为 2 .

<img src="http://www.milky.show/images/redis/redis_39.png" alt="http://www.milky.show/images/redis/redis_39.png" style="zoom:33%;" />

**后退指针**

节点的后退指针(`backward` 属性)用于从表尾向表头方向访问节点:  跟可以一次跳过多个节点的前进指针不同, 因为每个节点只有一个后退指针, 所以每次只能后退至前一个节点.

图 5-6 用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点:  程序首先通过跳跃表的 `tail` 指针访问表尾节点, 然后通过后退指针访问倒数第二个节点, 之后再沿着后退指针访问倒数第三个节点, 再之后遇到指向 `NULL` 的后退指针, 于是访问结束.

<img src="http://www.milky.show/images/redis/redis_40.png" alt="http://www.milky.show/images/redis/redis_40.png" style="zoom:33%;" />

**分值和成员**

节点的分值(`score` 属性)是一个 `double` 类型的浮点数, 跳跃表中的所有节点都按分值从小到大来排序.

节点的成员对象(`obj` 属性)是一个指针, 它指向一个字符串对象, 而字符串对象则保存着一个 SDS 值.

在同一个跳跃表中, 各个节点保存的成员对象必须是唯一的, 但是多个节点保存的分值却可以是相同的:  分值相同的节点将按照成员对象在字典序中的大小来进行排序, 成员对象较小的节点会排在前面(靠近表头的方向), 而成员对象较大的节点则会排在后面(靠近表尾的方向).

举个例子, 在图 5-7 所示的跳跃表中, 三个跳跃表节点都保存了相同的分值 `10086.0` , 但保存成员对象 `o1` 的节点却排在保存成员对象 `o2`和 `o3` 的节点之前, 而保存成员对象 `o2` 的节点又排在保存成员对象 `o3` 的节点之前, 由此可见, `o1` ,  `o2` ,  `o3` 三个成员对象在字典中的排序为 `o1 <= o2 <= o3` .

<img src="http://www.milky.show/images/redis/redis_41.png" alt="http://www.milky.show/images/redis/redis_41.png" style="zoom: 33%;" />

虽然仅靠多个跳跃表节点就可以组成一个跳跃表, 但通过使用一个 zskiplist 结构来持有这些节点, 程序可以更方便地对整个跳跃表进行处理, 比如快速访问跳跃表的表头节点和表尾节点, 又或者快速地获取跳跃表节点的数量(也即是跳跃表的长度)等信息

**zskiplist 结构的定义如下: **

```c
typedef struct zskiplist {

    // 表头节点和表尾节点
    struct zskiplistNode *header,  *tail;

    // 表中节点的数量
    unsigned long length;

    // 表中层数最大的节点的层数
    int level;

} zskiplist;
```

header 和 tail 指针分别指向跳跃表的表头和表尾节点, 通过这两个指针, 程序定位表头节点和表尾节点的复杂度为 O(1)  .

通过使用 length 属性来记录节点的数量, 程序可以在 O(1)  复杂度内返回跳跃表的长度.

level 属性则用于在 O(1)  复杂度内获取跳跃表中层高最大的那个节点的层数量, 注意表头节点的层高并不计算在内.



**重点回顾**

- 跳跃表是有序集合的底层实现之一, 除此之外它在 Redis 中没有其他应用.
- Redis 的跳跃表实现由 `zskiplist` 和 `zskiplistNode` 两个结构组成, 其中 `zskiplist` 用于保存跳跃表信息(比如表头节点, 表尾节点, 长度), 而 `zskiplistNode` 则用于表示跳跃表节点.
- 每个跳跃表节点的层高都是 `1` 至 `32` 之间的随机数.
- 在同一个跳跃表中, 多个节点可以包含相同的分值, 但每个节点的成员对象必须是唯一的.
- 跳跃表中的节点按照分值大小进行排序, 当分值相同时, 节点按照成员对象的大小进行排序.



<img src="http://www.milky.show/images/redis/redis_7.png" alt="http://www.milky.show/images/redis/redis_7.png" style="zoom: 33%;" />



**搜索: **从最高层的链表节点开始, 如果比当前节点要大和比当前层的下一个节点要小, 那么则往下找, 也就是和当前层的下一层的节点的下一个节点进行比较, 以此类推, 一直找到最底层的最后一个节点, 如果找到则返回, 反之则返回空.

**插入: **首先确定插入的层数, 有一种方法是假设抛一枚硬币, 如果是正面就累加, 直到遇见反面为止, 最后记录正面的次数作为插入的层数.当确定插入的层数k后, 则需要将新元素插入到从底层到k层.

**删除: **在各个层中找到包含指定值的节点, 然后将节点从链表中删除即可, 如果删除以后只剩下头尾两个节点, 则删除这一层.



前面讲过, skiplist 编码的有序集合对象使用 zset 结构作为底层实现。一个 zset 结构同时包含一个字典和一个跳跃表。

```c
typedef struct zset {
    zskiplist *zs1;
    dict *dict;
}
```

zset 结构中的 zs1 跳跃表按分值从小到大保存了所有集合元素, 每个跳跃表节点都保存了一个集合元素。

通过跳跃表, 可以对有序集合进行基于 score 的快速范围查找。zset 结构中的 dict 字典为有序集合创建了从成员到分值的映射, 字典的键保存了成员, 字典的值保存了分值。通过字典, 可以用 **O(1)** 复杂度查找给定成员的分值。

假如还是执行 ZADD price 8.5 apple 5.0 banana 6.0 cherry 命令向 zset 保存数据, 如果采用 skiplist 编码方式的话, 该有序集合在内存中的结构如下:

<img src="http://www.milky.show/images/redis/redis_104.png" alt="http://www.milky.show/images/redis/redis_104.png" style="zoom: 50%;" />









**总结**

大多数情况下, Redis使用简单字符串SDS作为字符串的表示, 相对于C语言字符串, SDS具有常数复杂度获取字符串长度, 杜绝了缓存区的溢出, 减少了修改字符串长度时所需的内存重分配次数, 以及二进制安全能存储各种类型的文件, 并且还兼容部分C函数.

通过为链表设置不同类型的特定函数, Redis链表可以保存各种不同类型的值, 除了用作列表键, 还在发布与订阅, 慢查询, 监视器等方面发挥作用(后面会介绍).

Redis的字典底层使用哈希表实现, 每个字典通常有两个哈希表, 一个平时使用, 另一个用于rehash时使用, 使用链地址法解决哈希冲突.

跳跃表通常是有序集合的底层实现之一, 表中的节点按照分值大小进行排序.

整数集合是集合键的底层实现之一, 底层由数组构成, 升级特性能尽可能的节省内存.

压缩列表是Redis为节省内存而开发的顺序型数据结构, 通常作为列表键和哈希键的底层实现之一.

以上介绍的简单字符串, 链表, 字典, 跳跃表, 整数集合, 压缩列表等数据结构就是Redis底层的一些数据结构, 用来实现上一篇博客介绍的Redis五大数据类型, 那么每种数据类型是由哪些数据结构实现的呢？下一篇博客进行介绍.





总的来说, Redis 底层数据结构主要包括简单动态字符串(SDS)、链表、字典、跳跃表、整数集合和压缩列表六种类型。并且基于这些基础数据结构实现了字符串对象、列表对象、哈希对象、集合对象以及有序集合对象五种常见的对象类型。每一种对象类型都至少采用了 2 种数据编码, 不同的编码使用的底层数据结构也不同。







## Redis 五大类型与底层结构的关系

<img src="http://www.milky.show/images/redis/redis_105.png" alt="http://www.milky.show/images/redis/redis_105.png" style="zoom:33%;" />



### 字符串对象(String)

**字符串对象的编码可以是int, raw或者embstr**
如果一个字符串的内容可以转换为long, 那么该字符串就会被转换成为long类型, 对象的ptr就会指向该long, 并且对象类型也用int类型表示.
普通的字符串有两种, embstr和raw.embstr应该是Redis 3.0新增的数据结构, 在2.8中是没有的.**如果字符串对象的长度小于39字节, 就用embstr对象.否则用传统的raw对象.**

```c
#define REDIS_ENCODING_EMBSTR_SIZE_LIMIT 44  
robj *createStringObject(char *ptr,  size_t len) {  
    if (len <= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)  
        return createEmbeddedStringObject(ptr, len);  
    else  
        return createRawStringObject(ptr, len);  
}  
```

embstr的好处有如下几点: 

1. embstr的创建只需分配一次内存, 而raw为两次(一次为[`sds`](https://github.com/antirez/redis/blob/unstable/src/sds.h)分配对象, 另一次为objet分配对象, embstr省去了第一次).
2. 相对地, 释放内存的次数也由两次变为一次.
3. embstr的objet和sds放在一起, 更好地利用缓存带来的优势.
4. 但redis不集成对embstr的操作, 因此执行命令时, 会自动将embstr转换为row编码

raw 和 embstr 的区别可以用下面两幅图所示: 

**raw 编码的字符串对象:**

<img src="http://www.milky.show/images/redis/redis_11.png" alt="http://www.milky.show/images/redis/redis_11.png" style="zoom:33%;" />

**embstr 编码的字符串对象:**

<img src="http://www.milky.show/images/redis/redis_12.png" alt="http://www.milky.show/images/redis/redis_12.png" style="zoom:33%;" />



**当字符串对象是由整数构成时, 采用整数值作为底层结构; 当对象有字符串构成, 且值小于32字节, 此时用embstr编码的SDS, 否则采用row编码的SDS.**



### 列表对象(List)

**列表对象的编码可以是ziplist或者linkedlist**

ziplist是一种压缩链表, 它的好处是更能节省内存空间, 因为它所存储的内容都是在连续的内存区域当中的.当列表对象元素不大, 每个元素也不大的时候, 就采用ziplist存储但当数据量过大时就ziplist就不是那么好用了.因为为了保证他存储内容在内存中的连续性, 插入的复杂度是O(N), 即每次插入都会重新进行realloc.如下图所示, 对象结构中ptr所指向的就是一个ziplist整个ziplist只需要malloc一次, 它们在内存中是一块连续的区域.

<img src="http://www.milky.show/images/redis/redis_13.png" alt="http://www.milky.show/images/redis/redis_13.png" style="zoom:33%;" />

linkedlist是一种双向链表.它的结构比较简单, 节点中存放pre和next两个指针, 还有节点相关的信息.当每增加一个node的时候, 就需要重新malloc一块内存.

<img src="http://www.milky.show/images/redis/redis_14.png" alt="http://www.milky.show/images/redis/redis_14.png" style="zoom:33%;" />



**当列表对象所有值小于64字节, 且长度小于512个, 采用压缩列表作为底层结构.否则自动采用双端链表的结构**

### 哈希(Map)

**哈希对象的底层实现可以是ziplist或者hashtable.**
ziplist中的哈希对象是按照key1, value1, key2, value2这样的顺序存放来存储的.当对象数目不多且内容不大时, 这种方式效率是很高的.

hashtable的是由dict这个结构来实现的, dict是一个字典, 其中的指针dicht ht[2] 指向了两个哈希表

```c
typedef struct dict {  
    dictType *type;  
    void *privdata;  
    dictht ht[2];  
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */  
    int iterators; /* number of iterators currently running */  
} dict;  
typedef struct dictht {  
    dictEntry **table;  
    unsigned long size;  
    unsigned long sizemask;  
    unsigned long used;  
} dictht;  
```

dicht[0] 是用于真正存放数据, dicht[1]一般在哈希表元素过多进行rehash的时候用于中转数据.
dictht中的table用语真正存放元素了, 每个key/value对用一个dictEntry表示, 放在dictEntry数组中.

<img src="http://www.milky.show/images/redis/redis_15.png" alt="http://www.milky.show/images/redis/redis_15.png" style="zoom:33%;" />

**当哈希对象每个值小于64字节, 且大小小于512个时, 采用压缩列表作为底层结构.否则自动采用字典的结构**

### 集合对象(Set)

**集合对象的编码可以是intset或者hashtable**
intset是一个整数集合, 里面存的为某种同一类型的整数, 支持如下三种长度的整数: 

```c
#define INTSET_ENC_INT16 (sizeof(int16_t))  
#define INTSET_ENC_INT32 (sizeof(int32_t))  
#define INTSET_ENC_INT64 (sizeof(int64_t))
```

intset是一个有序集合, 查找元素的复杂度为O(logN), 但插入时不一定为O(logN), 因为有可能涉及到升级操作.比如当集合里全是int16_t型的整数, 这时要插入一个int32_t, 那么为了维持集合中数据类型的一致, 那么所有的数据都会被转换成int32_t类型, 涉及到内存的重新分配, 这时插入的复杂度就为O(N)了.
intset不支持降级操作.

**当集合对象每个值是整数, 且集合大小小于512个时, 采用整数作为底层结构.否则自动采用字典的结构**

### 有序集合对象(ZSet)

**有序集合的编码可能两种, 一种是ziplist, 另一种是skiplist与dict的结合.**
ziplist作为集合和作为哈希对象是一样的, member和score顺序存放.按照score从小到大顺序排列
skiplist是一种跳跃表, 它实现了有序集合中的快速查找, 在大多数情况下它的速度都可以和平衡树差不多.但它的实现比较简单, 可以作为平衡树的替代品.它的结构比较特殊.下面分别是跳跃表skiplist和它内部的节点skiplistNode的结构体: 

```c
/* 
 * 跳跃表 
 */  
typedef struct zskiplist {  
    // 头节点,  尾节点  
    struct zskiplistNode *header,  *tail;  
    // 节点数量  
    unsigned long length;  
    // 目前表内节点的最大层数  
    int level;  
} zskiplist;  
/* ZSETs use a specialized version of Skiplists */  
/* 
 * 跳跃表节点 
 */  
typedef struct zskiplistNode {  
    // member 对象  
    robj *obj;  
    // 分值  
    double score;  
    // 后退指针  
    struct zskiplistNode *backward;  
    // 层  
    struct zskiplistLevel {  
        // 前进指针  
        struct zskiplistNode *forward;  
        // 这个层跨越的节点数量  
        unsigned int span;  
    } level[];  
} zskiplistNode;  
```

head和tail分别指向头节点和尾节点, 然后每个skiplistNode里面的结构又是分层的(即level数组)
用图表示, 大概是下面这个样子: 

<img src="http://www.milky.show/images/redis/redis_16.png" alt="http://www.milky.show/images/redis/redis_16.png" style="zoom: 33%;" />

**当集合的长度小于64字节, 且集合大小小于128时, 采用压缩列表作为底层结构.否则自动采用跳跃表和字典的结构**

**有序集合是比较特殊的结构, 采用跳跃表和字典双重结构: **

**当单独采用跳跃表时, 虽然保留跳跃表的优点, 但是获取集合的值时, 无法像字典那样效率达到O(1) **

**当单独采用字典结构时, 虽然获取值时效率较高, 但由于字典时无序的, 进行有序遍历或者排序时, 效率较差.**
