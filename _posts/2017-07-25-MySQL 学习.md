---
layout: post
title: "MySQL 学习"
categories: [RDBMS]
description: mysql基础语法
keywords: rdbms, mysql
---

* content
{:toc}
## 基础操作

### 数据库操作

创建数据库

```mysql
create database web08; --默认字符集
create database web08_01 character set gbk; --指定字符集
```

查看数据库

```mysql
show databases;
```

查看数据库结构

```mysql
show create database web08_01;
```

查看正在使用的库

```mysql
select database();
```

删除一个库

```mysql
drop database web08_01;
```

使用库

```mysql
use web08;
```

导出整个库

```mysql
mysqldump -u 用户名 -p 数据库名 > 导出的文件名
```


### 表操作

创建表
```mysql
create table 表名{
    字段名 类型(长度) [约束],
    字段名 类型(长度) [约束]
};
      
create table user(
    uid int(32) primary key auto_increment,
    uname varchar(32),
    upassword varchar(32)
);
      
主键约束: primary key 要求被修饰的字段: 唯一和非空
唯一约束: unique 要求被修饰的字段: 唯一
非空约束: not null 要求被修饰的字段: 非空
```

查看表列表

```mysql
show tables;
```

查看表结构

```mysql
desc user;
```

删除表

```mysql
drop table user;
```

修改表

```mysql
alter table user add column uinfo varchar(32) not null; --增加一列

alter table user modify uinfo varchar(50) not null; -- 修改列的长度, 类型, 约束

alter table user change 旧列名 新列名 类型(长度) 约束; -- 修改列名, 类型, 约束

alter table user drop 列名; -- 删除列

rename table 表名 to 新表名; -- 修改表名

alter table 表名 character set 字符集 -- 修改表的字符集
```

查看当前表的编码

```mysql
show create table tbl_user;
```

导出一个表

```bash
mysqldump -u 用户名 -p 数据库名 表名> 导出的文件名
```

导入

```bash
在 mysql命令行界面 source 目标sql文件
```

插入记录

```mysql
insert into 表(列名1, 列名2, 列名3, ...) values(值1, 值2, 值3);

insert into 表 values(值1, 值2, 值3...);
```

更新记录

```mysql
update 表名 set 字段名=值, 字段名=值 where = 条件
```

删除记录

```mysql
delete from 表名 where = 条件
```

从现有表新建表

```mysql
create table new_table_name from select [*|column1,column2] from table_name [where]
```

### 查询

准备工作
```mysql
create table product(    
    pid int primary key auto_increment,   
    pname varchar(20),   
    price double,   
    pdate timestamp,
    cid varchar(32)
)
```

自动增长列:auto_increment

1.  必须整型(int) 
2.  必须是主键

```mysql
insert into product values (null,'谭妮平',0.01,null,1);
insert into product values (null,'李士雪',38,null,1);
insert into product values (null,'左慈',-998,null,1);
insert into product values (null,'黄迎',99999,null,2);
insert into product values (null,'南国强',99998,null,2);
insert into product values (null,'士兵',1,null,2);
insert into product values (null,'李士兵',698,null,3);
insert into product values (null,'士兵',1,null,3);
```

简单查询

1.  查询所有商品

    ```mysql
    select * from product;
    ```

2.  查询商品名和商品价格

    ```mysql
    select pname, price from product;
    ```

3.  查询所有商品信息使用表别名

    ```mysql
    select * from product as p; --as可以省略
    ```

4.  查询商品名, 使用列别名

    ```mysql
    select pname as name from product; --as可以省略
    ```

5.  去掉重复值(按照价格)

    ```mysql
    select distinct price from product;
    ```

6.  将所有的商品的价格+10进行显示

    ```mysql
    select price + 10 from product;
    ```

条件查询

1.  查询商品名称为"左慈"的商品信息

    ```mysql
    select * from product where pname = '左慈';
    ```

2.  查询价格>60元的所有商品信息

    ```mysql
    select * from product where price > 60;
    ```

3.  查询商品名称含有"士"字的商品信息

    ```mysql
    select * from product where pname like '%士%';
    ```

4.  查询商品id在(3,6,9)范围内的所有商品信息

    ```mysql
    select * from product where pid in (3, 6, 9);
    ```

5.  查询商品名称含有"士"字并且id=6的商品

    ```mysql
    select * from product where pname like '%士%' and pid = 6;
    ```

排序(asc/desc)

1.  查询所有的商品, 按价格进行排序(升序, 降序)

    ```mysql
    select * from product order by price asc;
    ```

2.  查询名称有"士"的商品信息并且按照价格降序排序

    ```mysql
    select * from product where pname like '%士%' order by price desc, pid desc;
    ```

聚合

1. 获得所有商品的价格的总和

  ```mysql
  select sum(price) from product;
  ```

2. 获得所有商品的平均价格
   
    ```mysql
    select avg(price) from product;
    ```
    
3. 获得所有商品的个数
   
    ```mysql
    select count(*) from product;
    ```

分组

1.  根据cid字段分组, 分组后统计商品的个数.

    ```mysql
    select count(*) from product group by cid;
    ```

2.  根据cid分组, 分组统计每组商品的平均价格, 并且平均价格大于20000元.

    ```mysql
    select avg(price) from product group by cid having avg(price) > 20000;
    ```

外键

1.  添加

    ```mysql
    alter table product add foreign key [constraint] [constraint_name] (从表外键字段名) references 主表(主表的主键)
    ```

多表查询

1. 交叉连接查询(基本不会使用, 得到的是两个表的乘积)

    ```mysql
    select * from A,B;
    ```

2. 内连接查询(使用 inner join --inner可以省略)

    隐士内连接: `select * from A,B where 条件`

    显示内连接: `select * from A inner join B on 条件`

3. 外连接查询(使用 outer join --outer可以省略)
   

  左外连接: `select * from A left outer join B on 条件`

    右外连接: `select * from A right outer join B on 条件`

4. 全连接 full outer join(oracle中)

5. 联合查询

     union:去重,排序,效率低

     union all:不去重,不排序,效率高

<img src="http://www.milky.show/images/mysql/1.png" alt="http://www.milky.show/images/mysql/1.png" style="zoom: 33%;" />

复制现有表

```mysql
create table new_table select * from old_table;
```


### 完整性约束

主键约束: 主键是表里一个或多个用于实现记录唯一性的字段

```mysql
create table table_name(
    id int primary key,
    name varchar(20)
);

create table table_name(
    id int,
    name varchar(20),
    primary key(id)
);
```

唯一性约束: 唯一性要求表里的某个字段的值在每条记录里是唯一的

```mysql
create table table_name(
    id int primary key,
    name varchar(20),
    cellphone varchar(11) unique
);
```

外键约束: 外键是从表里的一个字段, 引用主表里的主键

```mysql
create table tb_emp(
    id int primary key,
    dept_id int,
    constraint fk_emp_dept_id foreign_key(dept_id) references tb_dept(id)
);
```


### 服务操作

启动服务端(mac)

```bash
mysql.server start
```

停止服务端(mac)

```bash
mysql.server stop
```

启动客户端(mac)

```bash
mysql -uroot -p
```

启动服务端(Linux)

```bash
service mysqld start
```

停止服务端(Linux)

```bash
service mysqld stop
```

### 权限操作

授权操作

```mysql
grant all privileges on databasename.tablename to 'username'@'addr' identified by 'password';

将所有库的所有表的增删改查权限授权给miaomiaoqi用户在localhost登录时, 并且密码是miaoqi
grant select,delete,update,INSERT on *.* to 'miaomiaoqi'@'localhost' identified by 'miaoqi';
```

```mysql
grant all PRIVILEGES on *.* to 'miaomiaoqi'@'localhost' identified by 'miaoqi';
```

查看权限

```mysql
show grants;

show grants for username;

select * from mysql.user;
```



### 特殊sql

补充自增主键

```mysql
alter table `表名` add column `列名` int not null auto_increment primary key comment '主键' first;
```

中文字段排序

```mysql
ORDER BY CONVERT(column USING gbk) ASC
```

## 锁

### 悲观锁

数据库层面加个排它锁, 性能低

```mysql
select * from account for update;
try {
    // process business logic
    commit();
} catch (Exception e) {
    rollback();
}
```

### 乐观锁

程序员手动控制(CAS机制)

```mysql
int version = select version from tb_xxx where id = 1;
boolean success = update tb_xxx set name = 'bbb' where id = 1 and version = 1.0
if (!success) {
    try...again
}
```

## 函数

### DATE_FORMAT

日期格式化函数

```mysql
SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s') FROM DUAL;
```

### INSTR

判断 fo 是否在 foobarbar 中

```mysql
SELECT INSTR('foobarbar', 'fo') FROM DUAL;
```

### GROUP_CONCAT

我们在写统计 sql 的时候, 有时候需要根据某个字段进行 group by 操作, 当我们进行 group by 操作后, 多条数据会合并成一条, 这时候想要展示出其他字段的值, 就可以使用 group_concat 函数, 假设有如下数据

username	score
zhangsan	10
zhangsan	20
zhangsan	30
lisi			50

根据 username 进行group by 多条数据就会合成一条

```mysql
select * from tbl group by username;
```

执行结果如下:

username	score

zhangsan	10

lisi			50

如果我们想要看下zhangsan和lisi的全部得分怎么办呢? group_concat函数就出场了, 修改sql如下

```mysql
select username, group_concat(score) from tbl group by username;
```

执行结果如下:

username	group_concat(score)

zhangsan	10, 20, 30

lisi			50

到此group_concat的用法就介绍完了

**group_concat 存在的问题**

在做项目中, 遇到了一个很奇葩的问题, 应该给用户返钱, 但总是漏掉一些用户, 通过查看日志发现, group_concat 后的数据少了一部分, 通过查找发现 mysql 的 group_concat 默认连接长度为 1024 字符, 也就是说如果超过 1024 字符, 它只会显示这么多, 其余部分会被截取丢掉, 导致我们漏掉了数据

* 解决办法一

    修改连接的配置

    ```
    SET GLOBAL group_concat_max_len=102400;
    SET SESSION group_concat_max_len=102400; 
    ```

* 解决办法二

    修改 mysql 配置文件, 在 mysql 配置文件中添加如下这句, 修改配置文件后记得需要重启 mysql 服务

    ```
    group_concat_max_len = 102400
    ```

虽然上面的办法可以解决问题, 但是使用函数终究性能不会太好, 所以我决定以后避免使用 group_concat 函数, 而是通过关键列进行简单的索引查找, 在应用层中进行分组, 这样可以避免一些不可预知的问题, 也可以减少 mysql 的压力



## 主从一致 binlog

binlog 是用来实现 mysql 主从的重要文件

主库负责写, 从库负责读, 主库会启动一个线程, 将写操作写到日志文件 binlog 中, 从库会启动一个 IO 线程负责从日志文件中读取操作记录, SQL 线程负责执行操作记录进行同步

如何保持一致性: 减少数据库压力

binlog 是记录所有数据库表结构变更(例如CREATE, ALTER TABLE…)以及表数据修改(INSERT, UPDATE, DELETE…)的二进制日志

binlog 不会记录 SELECT 和 SHOW 这类操作, 因为这类操作对数据本身并没有修改, 但你可以通过查询通用日志来查看 MySQL 执行过的所有语句.

**多说一句, 如果 update 操作没有造成数据变化, 也是会记入binlog.**

### 误解

binlog只是一类记录操作内容的日志文件

因为binlog称之为二进制日志, 很多研发会把这个二进制日志和我们平时在代码里写的代码日志联系在一起.因为我们的代码日志, 只有一类记录操作容的文件, 并不包含索引文件.然而, 这个二进制日志包括两类文件:

* 索引文件(文件名后缀为.index)用于记录哪些日志文件正在被使用
* 日志文件(文件名后缀为.00000*)记录数据库所有的DDL和DML(除了数据查询语句)语句事件

假设文件my.cnf中有这么三条配置

```
log_bin:on 打开binlog日志

log_bin_basename:bin文件路径及名前缀(/var/log/mysql/mysql-bin)

log_bin_index:bin文件index(/var/log/mysql/mysql-bin.index)
```

那么你会在文件目录/var/log/mysql/下面发现两个文件mysql-bin.000001和mysql-bin.index.
mysql-bin.index就是我们所说的索引文件, 打开瞅瞅, 内容是下面这样,记录哪些文件是日志文件.

```
./mysql-bin.000001
```

那么说到日志文件.在 innodb 里其实又可以分为两部分, 一部分在缓存中, 一部分在磁盘上.这里业内有一个词叫做刷盘, 就是指将缓存中的日志刷到磁盘上.跟刷盘有关的参数有两个个 sync_binlog 和 binlog_cache_size. 这两个参数作用如下

```bash
binlog_cache_size: 二进制日志缓存部分的大小, 默认值32k

sync_binlog=[N]: 表示写缓冲多少次, 刷一次盘,默认值为0
```

注意两点:

* binlog_cache_size设过大, 会造成内存浪费.binlog_cache_size设置过小, 会频繁将缓冲日志写入临时文件.具体怎么设, 有兴趣自行查询, 我觉得研发大大根本没机会去设这个值的, 了解即可.
* sync_binlog=0:表示刷新binlog时间点由操作系统自身来决定, 操作系统自身会每隔一段时间就会刷新缓存数据到磁盘, 这个性能最好.sync_binlog=1, 代表每次事务提交时就会刷新binlog到磁盘.sync_binlog=N,代表每N个事务提交会进行一次binlog刷新.

另外, 这里存在一个一致性问题, sync_binlog=N, 数据库在操作系统宕机的时候, 可能数据并没有同步到磁盘, 于是再次重启数据库, 会带来数据丢失问题. 
当sync_binlog=1, 事务在Commit的时候, 数据写入binlog, 但是还没写入事务日志(redo log和undo log).此时宕机, 重启数据库, 数据被回滚.但是binlog里已经记录, 这里存在不一致问题.这个事务日志和binlog一致性的问题, 大家可以查询mysql的内部XA协议, 该协议就是解决这个一致性问题的.

**binlog是InnoDb独有的**

binlog是以事件形式记录的, 这句话通俗点说, 就是binlog的内容都是一个个的事件.这块具体的我会在下一篇讲, 这篇记住binlog的内容就是一个个事件就行.
注意了, 这里的用词, 是一个个事件, 而不是事务.大家应该知道Innodb和mysiam最显著的区别就是一个支持事务, 一个不支持事务.
因此你可以说, binlog是基于事务来记录二进制日志, 比如sync_binlog=1,每提交一次事务, 就写入binlog.你却不能说binlog是事务日志, binlog不仅记录innodb日志, 在myisam中, 也一样存在binlog.

### 数据库常用语句

| sql 语句                                                | 含义                                                         |
| :------------------------------------------------------ | :----------------------------------------------------------- |
| show variables like 'bin_log';                          | 查看是否开启 binlog                                          |
| show variables like 'binlog_format';                    | 查看 binlog 格式                                             |
| show master logs;                                       | 查看所有的 binlog 日志列表                                   |
| show master status;                                     | 查看最后一个 Binlog 日志的编号名称, 及最后一个事件结束的位置(pos) |
| flush logs;                                             | 刷新 Binlog, 此刻开始产生一个新编号的 Binlog 文件            |
| reset master;                                           | 清空所有的 Binlog 日志                                       |
| show binlog events;                                     | 查看第一个 Binlog 日志                                       |
| show binlog events in 'binlog.000030'                   | 查看指定的 Binlog 日志                                       |
| show binlog events in 'binlog.000030' from 931;         | 从指定位置开始, 查看指定 Binlog 日志                         |
| show binlog events in 'binlog.000030' from 931 limit 2; | 从指定位置开始, 查看指定 Binlog 日志, 限制查询的条数         |

**Binlog 的 Event_type**

query_event: 与数据操作无关, begin, drop table, truncate table 等

table_map_event: 记录下一个操作所对应的表信息, 存储了数据库名和表名

xid_event: 标记事务提交

write_rows_event: 插入数据, 即 insert 操作

update_rows_event: 更新数据, 即 update 操作

delete_rows_event: 删除数据, 即 delete 操作

### 用途

#### 复制

主库有一个单独的 log dump 线程, 将 binlog 传给从库, 从库有两个线程, 一个I/O线程, 一个SQL线程, I/O线程读取主库传过来的binlog内容并写入到relay log,SQL线程从relay log里面读取内容, 写入从库的数据库, 这也是主从的原理.

#### 恢复

这里网上有大把的文章指导你, 如何利用 binlog 日志恢复数据库数据.如果你真的觉得自己很有时间, 就自己去创建个库, 然后删了, 再去恢复一下数据, 练练手吧.

#### 审计

 用户可以通过二进制日志中的信息来进行审计, 判断是否有对数据库进行注入攻击

### 常识

#### binlog 常见格式

| format    | 定义                       | 优点                           | 缺点                                                         |
| --------- | -------------------------- | ------------------------------ | ------------------------------------------------------------ |
| Statement | 记录的是修改SQL语句        | 日志文件小, 解决IO, 提高性能   | 准确性差, 对一些系统函数不能准确复制或不能复制, 如now(), uuid()等 |
| row       | 记录的是每行实际数据的变更 | 准确性强, 能准确复制数据的变更 | 日志文件大, 较大的网络IO和磁盘IO                             |
| mixed     | statement和row模式的混合   | 准确性强, 文件大小合适         | 有可能发生主从不一致问题                                     |

**业内目前推荐使用的是 row 模式**, 准确性高, 虽然说文件大, 但是现在有 SSD 和万兆光纤网络, 这些磁盘 IO 和网络 IO 都是可以接受的.那么, 大家一定想问, 为什么不推荐使用 mixed 模式, 理由如下, 假设 master 有两条记录, 而 slave 只有一条记录.

<img src="http://www.milky.show/images/mysql/binlog_1.png" alt="http://www.milky.show/images/mysql/binlog_1.png" style="zoom:67%;" />

当在master上更新一条从库不存在的记录时, 也就是id=2的记录, 你会发现master是可以执行成功的.而slave拿到这个SQL后, 也会照常执行, 不报任何异常, 只是更新操作不影响行数而已.并且你执行命令show slave status, 查看输出, 你会发现没有异常.但是, 如果你是row模式, 由于这行根本不存在, 是会报1062错误的.

#### 怎查看binlog

binlog本身是一类二进制文件.二进制文件更省空间, 写入速度更快, 是无法直接打开来查看的.

因此mysql提供了命令mysqlbinlog进行查看.

* 一般的statement格式的二进制文件, 用下面命令就可以

    ```
    mysqlbinlog mysql-bin.000001
    ```

* 如果是row格式, 加上-v或者-vv参数就行, 如

    ```
    mysqlbinlog -vv mysql-bin.000001
    ```

#### 怎么删binlog

删binlog的方法很多, 有三种是常见的

* 使用`reset master`,该命令将会删除所有日志, 并让日志文件重新从000001开始.

* 使用命令

    ```
    PURGE { BINARY | MASTER } LOGS { TO 'log_name' | BEFORE datetime_expr }
    ```

    例如

    ```
    purge master logs to "binlog_name.00000X" 
    ```

    将会清空00000X之前的所有日志文件

* 使用`expire_logs_days=N`选项指定过了多少天日志自动过期清空.

#### binlog常见参数

常见参数, 列举如下, 有个印象就好.

| 参数名                                       | 含义                                           |
| -------------------------------------------- | ---------------------------------------------- |
| log_bin = {on \| off\| base_name}            | 指定是否启用记录二进制日志或者指定一个日志路径 |
| Sql_log_bin = {on \| off}                    | 指定是否启用记录二进制日志                     |
| expire_logs_days                             | 指定自动删除二进制日志的时间, 即日志过期时间   |
| log_bin_index                                | 指定mysql-bin.index文件的路径                  |
| binlong_format = {mixed \| row \| statement} | 指定二进制日志基于什么模式记录                 |
| max_binlog_size                              | 指定二进制日志文件最大值                       |
| binlog_cache_size                            | 指定事物日志缓存区大小                         |
| max_binlog_cache_size                        | 指定二进制日志缓存最大大小                     |
| sync_binlog = {0 \| n}                       | 指定写缓冲多少次, 刷一次盘                     |

### 开源工具监听 binlog

```xml
<!-- binlog 监听与解析: https://github.com/shyiko/mysql-binlog-connector-java -->
<dependency>
    <groupId>com.github.shyiko</groupId>
    <artifactId>mysql-binlog-connector-java</artifactId>
    <version>0.13.0</version>
</dependency>
```

```java
public class BinlogServiceTest {
    public static void main(String[] args) throws IOException {
        BinaryLogClient client = new BinaryLogClient("127.0.0.1", 3306, "root", "miaoqi");
        // client.setBinlogFilename();
        // client.setBinlogPosition();
        client.registerEventListener(event -> {
            EventData data = event.getData();
            if (data instanceof UpdateRowsEventData) {
                // update ad_unit_keyword set keyword = '奔驰' where keyword = '标志';
                System.out.println("Update---------------");
                System.out.println(data.toString());
            } else if (data instanceof WriteRowsEventData) {
                // insert into `ad_unit_keyword`(`unit_id`, `keyword`) values(10, '标志');
                System.out.println("Write----------------");
                System.out.println(data.toString());
            } else if (data instanceof DeleteRowsEventData) {
                System.out.println("Delete---------------");
                System.out.println(data.toString());
            }
        });
        client.connect();
    }
}
```

**binlog 文件会监听数据库中所有的变化, 所以我们可以自定义一份模板文件, 指定我们想要监听的内容**

```json
{
  "database": "advertisement",
  "tableList": [
    {
      "tableName": "ad_plan",
      "level": 2,
      "insert": [
        {"column": "id"},
        {"column": "user_id"},
        {"column": "plan_status"},
        {"column": "start_date"},
        {"column": "end_date"}
      ],
      "update": [
        {"column": "id"},
        {"column": "user_id"},
        {"column": "plan_status"},
        {"column": "start_date"},
        {"column": "end_date"}
      ],
      "delete": [
        {"column": "id"}
      ]
    },
    {
      "tableName": "ad_unit",
      "level": 3,
      "insert": [
        {"column": "id"},
        {"column": "unit_status"},
        {"column": "position_type"},
        {"column": "plan_id"}
      ],
      "update": [
        {"column": "id"},
        {"column": "unit_status"},
        {"column": "position_type"},
        {"column": "plan_id"}
      ],
      "delete": [
        {"column": "id"}
      ]
    },
    {
      "tableName": "ad_creative",
      "level": 2,
      "insert": [
        {"column": "id"},
        {"column": "type"},
        {"column": "material_type"},
        {"column": "height"},
        {"column": "width"},
        {"column": "audit_status"},
        {"column": "url"}
      ],
      "update": [
        {"column": "id"},
        {"column": "type"},
        {"column": "material_type"},
        {"column": "height"},
        {"column": "width"},
        {"column": "audit_status"},
        {"column": "url"}
      ],
      "delete": [
        {"column": "id"}
      ]
    },
    {
      "tableName": "creative_unit",
      "level": 3,
      "insert": [
        {"column": "creative_id"},
        {"column": "unit_id"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "creative_id"},
        {"column": "unit_id"}
      ]
    },
    {
      "tableName": "ad_unit_district",
      "level": 4,
      "insert": [
        {"column": "unit_id"},
        {"column": "province"},
        {"column": "city"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "unit_id"},
        {"column": "province"},
        {"column": "city"}
      ]
    },
    {
      "tableName": "ad_unit_it",
      "level": 4,
      "insert": [
        {"column": "unit_id"},
        {"column": "it_tag"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "unit_id"},
        {"column": "it_tag"}
      ]
    },
    {
      "tableName": "ad_unit_keyword",
      "level": 4,
      "insert": [
        {"column": "unit_id"},
        {"column": "keyword"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "unit_id"},
        {"column": "keyword"}
      ]
    }
  ]
}
```

**查看表信息**

```sql
select table_schema, table_name, column_name, ordinal_position from information_schema.columns where table_schema = 'advertisement' and table_name = 'ad_unit_keyword';
```





## MyISAM 和 InnoDB

myisam引擎是5.1版本之前的默认引擎, 支持全文检索、压缩、空间函数等, 但是不支持事务和行级锁, 所以一般用于有大量查询少量插入的场景来使用, 而且myisam不支持外键, 并且索引和数据是分开存储的. 

innodb是基于聚簇索引建立的, 和myisam相反它支持事务、外键, 并且通过MVCC来支持高并发, 索引和数据存储在一起. 

### 区别

1.  InnoDB 支持事务, MyISAM 不支持事务.这是 MySQL 将默认存储引擎从 MyISAM 换到 InnoDB 的重要原因.
2.  InnoDB 支持外键, MyISAM 不支持外键.对一个包含外键的 InnoDB 表转换为 MyISAM 会失败.
3.  InnoDB 是聚集索引, MyISAM 是非聚集索引.聚集索引的文件放在主键索引的叶子节点上, 所以 InnoDB 必须要有主键, 通过主键索引效率很高.MyISAM 是非聚集索引, 数据文件是分离的, 索引保存的是数据文件的指针.主键索引和辅助索引是独立的.
4.  InnoDB 不保存表的具体行数.执行 `SELECT COUNT(*) FROM table` 时需要全表扫描.MyISAM 用一个变量保存了整个表的行数, 因此统计全表行数速度很快.
5.  InnoDB 最小的锁粒度是行锁, MyISAM 最小的锁粒度是表锁.
6.  InnoDB 支持 MVCC, MyISAM 不支持.
7.  InnoDB 5.6 之前不支持全文索引(5.6及之后支持), MyISAM支持.

### 选择

-   是否需要支持事务.如果要支持事务, 选择 InnoDB
-   如果绝大多数是读查询操作, 选择 MyISAM; 如果读写均很频繁, 则选择 InnoDB
-   系统崩溃后, MyISAM 恢复更为困难, 如果不能接受, 则选择 InnoDB



| 对比项 | MyISAM                                                | InnoDB                                               |
| ------ | ----------------------------------------------------- | ---------------------------------------------------- |
| 主外键 | 不支持                                                | 支持                                                 |
| 事物   | 不支持                                                | 支持                                                 |
| 行表锁 | 表锁, 即使操作一条记录也会锁住整个表,不适合高并发操作 | 行锁,操作时只锁某一行,不对其他行有影响,适合高并发    |
| 缓存   | 只缓存索引, 不缓存真实数据                            | 不仅缓存索引还缓存真实数据,对内存要求高,内存决定性能 |
| 表空间 | 小                                                    | 大                                                   |
| 关注点 | 性能                                                  | 事务                                                 |

## InnoDB 引擎的行锁和表锁

InnoDB 与 MyISAM 的最大不同有两点: 一是支持事务(TRANSACTION); 二是采用了行级锁. 行级锁与表级锁本来就有许多不同之处, 另外, 事务的引入也带来了一些新问题.下面我们先介绍一点背景知识, 然后详细讨论InnoDB的锁问题.

**在 mysql 的 InnoDB 引擎支持行锁, 与 Oracle 不同, mysql 的行锁是通过索引加载的, 即是行锁是加在索引响应的行上的, 要是对应的SQL语句没有走索引, 则会全表扫描, 行锁则无法实现, 取而代之的是表锁.**

**表锁**: 不会出现死锁, 发生锁冲突几率高, 并发低.

**行锁**: 会出现死锁, 发生锁冲突几率低, 并发高.

**锁冲突**: 例如说事务 A 将某几行上锁后, 事务 B 又对其上锁, 锁不能共存否则会出现锁冲突.**(但是共享锁可以共存, 共享锁和排它锁不能共存, 排它锁和排他锁也不可以)**

**死锁**: 例如说两个事务, 事务 A 锁住了 1~5 行, 同时事务 B 锁住了 6~10 行, 此时事务 A 请求锁住 6~10 行, 就会阻塞直到事务 B 释放 6~10 行的锁, 而随后事务 B 又请求锁住 1~5 行, 事务 B 也阻塞直到事务 A 释放 1~5 行的锁. 死锁发生时, 会产生 Deadlock 错误.

**锁是对表操作的, 所以自然锁住全表的表锁就不会出现死锁.**

### 行锁

优势: 锁粒度小, 发生锁冲突的概率低;处理并发的能力强

劣势: 开销大;加锁慢;会出现死锁

加锁方式: 自动加锁.查询操作不加任何锁;更新操作会自动给涉及的记录加排他锁.

显式加锁: 

*   共享锁 select * from 【tablename】 where …… lock in share more;

*   排他锁 select * from 【tablename】 where …… for update;

行锁优化: 

*   尽可能让所有数据检索都通过索引来完成, 避免无索引或索引失效导致行锁升级为表锁.

*   尽可能避免间隙锁带来的性能下降, 减少或使用合理的检索范围.

*   尽可能减少事务的粒度, 比如控制事务大小, 从而减少锁定资源量和时间长度, 从而减少锁的竞争, 提高性能.

*   尽可能使用低级别的事务隔离级别, 隔离级别越高, 并发的处理能力越低.

#### 行锁的类型

行锁分共享锁和排它锁.

**共享锁又称**: 读锁.当一个事务对某几行上读锁时, 允许其他事务对这几行进行读操作, 但不允许其进行写操作, 也不允许其他事务给这几行上排它锁, 但允许上读锁.

**排它锁又称**: 写锁.当一个事务对某几个上写锁时, 不允许其他事务写, 但允许读.更不允许其他事务给这几行上任何锁.包括写锁.

**上共享锁的写法**: lock in share mode

```mysql
select math from zje where math > 60 lock in share mode;
```

**上排它锁的写法**: for update

```mysql
select math from zje where math > 60 for update;
```

#### 行锁的实现

1.  行锁必须有索引才能实现, 否则会自动锁全表, 那么就不是行锁了.

2.  必须要有事务, 这样才是行锁

3.  两个事务不能锁同一个索引, 例如:

    ```mysql
    事务A先执行:
    select math from zje where math > 60 for update;
     
    事务B再执行:
    select math from zje where math < 60 for update;
    
    这样的话, 事务 B 是会阻塞的.如果事务 B 把 math索引换成其他索引就不会阻塞
    ```

4.  insert, delete,  update 在事务中都会自动默认加上排它锁.

    行级锁定不是 MySQL 自己实现的锁定方式, 而是由其他存储引擎自己所实现的, 如广为大家所知的 InnoDB 存储引擎, 以及 MySQL 的分布式存储引擎NDBCluster 等都是实现了行级锁定.考虑到行级锁定君由各个存储引擎自行实现, 而且具体实现也各有差别, 而 InnoDB 是目前事务型存储引擎中使用最为广泛的存储引擎, 所以这里我们就主要分析一下 InnoDB 的锁定特性.

    InnoDB 锁定模式及实现机制
    总的来说, InnoDB 的锁定机制和 Oracle 数据库有不少相似之处.InnoDB 的行级锁定同样分为两种类型, 共享锁和排他锁, 而在锁定机制的实现过程中为了让行级锁定和表级锁定共存, InnoDB 也同样使用了意向锁(表级锁定)的概念, 也就有了意向共享锁和意向排他锁这两种.
    当一个事务需要给自己需要的某个资源加锁的时候, 如果遇到一个共享锁正锁定着自己需要的资源的时候, 自己可以再加一个共享锁, 不过不能加排他锁.但是, 如果遇到自己需要锁定的资源已经被一个排他锁占有之后, 则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定.而意向锁的作用就是当一个事务在需要获取资源锁定的时候, 如果遇到自己需要的资源已经被排他锁占用的时候, 该事务可以需要锁定行的表上面添加一个合适的意向锁.如果自己需要一个共享锁, 那么就在表上面添加一个意向共享锁.而如果自己需要的是某行(或者某些行)上面添加一个排他锁的话, 则先在表上面添加一个意向排他锁.意向共享锁可以同时并存多个, 但是意向排他锁同时只能有一个存在.所以, 可以说 InnoDB 的锁定模式实际上可以分为四种:共享锁(S), 排他锁(X), 意向共享锁(IS)和意向排他锁(IX), 我们可以通过以下表格来总结上面这四种所的共存逻辑关系:

|                    | 共享锁(S) | 排它锁(X) | 意向共享锁(IS) | 意向排它锁(IX) |
| ------------------ | --------- | --------- | -------------- | -------------- |
| **共享锁(S)**      | 兼容      | 冲突      | 兼容           | 冲突           |
| **排它锁(X)**      | 冲突      | 冲突      | 冲突           | 冲突           |
| **意向共享锁(IS)** | 兼容      | 冲突      | 兼容           | 兼容           |
| **意向排它锁(IX)** | 冲突      | 冲突      | 兼容           | 兼容           |

如果一个事务请求的锁模式与当前的锁兼容, InnoDB就将请求的锁授予该事务;反之, 如果两者不兼容, 该事务就要等待锁释放.
**意向锁是 InnoDB 自动加的, 不需用户干预.对于 UPDATE, DELETE 和 INSERT 语句, InnoDB 会自动给涉及数据集加排他锁(X);对于普通SELECT语句, InnoDB 不会加任何锁;**

#### 查看锁竞争情况

使用命令 `show status like 'innodb_row_lock%';` 查看锁竞争情况

```mysql
show status like 'innodb_row_lock%';

Innodb_row_lock_current_waits	0
Innodb_row_lock_time	0
Innodb_row_lock_time_avg	0
Innodb_row_lock_time_max	0
Innodb_row_lock_waits	0
```

**如果发现锁争用比较严重, 如 InnoDB_row_lock_waits 和 InnoDB_row_lock_time_avg 的值比较高, 还可以通过设置 InnoDB Monitors 来进一步观察发生锁冲突的表, 数据行等, 并分析锁争用的原因.**



### 表锁

优势: 开销小;加锁快;无死锁

劣势: 锁粒度大, 发生锁冲突的概率高;处理并发的能力弱

加锁方式: 自动加锁.查询操作会自动给涉及的所有表加读锁;更新操作会自动给涉及的表加写锁.

显式加锁: 

-   共享读锁: lock table 【tablename】 read;
-   独占写锁: lock table 【tablename】 write;
-   批量解锁: unlock tables;

表锁中: 读锁会阻塞写, 不会阻塞读;而写锁则会把读写都阻塞.

### 行锁变表锁

1.  当索引生效时使用行锁;没有索引或索引失效时使用表锁

2.  当生效的索引是唯一索引, 则使用行锁;当生效的索引不是唯一索引, 则使用表锁.(用索引字段做为条件进行修改时,  是否表锁的取决于这个索引字段能否确定记录唯一, 当索引值对应记录不唯一, 会进行锁表, 相反则行锁.)

3.  当表的大部分数据需要修改时, 行锁会升级为表锁

4.  多表复杂关联查询时, 行锁会升级为表锁.因为复杂的关联查询, 事务涉及多个表, 很可能引起死锁, 造成大量事务回滚.这种情况若能一次性锁定事务涉及的表, 从而可以避免死锁, 减少数据库因事务回滚带来的开销.

### 锁定义

#### 间隙锁

定义: 当使用范围条件检索数据并请求共享或排他锁时, InnoDB 会给符合条件的已有数据记录的索引项加锁;对于键值在条件范围内但并不存在的记录, 叫做间隙(GAP).InnoDB 也会对这个间隙加锁, 这种锁机制就是所谓的间隙锁(Next-Key锁).

危害: 若执行的条件范围过大, 则 InnoDB 会将整个范围内所有的索引键值全部锁定, 很容易对性能造成影响.

#### 排他锁

定义: 排他锁也称为写锁, 独占锁, 当前写操作没有完成前, 会阻断其他写锁和读锁.

排他锁是行锁

#### 共享锁

定义: 共享锁也称为读锁, 多用于判断数据是否存在.多个读操作可以同时进行而不会互相影响, 但会阻塞对同一表的写操作, 只有当读锁释放后, 才能执行其他进程的写操作.如果事务对读锁进行修改操作, 很可能会造成死锁.

共享锁是行锁

#### 意向锁

意向锁是表锁

意向共享锁: 事务在请求共享锁时, 需要先获取意向共享锁

意向排他锁: 事务在请求排他锁时, 需要先获取意向排他锁

为什么意向锁是表锁: 当需要一个排他锁时, 需要根据意向锁判断表中有没有数据行被锁定: 

-   如果意向锁是行锁, 则需要遍历每一行去确认
-   如果意向锁是表锁, 则只需要一次即可知道有没有数据行被锁定, 提升性能



### 间隙锁(Next-Key 锁)

当我们用范围条件而不是相等条件检索数据, 并请求共享或排他锁时, InnoDB会给符合条件的已有数据的索引项加锁;对于键值在条件范围内但并不存在的记录, 叫做“间隙(GAP)”, InnoDB也会对这个“间隙”加锁, 这种锁机制就是间隙锁(Next-Key锁).

举例来说, 假如emp表中只有101条记录, 其empid的值分别是1,2,...,100,101, 下面的SQL:

```mysql
SELECT * FROM emp WHERE empid > 100 FOR UPDATE
```

是一个范围条件的检索, InnoDB不仅会对符合条件的empid值为101的记录加锁, 也会对empid大于101(这些记录并不存在)的“间隙”加锁.

InnoDB使用间隙锁的目的, 一方面是为了防止幻读, 以满足相关隔离级别的要求, 对于上面的例子, 要是不使用间隙锁, 如果其他事务插入了empid大于100的任何记录, 那么本事务如果再次执行上述语句, 就会发生幻读;另一方面, 是为了满足其恢复和复制的需要.有关其恢复和复制对机制的影响, 以及不同隔离级别下InnoDB使用间隙锁的情况.

很显然, 在使用范围条件检索并锁定记录时, InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入, 这往往会造成严重的锁等待.因此, 在实际开发中, 尤其是并发插入比较多的应用, 我们要尽量优化业务逻辑, 尽量使用相等条件来访问更新数据, 避免使用范围条件.



## MySQL 遇到的问题

### MySQL 索引与字段的关系

在做 Quartz 的练习时, 需要创建 Quartz 需要用到的表, 但是在执行 SQL 的过程中报出如下错误

**Error : Specified key was too long; max key length is 767 bytes**

这句话的意思是索引的最大长度为767字节(byte), 而我得索引列长度超过了767字节, 所以报出上述的错误, 接下来我们具体分析一下这个错误

首先看一下建表语句

```mysql
CREATE TABLE QRTZ_JOB_DETAILS(
    SCHED_NAME VARCHAR(120) NOT NULL,
    JOB_NAME VARCHAR(200) NOT NULL,
    JOB_GROUP VARCHAR(200) NOT NULL,
    DESCRIPTION VARCHAR(250) NULL,
    JOB_CLASS_NAME VARCHAR(250) NOT NULL,
    IS_DURABLE VARCHAR(1) NOT NULL,
    IS_NONCONCURRENT VARCHAR(1) NOT NULL,
    IS_UPDATE_DATA VARCHAR(1) NOT NULL,
    REQUESTS_RECOVERY VARCHAR(1) NOT NULL,
    JOB_DATA BLOB NULL,
	PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)
)ENGINE=InnoDB;
```

我们可以看到这个建表语句创建了一个复合索引**PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)**, 我创建数据库的时候使用的是utf8mb4字符集, **一个字符会占用4个字节**, 而3个字段的长度是120 + 200 + 200 = 520, 复合索引的长度是2080字节, 单个索引的长度分别是480, 800, 800字节

**经过查阅得知, MySQL在创建单个字段索引时, 主要的限制是字段长度, 如果单个字段长度不超过767字节, 不会出现问题但复合索引的情况与单字段索引有所不同. 复合索引中除了单字段长度不能超过767字节外, 索引中所有字段长度的总合不能超过3072字节. **

#### 测试单列索引的情况

首先修改创建表的语句如下

```mysql
CREATE TABLE QRTZ_JOB_DETAILS(
    SCHED_NAME VARCHAR(120) NOT NULL,
    JOB_NAME VARCHAR(200) NOT NULL,
    JOB_GROUP VARCHAR(200) NOT NULL,
    DESCRIPTION VARCHAR(250) NULL,
    JOB_CLASS_NAME VARCHAR(250) NOT NULL,
    IS_DURABLE VARCHAR(1) NOT NULL,
    IS_NONCONCURRENT VARCHAR(1) NOT NULL,
    IS_UPDATE_DATA VARCHAR(1) NOT NULL,
    REQUESTS_RECOVERY VARCHAR(1) NOT NULL,
    JOB_DATA BLOB NULL
)ENGINE=InnoDB;
```

**首先我们为 SCHED_NAME 添加主键索引**

```mysql
mysql [quartz_db]> ALTER TABLE `QRTZ_JOB_DETAILS` ADD PRIMARY KEY `idx_details_sn` (SCHED_NAME) COMMENT '单一varchar字段的索引, 不指定索引前缀的长度';
Query OK, 0 rows affected (0.009 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

可以看到语句执行成功了, 因为 SCHED_NAME 的长度是 120 个字符, 1个字符占用4字节, 4 * 120 = 480 < 767 可以创建成功

**接下来我们为 JOB_NAME 添加主键索引**

```mysql
mysql [quartz_db]> ALTER TABLE `QRTZ_JOB_DETAILS` ADD PRIMARY KEY `idx_details_jn` (JOB_NAME) COMMENT '单一varchar字段的索引, 不指定索引前缀的长度';
ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes
```

可以看到语句并没有执行成功, 而是说索引列太长了, 不能超过 767 个字节, 因为 JOB_NAME 字段时200个字符, 1 个字符占用4字节, 4 * 200 = 800, 所以创建失败

**接下来我们为 JOB_NAME 添加前缀主键索引**

```mysql
mysql [quartz_db]> ALTER TABLE `QRTZ_JOB_DETAILS` ADD PRIMARY KEY `pre_idx_details_jn` (JOB_NAME(190)) COMMENT '单一varchar字段的索引, 指定索引前缀的长度为190个字符';
Query OK, 0 rows affected (0.010 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

这次我们依旧是使用 JOB_NAME 字段创建索引, **但是在创建索引的时候指定了索引前缀**, 即只使用 JOB_NAME 列的前190个字符进行索引, 190 * 4 = 760 < 767, 所以创建成功

#### 测试复合索引的情况

为了方便测试, 我们在添加几个字段

```mysql
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t1 VARCHAR(150);
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t2 VARCHAR(150);
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t3 VARCHAR(150);
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t4 VARCHAR(150);
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t5 VARCHAR(150);
```

**首先我们为 SCHED_NAME, t1, t2, t3 创建复合主键索引**

```mysql
mysql [quartz_db]> ALTER TABLE QRTZ_JOB_DETAILS ADD PRIMARY KEY idx_details_snt1t2t3(SCHED_NAME, t1, t2, t3);
Query OK, 0 rows affected (0.026 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

可以看到语句执行成功了, 因为 SCHED_NAME 的长度是 120 个字符, 1 个字符占用 4 字节, 4 * 120 = 480 < 767 可以创建成功, 4 列的字符数分别是, 120, 150, 150, 150, 均满足单列字节不超过767的限制, 总的字节数是 (120 + 150 + 150 + 150) * 4 = 2280 < 3072, 也满足总长度不超过3072字节

**接下来我们为 JOB_NAME, t1, t2, t3 创建复合主键索引**

```mysql
mysql [quartz_db]> ALTER TABLE QRTZ_JOB_DETAILS ADD PRIMARY KEY idx_details_snt1t2t3(JOB_NAME, t1, t2, t3);
ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes
```

这次添加失败了, 因为 JOB_NAME 是200个字符, 200 * 4 = 800 > 767, 复合索引中的某一列的字节数超过限制, 索引创建失败

接下来我们为 SCHED_NAME, t1, t2, t3, t4, t5 创建复合主键索引

```mysql
mysql [quartz_db]> ALTER TABLE QRTZ_JOB_DETAILS ADD PRIMARY KEY idx_details_snt1t2t3(JOB_NAME, t1, t2, t3, t4, t5);
ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes
```

显然这次也会失败了, 虽然 SCHED_NAME, t1, t2, t3, t4, t5 的单列长度均没有超出767的长度限制, 但是总的长度 120 + 150 + 150 + 150 + 150 + 150 = 870 * 4 = 3480 > 3072, 所以超出了总长度的限制

#### 总结

通过上面一系列的试验, 我们明确知道 MySQL 创建索引时, 单字段索引的字段长度不能超过 767 字节, 超过时需要指定索引前缀;创建复合索引时, 单字段长度不能超过 767 字节, 且索引中所有字段的总长度不能超过 3072 字节, **违反这些约束时需要删减字段或是为长度较大的字段指定索引前缀或者修改字符集**. 在MySQL 5.6.28 中, 字符类型的长度指的是字符数, 而不是字节数, 每个字符占用的字节数和使用的字符集相关



### MySQL 存储 emoji 表情

在存储用户昵称时遇到如下错误

```mysql
java.sql.SQLException: Incorrect string value: ‘\xF0\x9F\x92\x94’ for colum n ‘name’ at row 1 
```

使用 mysql 数据库的时候, 如果字符集是 UTF-8 并且在 java 服务器上, 当存储 emoji 表情的时候, 会抛出以上异常(比如微信开发获取用户昵称, 有的用户的昵称用的是 emoji 的图像)

这是由于 mysql 字符集不支持的异常导致的, **在 mysql 中的 utf-8 字符集最多只支持3个字节的存储, 如果一个字符的 utf8 编码占用 4 个字节(最常见的就是ios 中的 emoji 表情字符), 那么在写入数据库时就会报错**

mysql从5.5.3版本开始, 才支持4字节的utf8编码, 编码名称为utf8mb4(mb4的意思是max bytes 4), 这种编码方式最多用4个字节存储一个字符. 

因此, 要解决上述异常的发生, 需要使用utf8mb4编码. 

解决数据库编码后, 还需要解决客户端Connection连接对象使用的编码问题. 

#### 解决方式(三种)

从数据库层面进行解决(mysql支持utf8mb4的版本是5.5.3+, 必须升级到较新版本)

1. 修改database, table, column字符集

    ```mysql
    ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci; 
    ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 
    ALTER TABLE table_name CHANGE column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
    ```

1. 修改mysql配置文件my.cnf

    ```mysql
    [client] 
    default-character-set = utf8mb4 
    [mysql] 
    default-character-set = utf8mb4 
    [mysqld] 
    character-set-client-handshake = FALSE 
    character-set-server = utf8mb4 
    collation-server = utf8mb4_unicode_ci 
    init_connect=’SET NAMES utf8mb4’
    ```

1. 用的是java服务器, 升级或者确保mysql connection版本高于5.1.13否则仍然不能试用utf8mb4 

1. 服务器端的db配置文件

    ```properties
    jdbc.driverClassName=com.mysql.jdbc.Driver 
    jdbc.url=jdbc:mysql://localhost:3306/database?useUnicode=true&characterEncoding=utf8&autoReconnect=true&rewriteBatchedStatements=TRUE 
    jdbc.username=root 
    jdbc.password=password
    ```

    如果升级了mysql-connector, 其中的characterEncoding=utf8可以自动被识别为utf8mb4(兼容原来的utf8), 而 autoReconnection(当数据库连接异常中断时, 是否自动重新连接？默认为false)强烈建议配上, 忽略这个属性, 可能导致缓存缘故, 没有读取到DB最新的配置, 导致一直无法试用utf8mb4字符集;

修改数据库连接池配置

- 如果项目中使用了DataSource数据源, 只需要对数据源进行相关配置即可, 这里以apache的DBCP数据源为例讲解, 在spring框架下配置如下:

    ```xml
    <!-- 数据源 -->
    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
    	<property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
    	<property name="url" value="jdbc:mysql://${${data-source.prefix}.data-source.host-name}:3306/${${data-source.prefix}.data-source.db-name}?characterEncoding=utf8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10&amp;allowMultiQueries=true" />
    	<property name="username" value="${${data-source.prefix}.data-source.username}" />
    	<property name="password" value="${${data-source.prefix}.data-source.password}" />
    	<property name="maxActive" value="150" />
    	<property name="maxIdle" value="2" />
    	<property name="testOnBorrow" value="true" />
    	<property name="testOnReturn" value="true" />
    	<property name="testWhileIdle" value="true" />
    	<property name="validationQuery" value="select 1" />
    	<!-- 此配置用于在创建Connection对象时执行指定的初始化sql -->
    	<property name="connectionInitSqls">
    		<list>
    			<value>set names 'utf8mb4'</value>
    		</list>
    	</property>
    </bean>
    ```

- 在springcloud项目中进行配置

    ```yaml
    spring:
      datasource:
        connection-init-sqls: set names 'utf8mb4'
    ```

- 该设置的解释引用自mysql参考手册:

    ```mysql
    SET NAMES 'charset_name';
    
    SET NAMES显示客户端发送的SQL语句中使用什么字符集. 
    
    因此, SET NAMES 'utf8mb4'语句告诉服务器:“将来从这个客户端传来的信息采用字符集utf8mb4”. 它还为服务器发送回客户端的结果指定了字符集. (例如, 如果你使用一个SELECT语句, 它表示列值使用了什么字符集. )
    
    SET NAMES 'x'语句与这三个语句等价:
    
    mysql> SET character_set_client = x;
    
    mysql> SET character_set_results = x;
    
    mysql> SET character_set_connection = x;
    ```

从应用层的方面进行解决 

1. 在获得数据之后往数据库存之前先进行编码:

    ```java
    URLEncoder.encode(nickName, “utf-8”);
    ```

1. 当从数据库中取出准备显示的时候进行解码, 

    ```java
    URLDecoder.decode(nickname, “utf-8”); 
    ```

从应用层进行解决的时候建议不要在对象getter, setter方法中直接编码, 因为放入对象的时候setter方法将nickname进行编码, 当插入数据库的时候相当于从对象中调用getter方法将你参考取出这就将之前setter编码过的nickname又重新解码了, 等于未对Nickname进行任何操作. 依然会出现以上问题. 



### Mysql中自增字段(AUTO_INCREMENT)的一些常识

在系统开发过程中, 我们经常要用到唯一编号. 使用过mysql的人都应该知道, mysql有一个定义列为自增的属性:AUTO_INCREMENT. 

指定了AUTO_INCREMENT的列必须要建索引, 不然会报错, 索引可以为主键索引, 当然也可以为非主键索引. **(不一定要做主键)**

```mysql
mysql> create table user (id int auto_increment);
ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key
```

下面的定义把user表的主键定义为了name, 而非自增的id字段

```mysql
mysql> create table user (id int auto_increment,name varchar(20) primary key,key(id)); 
Query OK, 0 rows affected (0.01 sec)
```

#### 指定了 auto_increment 的列

- 如果把一个 NULL 插入到一个AUTO_INCREMENT数据列里去, MySQL 将自动生成下一个序列编号. 编号从 1 开始, 并1  为基数递增. 

- 当插入记录时, 没有为 AUTO_INCREMENT 明确指定值, 则等同插入 NULL 值. 

    ```mysql
    mysql> insert into user (id, name) values (null,'test');
    Query OK, 1 row affected (0.00 sec)
        
    mysql> select * from user;
    +----+------+
    | id | name |
    +----+------+
    |  1 | test |
    +----+------+
    1 row in set (0.00 sec)
    ```

    上面语句等同于下面语句:

    ```mysql
    insert into user (name) values ('test');
    ```

- 当插入记录时, 如果为 AUTO_INCREMENT 字段明确指定了一个数值, 则会出现两种情况:

    - **如果插入的值与已有的编号重复, 则会出现出 错信息, 因为AUTO_INCREMENT数据列的值必须是唯一的**
    - **如果插入的值大于已编号的值, 则会把该插入到数据列中, 并使在下一个编号将从这个新值开始递增. **

    **总结一句话就是auto_increment会从最后一次insert语句开始递增**

    - **如果在小于AUTO_INCREMENT字段上插入一个小于AUTO_INCREMENT的值, 比如当前AUTO_INCREMENT是50, 我插入一个47的值, 那再往后插入的值还是从50开始的, 并不会受之前的插入操作影响**

- 当更新AUTO_INCREMENT字段时, 根据存储引擎的不同, 会出现两种情况:

    - **对于MyISAM表, 如果用UPDATE命令更新自增列, 如果列值与已有的值重复, 则会出错. 如果大于已有值, 则下一个编号从该值开始递增****
    - **对于Innodb表, update auto_increment字段, 可能会导致发生报错, 如果将一个id更新为12, 当前AUTO_INCREMEN是10并不会发生变化, Innodb表继续插入记录, 当主键插入到12时会发生报错, 但只会报错一次, 跳过12之后会正常插入**

- 被delete语句删除的id值, 除非sql中将id重新插入, 否则前面空余的id不会复用. 

    - **当前AUTO_INCREMENT=30, delete掉id为10的记录, 下一次插入会是31, 并不会复用空余的10**

- truncate table user 该语句会引起auto_increment的变化, 从头开始. 

- 修改AUTO_INCREMENT字段的起始值

    - **可用alter table table_name AUTO_INCREMENT=n命令来重设自增的起始值. **
    - **但是如果设置的 n 比目前的数值小的话, 执行的 sql 不会报错, 但是不会生效! MyISAM 和 Innodb 均是如此. **

### MySQL 插入语句 insert ignore, insert into 和 replace into 区别

我们先把结论贴出来

| 指令          | 已存在       | 不存在 | 不存在                                                  |
| ------------- | ------------ | ------ | ------------------------------------------------------- |
| insert        | 报错         | 插入   | insert into names(name, age) values(“小明”, 23);        |
| insert ignore | 忽略         | 插入   | insert ignore into names(name, age) values(“小明”, 24); |
| replace       | 先删除再插入 | 插入   | replace into names(name, age) values(“小明”, 25);       |

表要求:**有 PrimaryKey, 或者 unique 索引** 

结果:**表 id 都会自增**

#### 创建测试环境

创建表

```mysql
CREATE TABLE names(
    id INT(10) PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) UNIQUE,
    age INT(10)
)
```

插入数据

```mysql
mysql> insert into names(name, age) values("小明", 24);
mysql> insert into names(name, age) values("大红", 24);
mysql> insert into names(name, age) values("大壮", 24);
mysql> insert into names(name, age) values("秀英", 24);

mysql> select * from names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  1 | 小明   |   24 |
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
+----+--------+------+
```

#### 测试 Insert

插入已存在, id会自增, 但是插入不成功, 会报错

```
mysql> insert into names(name, age) values("小明", 23);

ERROR 1062 (23000): Duplicate entry '小明' for key 'name'
```

提示我们插入失败, 因为'name'字段冲突了

#### 测试 replace

表示插入替换数据, 需求表中有 PrimaryKey, 或者 unique 索引的话, 如果数据库已经存在数据, 则用新数据替换, 如果没有数据效果则和 insert into 一样; 
REPLACE 语句会返回一个数, 来指示受影响的行的数目. 该数是被删除和被插入的行数的和. 如果对于一个单行 REPLACE 该数为 1, 则一行被插入, 同时没有行被删除. 如果该数大于 1, 则在新行被插入前, 有一个或多个旧行被删除. 如果表包含多个唯一索引, 并且新行复制了在不同的唯一索引中的不同旧行的值, 则有可能是一个单一行替换了多个旧行. 

```mysql
mysql> replace into names(name, age) values("小明", 23);
Query OK, 2 rows affected (0.00 sec)

mysql> select * from names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
|  6 | 小明   |   23 |
+----+--------+------+
```

id为1的记录被删除了, 新增的记录id是6, name是小名, replace会先删除已经存在的记录, 在创建新的记录, 而id为6是之前insert时id会自增

**不存在替换, 添加新的记录**

```mysql
mysql> replace into names(name, age) values("大名", 23);
Query OK, 1 row affected (0.00 sec)

mysql> select * from names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
|  6 | 小明   |   23 |
|  7 | 大名   |   23 |
+----+--------+------+
```

这次没有重复的记录, 直接添加id为7的记录

#### insert ignore

**插入已存在, 忽略新插入的记录, id会自增, 不会报错**

```mysql
mysql> insert ignore into names(name, age) values("大壮", 25);
Query OK, 0 rows affected, 1 warning (0.00 sec)
```

大壮是已经存在的记录, 但是并没有报错, 而是忽略这一条记录, 当我们进行批量插入的时候, 也可以使用insert ingore避免主键冲突对其他插入语句的影响

**插入不存在, 添加新的记录**

```mysql
mysql> insert ignore into names(name, age) values("壮壮", 25);
Query OK, 1 row affected (0.01 sec)

mysql> select * from  names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
|  6 | 小明   |   23 |
|  7 | 大名   |   23 |
|  9 | 壮壮   |   25 |
+----+--------+------+
```

这次没有重复的记录, 壮壮可以直接插入进来, 并且id自增了



## 一条 sql 的执行过程

客户端发送一条查询给服务器. 

服务器先检查查询缓存, 如果命中了缓存, 则立刻返回存储在缓存中的结果. 否则进入下一阶段. 

服务器端进行 SQL 解析、预处理, 再由优化器生成对应的执行计划. 

MySQL 根据优化器生成的执行计划, 再调用存储引擎的 API 来执行查询. 

将结果返回给客户端. 

### MySQL 基本架构概览

下图是 MySQL 的一个简要架构图, 从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的. 

先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图, 在 1.2 节中会详细介绍到这些组件的作用. 

-   连接器： 身份认证和权限相关(登录 MySQL 的时候). 
-   查询缓存: 执行查询语句的时候, 会先查询缓存(MySQL 8.0 版本后移除, 因为这个功能不太实用). 
-   分析器: 没有命中缓存的话, SQL 语句就会经过分析器, 分析器说白了就是要先看你的 SQL 语句要干嘛, 再检查你的 SQL 语句语法是否正确. 
-   优化器： 按照 MySQL 认为最优的方案去执行. 
-   执行器: 执行语句, 然后从存储引擎返回数据. 

<img src="http://www.milky.show/images/database/mysql/mysql_1.png" alt="http://www.milky.show/images/database/mysql/mysql_1.png" style="zoom: 67%;" />

<img src="http://www.milky.show/images/database/mysql/mysql_2.png" alt="http://www.milky.show/images/database/mysql/mysql_2.png" style="zoom: 33%;" />

简单来说 MySQL 主要分为 Server 层和存储引擎层：

-   Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等, 所有跨存储引擎的功能都在这一层实现, 比如存储过程、触发器、视图, 函数等, 还有一个通用的日志模块 binglog 日志模块. 
-   存储引擎： 主要负责数据的存储和读取, 采用可以替换的插件式架构, 支持 InnoDB、MyISAM、Memory 等多个存储引擎, 其中 InnoDB 引擎有自有的日志模块 redolog 模块. 现在最常用的存储引擎是 InnoDB, 它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了. 

### Server 层基本组件介绍

#### 连接器

连接器主要和身份认证和权限相关的功能相关, 就好比一个级别很高的门卫一样. 

主要负责用户登录数据库, 进行用户的身份认证, 包括校验账户密码, 权限等操作, 如果用户账户密码已通过, 连接器会到权限表中查询该用户的所有权限, 之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据, 也就是说, 后续只要这个连接不断开, 即时管理员修改了该用户的权限, 该用户也是不受影响的. 

SQL客户端与与服务器建立连接, 该请求被发送到连接管理器, 连接成功后会验证权限等, 这过程其实就是一个TCP连接的过程. 注意, MySQL服务器与客户端之间的通信是“半双工”的, 意味着任意时刻, 要么是服务器向客户端发送数据, 要什么是客户端向服务器发送数据(请求), 不能同时进行. 
查看连接状态：SHOW FULL PROCESSLIST命令来查看MySQL正在做什么, 如：

```
sleep：线程正在等待客户端发起新的请求
query：正在执行查询或者将数据返回给客户端
locked：该线程正在等待表锁(实现锁是在存储引擎中)
analyzing and statistics：线程正在收集存储引擎的统计信息, 并生产相应的查询计划
copying to tmp table：线程正在查询, 并将结果放到一个临时表中, 这时候一般是在做group bu操作
sorting result：对结果集进行排序
sending data：线程可能在多个状态之间传递数据, 或者正在生成结果集, 或是在返回数据, 有多种情况
```



#### 查询缓存(MySQL 8.0 版本后移除)

查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集. 如果查询命中缓存(一个大小写敏感的哈希查找实现的)则直接返回结果(注意：在返回结果前还会检查一次用户号的权限)；如果查询没有命中缓存, 则进行下一步sql解析. 

连接建立后, 执行查询语句的时候, 会先查询缓存, MySQL 会先校验这个 sql 是否执行过, 以 Key-Value 的形式缓存在内存中, Key 是查询预计, Value 是结果集. 如果缓存 key 被命中, 就会直接返回给客户端, 如果没有命中, 就会执行后续的操作, 完成后也会把结果缓存起来, 方便下一次调用. 当然在真正执行缓存查询的时候还是会校验用户的权限, 是否有该表的查询条件. 

MySQL 查询不建议使用缓存, 因为查询缓存失效在实际业务场景中可能会非常频繁, 假如你对一个表更新的话, 这个表上的所有的查询缓存都会被清空. 对于不经常更新的数据来说, 使用缓存还是可以的. 

所以, 一般在大多数情况下我们都是不推荐去使用查询缓存的. 

MySQL 8.0 版本后删除了缓存的功能, 官方也是认为该功能在实际的应用场景比较少, 所以干脆直接删掉了. 

#### 分析器

MySQL 没有命中缓存, 那么就会进入分析器, 分析器主要是用来分析 SQL 语句是来干嘛的, 分析器也会分为几步：

第一步, 词法分析, 一条 SQL 语句有多个字符串组成, 首先要提取关键字, 比如 select, 提出查询的表, 提出字段名, 提出查询条件等等. 做完这些操作后, 就会进入第二步. 

第二步, 语法分析, 主要就是判断你输入的 sql 是否正确, 是否符合 MySQL 的语法. 

完成这 2 步之后, MySQL 就准备开始执行了, 但是如何执行, 怎么执行是最好的结果呢？这个时候就需要优化器上场了. 

首先通过mysql关键字将语句解析, 会生成一个内部解析树, mysql解析器将对其解析, 查看是否是有错误的关键字, 关键字顺序是佛正确；
预处理器则是根据mysql的规则进行进一步的检查, 检查mysql语句是否合法, 如, 库表是否存在, 字段是否存在, 字段之间是否模棱两可等等, 预处理器也会验证权限. 

#### 优化器

优化器的作用就是它认为的最优的执行方案去执行(有时候可能也不是最优, 这篇文章涉及对这部分知识的深入讲解), 比如多个索引的时候该如何选择索引, 多表查询的时候如何选择关联顺序等. 

可以说, 经过了优化器之后可以说这个语句具体该如何执行就已经定下来. 

sql语句在优化器中转换成执行计划, 一条sql语句可以有多种方式查询, 最后返回的结果肯定是相同, 但是不同的查询方式效果不同, 优化器的作用就是：选择一种合适的执行计划
mysql是基于成本的优化器, 他将预测执行此计划的成本, 并选择成本最小的那条

#### 执行器

当选择了执行方案后, MySQL 就准备开始执行了, 首先执行前会校验该用户有没有权限, 如果没有权限, 就会返回错误信息, 如果有权限, 就会去调用引擎的接口, 返回接口执行的结果. 



### 语句分析

#### 查询语句

说了以上这么多, 那么究竟一条 sql 语句是如何执行的呢？其实我们的 sql 可以分为两种, 一种是查询, 一种是更新(增加, 更新, 删除). 我们先分析下查询语句, 语句如下：

```sql
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
```

结合上面的说明, 我们分析下这个语句的执行流程：

先检查该语句是否有权限, 如果没有权限, 直接返回错误信息, 如果有权限, 在 MySQL8.0 版本以前, 会先查询缓存, 以这条 sql 语句为 key 在内存中查询是否有结果, 如果有直接缓存, 如果没有, 执行下一步. 

通过分析器进行词法分析, 提取 sql 语句的关键元素, 比如提取上面这个语句是查询 select, 提取需要查询的表名为 tb_student,需要查询所有的列, 查询条件是这个表的 id=‘1’. 然后判断这个 sql 语句是否有语法错误, 比如关键词是否正确等等, 如果检查没问题就执行下一步. 

接下来就是优化器进行确定执行方案, 上面的 sql 语句, 可以有两种执行方案：

```sql
a. 先查询学生表中姓名为“张三”的学生, 然后判断是否年龄是 18. 
b. 先找出学生中年龄 18 岁的学生, 然后再查询姓名为“张三”的学生. 
```

那么优化器根据自己的优化算法进行选择执行效率最好的一个方案(优化器认为, 有时候不一定最好). 那么确认了执行计划后就准备开始执行了. 

进行权限校验, 如果没有权限就会返回错误信息, 如果有权限就会调用数据库引擎接口, 返回引擎的执行结果. 

#### 更新语句

以上就是一条查询 sql 的执行流程, 那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：

```sql
update tb_student A set A.age='19' where A.name=' 张三 ';
```

我们来给张三修改下年龄, 在实际数据库肯定不会设置年龄这个字段的, 不然要被技术负责人打的. 其实条语句也基本上会沿着上一个查询的流程走, 只不过执行更新的时候肯定要记录日志啦, 这就会引入日志模块了, MySQL 自带的日志模块式 binlog(归档日志) , 所有的存储引擎都可以使用, 我们常用的 InnoDB 引擎还自带了一个日志模块 redo log(重做日志), 我们就以 InnoDB 模式下来探讨这个语句的执行流程. 流程如下：

-   先查询到张三这一条数据, 如果有缓存, 也是会用到缓存. 
-   然后拿到查询的语句, 把 age 改为 19, 然后调用引擎 API 接口, 写入这一行数据, InnoDB 引擎把数据保存在内存中, 同时记录 redo log, 此时 redo log 进入 prepare 状态, 然后告诉执行器, 执行完成了, 随时可以提交. 
-   执行器收到通知后记录 binlog, 然后调用引擎接口, 提交 redo log 为提交状态. 
-   更新完成. 

这里肯定有同学会问, 为什么要用两个日志模块, 用一个日志模块不行吗?

这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) , MySQL 自带的引擎是 MyISAM, 但是我们知道 redo log 是 InnoDB 引擎特有的, 其他存储引擎都没有, 这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启, 之前提交的记录都不会丢失), binlog 日志只能用来归档. 

并不是说只用一个日志模块不可以, 只是 InnoDB 引擎就是通过 redo log 来支持事务的. 那么, 又会有同学问, 我用两个日志模块, 但是不要这么复杂行不行, 为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？

-   先写 redo log 直接提交, 然后写 binlog, 假设写完 redo log 后, 机器挂了, binlog 日志没有被写入, 那么机器重启后, 这台机器会通过 redo log 恢复数据, 但是这个时候 bingog 并没有记录该数据, 后续进行机器备份的时候, 就会丢失这一条数据, 同时主从同步也会丢失这一条数据. 
-   先写 binlog, 然后写 redo log, 假设写完了 binlog, 机器异常重启了, 由于没有 redo log, 本机是无法恢复这一条记录的, 但是 binlog 又有记录, 那么和上面同样的道理, 就会产生数据不一致的情况. 

如果采用 redo log 两阶段提交的方式就不一样了, 写完 binglog 后, 然后再提交 redo log 就会防止出现上述的问题, 从而保证了数据的一致性. 那么问题来了, 有没有一个极端的情况呢？假设 redo log 处于预提交状态, binglog 也已经写完了, 这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了, MySQL 的处理过程如下：

-   判断 redo log 是否完整, 如果判断是完整的, 就立即提交. 
-   如果 redo log 只是预提交但不是 commit 状态, 这个时候就会去判断 binlog 是否完整, 如果完整就提交 redo log, 不完整就回滚事务. 

这样就解决了数据一致性的问题. 

<img src="http://www.milky.show/images/database/mysql/mysql_3.png" alt="http://www.milky.show/images/database/mysql/mysql_3.png" style="zoom: 50%;" />



### 总结

MySQL 主要分为 Server 层和引擎层, Server 层主要包括连接器、查询缓存、分析器、优化器、执行器, 同时还有一个日志模块(binlog), 这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有. 

引擎层是插件式的, 目前主要包括, MyISAM,InnoDB,Memory 等. 

SQL 等执行过程分为两类, 一类对于查询等过程如下：权限校验 -> 查询缓存 -> 分析器 -> 优化器 -> 权限校验 -> 执行器 -> 引擎

对于更新等语句执行流程如下：分析器----> 权限校验----> 执行器 -> 引擎 - redo log prepare -> binlog -> redo log commit



[https://juejin.im/post/6844903655439597582](https://juejin.im/post/6844903655439597582)

[https://www.cnblogs.com/lfri/p/12598339.html](https://www.cnblogs.com/lfri/p/12598339.html)

