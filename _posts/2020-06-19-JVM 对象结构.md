---
layout: post
title: "JVM 对象结构"
categories: [Java]
description:
keywords:
---

* content
{:toc}

## 对象内存布局

在 HotSpot 虚拟机中，对象的内存布局分为以下 3 块区域：

* 对象头（Header）

    * 自身运行时数据(Mark Word)(4字节)

        * 哈希值, GC分代年龄, 锁状态标识, 线程持有的锁, 偏向线程id, 偏向时间戳

    * Class 对象指针(4字节)

* 实例数据（Instance Data）

    * 相同宽度的字段会被分配到一起, Long/Double short/char

    * 对象实际数据(实际数据大小)

* 对齐填充（Padding）

    * 对齐可选(按8字节对齐), 填充内存, 无实际意义



JOL = Java Object Layout(Java 对象内存布局)

在堆内存中 new 出来一个对象, 这个对象在堆中分为四个部分

1. markword, 8 个字节, synchronized(o) 锁定对象的本质是修改了 markword, **使 markword 包含了锁的信息**, 我们平时所说的加锁, 就是修改对象的 markword 的内容

    *   锁信息, 无锁态, 偏向锁...
    *   GC 标记信息
    *   HashCode

    <img src="http://www.milky.show/images/mashibing/synchronized/syn_2.png" alt="http://www.milky.show/images/mashibing/synchronized/syn_2.png" style="zoom:50%;" />

2. klass poniter, 是一个指针, 指向 T.class, 表名这个对象属于哪一个 class, 压缩是 4 字节, 不压缩是 8 字节

3. instance state, 成员变量所占的位置, byte, short, int, long...

4. padding, 对齐, 64 位虚拟机 padding 是需要 4 块内容可以被 8 字节整除, 如果前 3 块不能被 8 整除, 就用 padding 补齐

<img src="http://www.milky.show/images/mashibing/synchronized/syn_1.png" alt="http://www.milky.show/images/mashibing/synchronized/syn_1.png" style="zoom: 33%;" />



### 对象头

对象头记录了对象在运行过程中所需要使用的一些数据：

* 哈希码

* GC 分代年龄

* 锁状态标志

* 线程持有的锁

* 偏向线程 ID

* 偏向时间戳

对象头可能包含类型指针，通过该指针能确定对象属于哪个类。如果对象是一个数组，那么对象头还会包括数组长度。



### 实例数据

实例数据部分就是成员变量的值，其中包括父类成员变量和本类成员变量。



### 对齐填充

用于确保对象的总长度为 8 字节的整数倍。

HotSpot VM 的自动内存管理系统要求对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

**对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。**



## 对象的创建过程

1. 类加载检查

    虚拟机在解析 .class文件时，若遇到一条 new 指令，首先它会去检查常量池中是否有这个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。

1. 为新生对象分配内存

    对象所需内存的大小在类加载完成后便可完全确定，接下来从堆中划分一块对应大小的内存空间给新的对象。分配堆中内存有两种方式：

    * 指针碰撞

        如果 Java 堆中内存绝对规整（说明采用的是“复制算法”或“标记整理法”），空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大小一样的距离，这种分配方式称为“指针碰撞”。

    * 空闲列表

        如果 Java 堆中内存并不规整，已使用的内存和空闲内存交错（说明采用的是标记-清除法，有碎片），此时没法简单进行指针碰撞， VM 必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划分给对象实例。这种方式称为“空闲列表”。

1. 初始化

    分配完内存后，为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。

至此，整个对象的创建过程就完成了。

## 对象访问定位方式

所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。也就是说在建立一个对象时两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针（引用）而已。 那么根据引用存放的地址类型的不同，对象有不同的访问方式。

* 句柄访问方式

    堆中需要有一块叫做“句柄池”的内存空间，句柄中包含了对象实例数据与类型数据各自的具体地址信息。

    引用类型的变量存放的是该对象的句柄地址（reference）。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址找到对象。

* 直接指针访问方式

    引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。但对象所在的内存空间需要额外的策略存储对象所属的类信息的地址。

**需要说明的是，HotSpot 采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要额外的策略来存储对象在方法区中类信息的地址。**



