---
layout: post
title: "多线程"
categories: [Java]
description:
keywords:
---

* content
{:toc}
## 多线程的实现方式

* 方式一: 继承 Thread 类, 重写 run 方法

* 方式二: 实现 Runnable 接口, 作为参数构造 Thread 类

* 方式三: 实现 Callable 接口, 相较于实现 Runnable 接口的方式, 方法可以有返回值, 并且可以抛出异常, 该方法需要 FutureTask 类配合使用, new Thread 只能接收 Runnable 对象, FutureTask 实现了 Runnable 接口, 可以对 Callable 进行封装

* 方式四: 线程池

## 解决线程安全问题:

* 方式一: 同步代码块

* 方式二: 同步方法

* 方式三: 1.5 以后出现的同步锁(Lock)

## 线程状态转换

<img src="http://www.milky.show/images/java/thread/t_1.png" alt="http://www.milky.show/images/java/thread/t_1.png" style="zoom: 50%;" />

<img src="http://www.milky.show/images/java/thread/t_2.png" alt="http://www.milky.show/images/java/thread/t_2.png" style="zoom: 50%;" />

<img src="http://www.milky.show/images/java/thread/t_3.png" alt="http://www.milky.show/images/java/thread/t_3.png" style="zoom: 50%;" />

1. **新建(NEW**): 新创建了一个线程对象. 
2. **运行(RUNNABLE)**：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
    线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
3. **阻塞(BLOCKED)**: 阻塞状态是指线程因为某种原因放弃了 cpu 使用权, 也即让出了cpu timeslice, 暂时停止运行. 直到线程进入可运行(runnable)状态, 才有机会再次获得 cpu timeslice 转到运行(running)状态. 阻塞的情况分三种:  
    * 等待阻塞: 运行(running)的线程执行 o.wait() 方法, JVM会把该线程放入等待队列(waitting queue)中. 
    * 同步阻塞: 运行(running)的线程在获取对象的同步锁时, 若该同步锁被别的线程占用, 则 JVM 会把该线程放入锁池(lock pool)中. 
    * 其他阻塞: 运行(running)的线程执行 Thread.sleep(long ms) 或 t.join() 方法, 或者发出了 I/O 请求时, JVM 会把该线程置为阻塞状态. 当 sleep() 状态超时、join() 等待线程终止或者超时、或者 I/O 处理完毕时, 线程重新转入可运行(runnable)状态. 
4. **等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5. **超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。
6. **终止(TERMINATED)**: 线程 run()、main() 方法执行结束, 或者因异常退出了 run() 方法, 则该线程结束生命周期. 死亡的线程不可再次复生

这 6 种状态定义在Thread类的State枚举中，可查看源码进行一一对应。



## 一个线程两次调用 start() 方法会出现什么情况

Java 的线程是不允许启动两次的, 第二次调用必然会抛出 IllegalThreadStateException, 这是一种运行时异常, 多次调用 start 被认为是编程错误. 

关于线程生命周期的不同状态, 在 Java 5 以后, 线程状态被明确定义在其公共内部枚举类型 java.lang.Thread.State 中

**在第二次调用 start() 方法的时候, 线程可能处于终止或者其他(非NEW)状态, 但是不论如何, 都是不可以再次启动的**