---
 
layout: post
title: "分布式事务"
categories: [Distributed]
description:
keywords:
---

* content
{:toc}




## 事务

什么是事务？举个生活中的例子：你去小卖铺买东西，“一手交钱，一手交货”就是一个事务的例子，交钱和交货必

须全部成功，事务才算成功，任一个活动失败，事务将撤销所有已成功的活动。

明白上述例子，再来看事务的定义：

事务可以看做是一次大的活动，它由不同的小活动组成，这些活动要么全部成功，要么全部失败。

**对同一数据源, 进行一组相关的 sql 操作, 要么全部成功, 要么全部失败.**



### 本地事务

在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又被称为本地事务。

数据库事务在实现时会将一次事务涉及的所有操作全部纳入到一个不可分割的执行单元，该执行单元中的所有操作要么都成功，要么都失败，只要其中任一操作执行失败，都将导致整个事务的回滚

### 事务的四个特性

原子性(Atomicity): 构成事务的所有操作，要么都执行完成，要么全部不执行，不可能出现部分成功部分失败的情况。

一致性(Consistency): 在事务执行前后，数据库的一致性约束没有被破坏。比如：张三向李四转100元，转账前和转账后的数据是正确状态这叫一致性，如果出现张三转出100元，李四账户没有增加100元这就出现了数据错误，就没有达到一致性。

隔离性(Isolation): 隔离性，数据库中的事务一般都是并发的，隔离性是指并发的两个事务的执行互不干扰，一个事务不能看到其他事务运行过程的中间状态。通过配置事务隔离级别可以避脏读、重复读等问题。

持久性(Durability): 事务完成之后，该事务对数据的更改会被持久化到数据库，且不会被回滚。

### 事务的隔离级别

根据两个事务之间的干扰性强弱, 划分为几个级别

读未提交\读已提交\可重复度\串行化

**脏读**: 事务 a, 读到了事务 b 未提交的数据.

**不可重复度**: 两次读到的数据不一致

**幻读**: 一个事务在查询, 另一个事务在做插入或者删除, 此时就会出现幻读

| 事务的隔离级别                                        | 脏读 | 不可重复读 | 幻读 |
| ----------------------------------------------------- | ---- | ---------- | ---- |
| Read uncommitted                                      | √    | √          | √    |
| Read committed--Sql Server , Oracle                   | ×    | √          | √    |
| Repeatable read--[MySQL](http://lib.csdn.net/base/14) | ×    | ×          | √    |
| Serializable                                          | ×    | ×          | ×    |



## 什么是分布式事务？

分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分事务、创建订单减库存事务，银行转账事务等都是分布式事务。

我们知道本地事务依赖数据库本身提供的事务特性来实现，因此以下逻辑可以控制本地事务：

```sql
begin transaction；
// 1.本地数据库操作：张三减少金额
// 2.本地数据库操作：李四增加金额
commit transation;
```

但是在分布式环境下，会变成下边这样：

```sql
begin transaction；
// 1.本地数据库操作：张三减少金额
// 2.远程调用：让李四增加金额
commit transation;
```

可以设想，当远程调用让李四增加金额成功了，由于网络问题远程调用并没有返回，此时本地事务提交失败就回滚了张三减少金额的操作，此时张三和李四的数据就不一致了。

因此在分布式架构的基础上，传统数据库事务就无法使用了，张三和李四的账户不在一个数据库中甚至不在一个应用系统里，实现转账事务需要通过远程调用，由于网络问题就会导致分布式事务问题。

最终的解决办法是要有一个全局的事务管理器

| 事务类别   | 数据库   | 会话     | 类比     | 事务管理器     |
| ---------- | -------- | -------- | -------- | -------------- |
| 本地事务   | 单数据库 | 单会话   | 单机游戏 | 本地事务管理器 |
| 分布式事务 | 多数据源 | 多个会话 | 斗地主   | 全局事务管理器 |



### 单一服务分布式事务

单体系统访问多个数据库实例 当单体系统需要访问多个数据库（实例）时就会产生分布式事务。 比如：用户信息和订单信息分别在两个MySQL实例存储，用户管理系统删除用户信息，需要分别删除用户信息及用户的订单信息，由于数据分布在不同的数据实例，需要通过不同的数据库链接去操作数据，此时产生分布式事务。 简言之：跨数据库实例产生分布式事务。

可以使用 Atomikos 解决

<img src="http://www.milky.show/images/distributed/transaction/tran_36.png" alt="http://www.milky.show/images/distributed/transaction/tran_36.png" style="zoom:50%;" />

### 分库分表

通过中间件+数据库同步技术, mycat\shardingdb

<img src="http://www.milky.show/images/distributed/transaction/tran_37.png" alt="http://www.milky.show/images/distributed/transaction/tran_37.png" style="zoom:50%;" />

### 多服务多数据源分布式事务

典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作。 比如：订单微服务和库存微服务，下单的同时订单微服务请求库存微服务减库存。 简言之：跨JVM进程产生分布式事务。

全局事务管理器(TM)和服务协调者, 共同协调

<img src="http://www.milky.show/images/distributed/transaction/tran_38.png" alt="http://www.milky.show/images/distributed/transaction/tran_38.png" style="zoom:50%;" />



## 分布式事务基础理论

### CAP 理论

CAP 是 Consistency、Availability、Partition tolerance三个词语的缩写，分别表示一致性、可用性、分区容忍
性。

为了方便对CAP理论的理解，我们结合电商系统中的一些业务场景来理解CAP。如下图，是商品信息管理的执行流程：

![http://www.milky.show/images/distributed/transaction/tran_1.png](http://www.milky.show/images/distributed/transaction/tran_1.png)

整体执行流程如下：

1.  商品服务请求主数据库写入商品信息（添加商品、修改商品、删除商品）
2.  主数据库向商品服务响应写入成功。
3.  商品服务请求从数据库读取商品信息。

**C - Consistency：**

一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都
是最新的状态。
上图中，商品信息的读写要满足一致性就是要实现如下目标：

1.  商品服务写入主数据库成功，则向从数据库查询新数据也成功。
2.  商品服务写入主数据库失败，则向从数据库查询新数据也失败。

如何实现一致性？

1.  写入主数据库后要将数据同步到从数据库。
2.  写入主数据库后，在向从数据库同步期间要将从数据库锁定，待同步完成后再释放锁，以免在新数据写入成功
    后，向从数据库查询到旧的数据。

分布式系统一致性的特点：

1.  由于存在数据同步的过程，写操作的响应会有一定的延迟。
2.  为了保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源。
3.  如果请求数据同步失败的结点则会返回错误信息，一定不会返回旧数据。



**A - Availability ：**

可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误。上图中，商品信息读取满足可用性就是要实现如下目标：

1.  从数据库接收到数据查询的请求则立即能够响应数据查询结果。
2.  从数据库不允许出现响应超时或响应错误。

如何实现可用性？

1.  写入主数据库后要将数据同步到从数据库。
2.  由于要保证从数据库的可用性，不可将从数据库中的资源进行锁定。
3.  即时数据还没有同步过来，从数据库也要返回要查询的数据，哪怕是旧数据，如果连旧数据也没有则可以按照

约定返回一个默认信息，但不能返回错误或响应超时。
分布式系统可用性的特点：

1.  所有请求都有响应，且不会出现响应超时或响应错误。



**P - Partition tolerance ：**

通常分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间
通信失败，此时仍可对外提供服务，这叫分区容忍性。
上图中，商品信息读写满足分区容忍性就是要实现如下目标：

1.  主数据库向从数据库同步数据失败不影响读写操作。
2.  其一个结点挂掉不影响另一个结点对外提供服务。

如何实现分区容忍性？

1.  尽量使用异步取代同步操作，例如使用异步方式将数据从主数据库同步到从数据，这样结点之间能有效的实现
    松耦合。

2.  添加从数据库结点，其中一个从结点挂掉其它从结点提供服务。

分布式分区容忍性的特点：

1.  分区容忍性分是布式系统具备的基本能力。

### CAP 组合方式

**在所有分布式事务场景中不会同时具备CAP三个特性，因为在具备了P的前提下C和A是不能共存的。**

本图分区容忍的含义是：

1.  主数据库通过网络向从数据同步数据，可以认为主从数据库部署在不同的分区，通过网络进行交互。

2.  当主数据库和从数据库之间的网络出现问题不影响主数据库和从数据库对外提供服务。

3.  其一个结点挂掉不影响另一个结点对外提供服务。

如果要实现C则必须保证数据一致性，在数据同步的时候为防止向从数据库查询不一致的数据则需要将从数据库数据锁定，待同步完成后解锁，如果同步失败从数据库要返回错误信息或超时信息。如果要实现A则必须保证数据可用性，不管任何时候都可以向从数据查询数据，则不会响应超时或返回错误信息。通过分析发现在满足P的前提下C和A存在矛盾性。



所以在生产中对分布式事务处理时要根据需求来确定满足CAP的哪两个方面。

1.  AP：

    放弃一致性，追求分区容忍性和可用性。这是很多分布式系统设计时的选择。

    例如：

    上边的商品管理，完全可以实现AP，前提是只要用户可以接受所查询的到数据在一定时间内不是最新的即可。

    通常实现AP都会保证最终一致性，后面讲的BASE理论就是根据AP来扩展的，一些业务场景 比如：订单退款，今

    日退款成功，明日账户到账，只要用户可以接受在一定时间内到账即可。

2.  CP：

    放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致，又比如跨行转账，一次转账请求要等待双方银行系统都完成整个事务才算完成。

3.  CA：

    放弃分区容忍性，即不进行分区，不考虑由于网络不通或结点挂掉的问题，则可以实现一致性和可用性。那么系统将不是一个标准的分布式系统，我们最常用的关系型数据就满足了CA。

**通过上面我们已经学习了CAP理论的相关知识，CAP是一个已经被证实的理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项。它可以作为我们进行架构设计、技术选型的考量标准。对于多数大型互联网应用的场景，结点众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9（99.99..%），并要达到良好的响应性能来提高用户体验，因此一般都会做出如下选择：保证P和A，舍弃C强一致，保证最终一致性。**

### BASE理论

CAP理论告诉我们一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项，其中AP在实际应用中较多，AP即舍弃一致性，保证可用性和分区容忍性，但是在实际生产中很多场景都要实现一致性，比如前边我们举的例子主数据库向从数据库同步数据，即使不要一致性，但是最终也要将数据同步成功来保证数据一致，这种一致性和CAP中的一致性不同，CAP中的一致性要求在任何时间查询每个结点数据都必须一致，它强调的是强一致性，但是最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。

BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“**柔性事务**”。

*   基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如，电商网站交易付款出现问题了，商品依然可以正常浏览。

*   软状态:由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用性，如订单的"支付中"、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。

*   最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的"支付中"状态，最终会变为“支付成功”或者"支付失败"，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。

### 分布式事务模型

描述分布式事务，常常会使用以下几个名词：

* 事务参与者：例如每个数据库就是一个事务参与者

* 事务协调者：访问多个数据源的服务程序，例如 shopping-service 就是事务协调者

* 资源管理器（Resource Manager, RM）：通常与事务参与者同义

* 事务管理器（Transaction Manager, TM）：通常与事务协调者同义

在分布式事务模型中，一个 TM 管理多个 RM，即一个服务程序访问多个数据源；TM 是一个全局事务管理器，协调多方本地事务的进度，使其共同提交或回滚，最终达成一种全局的 ACID 特性。

### 二将军问题和幂等性

二将军问题是网络领域的一个经典问题，用于表达计算机网络中互联协议设计的微妙性和复杂性。这里给出一个二将军问题的简化版本：

一支白军被围困在一个山谷中，山谷的左右两侧是蓝军。困在山谷中的白军人数多于山谷两侧的任意一支蓝军，而少于两支蓝军的之和。若一支蓝军对白军单独发起进攻，则必败无疑；但若两支蓝军同时发起进攻，则可取胜。两只蓝军的总指挥位于山谷左侧，他希望两支蓝军同时发起进攻，这样就要把命令传到山谷右侧的蓝军，以告知发起进攻的具体时间。假设他们只能派遣士兵穿越白军所在的山谷（唯一的通信信道）来传递消息，那么在穿越山谷时，士兵有可能被俘虏。

<img src="http://www.milky.show/images/distributed/transaction/tran_43.png" alt="http://www.milky.show/images/distributed/transaction/tran_43.png" style="zoom:50%;" />

只有当送信士兵成功往返后，总指挥才能确认这场战争的胜利（上方图）。现在问题来了，派遣出去送信的士兵没有回来，则左侧蓝军中的总指挥能不能决定按命令中约定的时间发起进攻？

答案是不确定，派遣出去送信的士兵没有回来，他可能遇到两种状况：

1. 命令还没送达就被俘虏了（中间图），这时候右侧蓝军根本不知道要何时进攻；

2. 命令送达，但返回途中被俘虏了（下方图），这时候右侧蓝军知道要何时进攻，但左侧蓝军不知道右侧蓝军是否知晓进攻时间。

类似的问题在计算机网络中普遍存在，例如发送者给接受者发送一个 HTTP 请求，或者 MySQL 客户端向 MySQL 服务器发送一条插入语句，然后超时了没有得到响应。请问服务器是写入成功了还是失败了？答案是不确定，有以下几种情况：

1. 可能请求由于网络故障根本没有送到服务器，因此写入失败；

2. 可能服务器收到了，也写入成功了，但是向客户端发送响应前服务器宕机了；

3. 可能服务器收到了，也写入成功了，也向客户端发送了响应，但是由于网络故障未送到客户端。

无论哪种场景，在客户端看来都是一样的结果：它发出的请求没有得到响应。为了确保服务端成功写入数据，客户端只能重发请求，直至接收到服务端的响应。

类似的问题问题被称为网络二将军问题。

网络二将军问题的存在使得消息的发送者往往要重复发送消息，直到收到接收者的确认才认为发送成功，但这往往又会导致消息的重复发送。例如电商系统中订单模块调用支付模块扣款的时候，如果网络故障导致二将军问题出现，扣款请求重复发送，产生的重复扣款结果显然是不能被接受的。因此要保证一次事务中的扣款请求无论被发送多少次，接收方有且只执行一次扣款动作，这种保证机制叫做接收方的幂等性。



## 分布式事务实战-Atomikos

**Atomikos 适合单服务多数据源的场景**

<img src="http://www.milky.show/images/distributed/transaction/tran_42.png" alt="http://www.milky.show/images/distributed/transaction/tran_42.png" style="zoom:50%;" />

我们准备 2 个数据库, 分别是订单数据库(tran_order)和日志数据库(tran_log), 订单数据库用于接收用户订单, 日志数据库用于记录用户的订单创建操作

```sql
CREATE TABLE order_info (
  id          INT    NOT NULL,
  money       DOUBLE NOT NULL,
  user_id     VARCHAR(20)  DEFAULT NULL,
  address     VARCHAR(200) DEFAULT NULL,
  create_time DATETIME     DEFAULT NULL,
  PRIMARY KEY (id)
);
```

```sql
CREATE TABLE log_info (
  id          INT NOT NULL,
  create_time DATETIME DEFAULT NULL,
  content     LONGTEXT,
  PRIMARY KEY (id)
);
```

### 实现步骤

1.  公共数据源代理的配置
    1.  配置两个数据源
    2.  XA 数据源统一管理
    3.  分别配置两个 SessionFactory
    4.  管理各自的 Mapper
2.  配置全局事务管理器(atomikos 提供)
3.  将全局事务管理器集成到 spring 中
4.  切面管理和事务通知管理
5.  将切入点和事务通知关联起来



## 分布式事务解决方案之两阶段提交（2PC） & 三阶段提交（3PC）方案

2PC即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commitphase），2是指两个阶段，P是指准备阶段，C是指提交阶段。

举例：张三和李四好久不见，老友约起聚餐，饭店老板要求先买单，才能出票。这时张三和李四分别抱怨近况不如意，囊中羞涩，都不愿意请客，这时只能AA。只有张三和李四都付款，老板才能出票安排就餐。但由于张三和李四都是铁公鸡，形成了尴尬的一幕：

准备阶段：老板要求张三付款，张三付款。老板要求李四付款，李四付款。

提交阶段：老板出票，两人拿票纷纷落座就餐。

例子中形成了一个事务，若张三或李四其中一人拒绝付款，或钱不够，店老板都不会给出票，并且会把已收款退回。

整个事务过程由事务管理器和参与者组成，店老板就是事务管理器，张三、李四就是事务参与者，事务管理器负责决策整个分布式事务的提交和回滚，事务参与者负责自己本地事务的提交和回滚。

在计算机中部分关系数据库如Oracle、MySQL支持两阶段提交协议，如下图：

1.  准备阶段（Prepare phase）：事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交。（Undo日志是记录修改前的数据，用于数据库回滚，Redo日志是记录修改后的数据，用于提交事务后写入数据文件）

    事务协调者向各个事务参与者发起询问请求：“我要执行全局事务了，这个事务涉及到的资源分布在你们这些数据源中，分别是……，你们准备好各自的资源（即各自执行本地事务到待提交阶段）”。各个参与者协调者回复 yes（表示已准备好，允许提交全局事务）或 no（表示本参与者无法拿到全局事务所需的本地资源，因为它被其他本地事务锁住了）或超时。

2. 提交阶段（commit phase）：如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意:必须在最后阶段释放锁资源。

    如果各个参与者回复的都是 yes，则协调者向所有参与者发起事务提交操作，然后所有参与者收到后各自执行本地事务提交操作并向协调者发送 ACK；如果任何一个参与者回复 no 或者超时，则协调者向所有参与者发起事务回滚操作，然后所有参与者收到后各自执行本地事务回滚操作并向协调者发送 ACK。

2PC 的流程如下图所示：

![http://www.milky.show/images/distributed/transaction/tran_2.png](http://www.milky.show/images/distributed/transaction/tran_2.png)



从上图可以看出，要实现 2PC，所有的参与者都要实现三个接口：

- Prepare()：TM 调用该接口询问各个本地事务是否就绪
- Commit()：TM 调用该接口要求各个本地事务提交
- Rollback()：TM 调用该接口要求各个本地事务回滚

可以将这三个接口简单地（但不严谨地）理解成 XA 协议。XA 协议是 X/Open 提出的分布式事务处理标准。MySQL、Oracle、DB2 这些主流数据库都实现了 XA 协议，因此都能被用于实现 2PC 事务模型。

2PC 简明易懂，但存在如下的问题：

1. 性能差，在准备阶段，要等待所有的参与者返回，才能进入阶段二，在这期间，各个参与者上面的相关资源被排他地锁住，参与者上面意图使用这些资源的本地事务只能等待。因为存在这种同步阻塞问题，所以影响了各个参与者的本地事务并发度；

2. 准备阶段完成后，如果协调者宕机，所有的参与者都收不到提交或回滚指令，导致所有参与者“不知所措”；

3. 在提交阶段，协调者向所有的参与者发送了提交指令，如果一个参与者未返回 ACK，那么协调者不知道这个参与者内部发生了什么（由于网络二将军问题的存在，这个参与者可能根本没收到提交指令，一直处于等待接收提交指令的状态；也可能收到了，并成功执行了本地提交，但返回的 ACK 由于网络故障未送到协调者上），也就无法决定下一步是否进行全体参与者的回滚。

2PC 之后又出现了 3PC，把两阶段过程变成了三阶段过程，分别是：询问阶段、准备阶段、提交或回滚阶段，这里不再详述。3PC 利用超时机制解决了 2PC 的同步阻塞问题，避免资源被永久锁定，进一步加强了整个事务过程的可靠性。但是 3PC 同样无法应对类似的宕机问题，只不过出现多数据源中数据不一致问题的概率更小。

2PC 除了性能和可靠性上存在问题，它的适用场景也很局限，它要求参与者实现了 XA 协议，例如使用实现了 XA 协议的数据库作为参与者可以完成 2PC 过程。但是在多个系统服务利用 api 接口相互调用的时候，就不遵守 XA 协议了，这时候 2PC 就不适用了。所以 2PC 在分布式应用场景中很少使用。

所以前文提到的电商场景无法使用 2PC，因为 shopping-service 通过 RPC 接口或者 Rest 接口调用 repo-service 和 order-service 间接访问 repo_db 和 order_db。除非 shopping-service 直接配置 repo_db 和 order_db 作为自己的数据库。





### XA 方案

2PC的传统方案是在数据库层面实现的，如Oracle、MySQL都支持2PC协议，为了统一标准减少行业内不必要的对接成本，需要制定标准化的处理模型及接口标准，国际开放标准组织Open Group定义了分布式事务处理模型**DTP**（Distributed Transaction Processing Reference Model）。

为了让大家更明确XA方案的内容程，下面新用户注册送积分为例来说明：

<img src="http://www.milky.show/images/distributed/transaction/tran_4.png" alt="http://www.milky.show/images/distributed/transaction/tran_4.png" style="zoom:67%;" />

执行流程如下：

1.  应用程序（AP）持有用户库和积分库两个数据源。

2.  应用程序（AP）通过TM通知用户库RM新增用户，同时通知积分库RM为该用户新增积分，RM此时并未提交事

务，此时用户和积分资源锁定。

3.  TM收到执行回复，只要有一方失败则分别向其他RM发起回滚事务，回滚完毕，资源锁释放。

4.  TM收到执行回复，全部成功，此时向所有RM发起提交事务，提交完毕，资源锁释放。



DTP模型定义如下角色：

*   AP(Application Program)：即应用程序，可以理解为使用DTP分布式事务的程序。

*   RM(Resource Manager)：即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对该数据库进行控制，资源管理器控制着分支事务。

*   TM(Transaction Manager)：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个RM。全局事务是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务。

*   DTP模型定义TM和RM之间通讯的接口规范叫XA，简单理解为数据库提供的2PC接口协议，基于数据库的XA协议来实现2PC又称为XA方案。

*   以上三个角色之间的交互方式如下：

    1.  TM向AP提供 应用程序编程接口，AP通过TM提交及回滚事务。

    2.  TM交易中间件通过XA接口来通知RM数据库事务的开始、结束以及提交、回滚等。

总结：

整个2PC的事务流程涉及到三个角色AP、RM、TM。AP指的是使用2PC分布式事务的应用程序；RM指的是资源管理器，它控制着分支事务；TM指的是事务管理器，它控制着整个全局事务。

1.  在准备阶段RM执行实际的业务操作，但不提交事务，资源锁定；

2.  在提交阶段TM会接受RM在准备阶段的执行回复，只要有任一个RM执行失败，TM会通知所有RM执行回滚操作，否则，TM将会通知所有RM提交该事务。提交阶段结束资源锁释放。

XA方案的问题：

1.  需要本地数据库支持XA协议。

2.  资源锁需要等到两个阶段结束才释放，性能较差。





### Seata 方案

Seata是由阿里中间件团队发起的开源项目 Fescar，后更名为Seata，它是一个是开源的分布式事务框架。

传统2PC的问题在Seata中得到了解决，它通过对本地关系数据库的分支事务的协调来驱动完成全局事务，是工作在应用层的中间件。主要优点是性能较好，且不长时间占用连接资源，它以高效并且对业务0侵入的方式解决微服务场景下面临的分布式事务问题，它目前提供AT模式(即2PC)及TCC模式的分布式事务解决方案。

Seata的设计目标其一是对业务无侵入，因此从业务无侵入的2PC方案着手，在传统2PC的基础上演进，并解决2PC方案面临的问题。

Seata把一个分布式事务理解成一个包含了若干分支事务的全局事务。全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个关系数据库的本地事务，下图是全局事务与分支事务的关系图：

<img src="http://www.milky.show/images/distributed/transaction/tran_5.png" alt="http://www.milky.show/images/distributed/transaction/tran_5.png" style="zoom:67%;" />

与 传统2PC 的模型类似，Seata定义了3个组件来协议分布式事务的处理过程：

<img src="http://www.milky.show/images/distributed/transaction/tran_6.png" alt="http://www.milky.show/images/distributed/transaction/tran_6.png" style="zoom: 50%;" />

*   Transaction Coordinator (TC)： 事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接收TM指令发起全局事务的提交与回滚，负责与RM通信协调各各分支事务的提交或回滚。

*   Transaction Manager (TM)： 事务管理器，TM需要嵌入应用程序中工作，它负责开启一个全局事务，并最终向TC发起全局提交或全局回滚的指令。

*   Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器TC的指令，驱动分支（本地）事务的提交和回滚。

还拿新用户注册送积分举例Seata的分布式事务过程：

<img src="http://www.milky.show/images/distributed/transaction/tran_7.png" alt="http://www.milky.show/images/distributed/transaction/tran_7.png" style="zoom: 50%;" />

具体的执行流程如下：

1.  用户服务的 TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID。

2.  用户服务的 RM 向 TC 注册 分支事务，该分支事务在用户服务执行新增用户逻辑，并将其纳入 XID 对应全局事务的管辖。

3.  用户服务执行分支事务，向用户表插入一条记录。

4.  逻辑执行到远程调用积分服务时(XID 在微服务调用链路的上下文中传播)。积分服务的RM 向 TC 注册分支事务，该分支事务执行增加积分的逻辑，并将其纳入 XID 对应全局事务的管辖。

5.  积分服务执行分支事务，向积分记录表插入一条记录，执行完毕后，返回用户服务。

6.  用户服务分支事务执行完毕。

7.  TM 向 TC 发起针对 XID 的全局提交或回滚决议。

8.  TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。

**Seata实现2PC与传统2PC的差别：**

架构层次方面，传统2PC方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身，通过 XA 协议实现，而Seata的 RM 是以jar包的形式作为中间件层部署在应用程序这一侧的。

两阶段提交方面，传统2PC无论第二阶段的决议是commit还是rollback，事务性资源的锁都要保持到Phase2完成才释放。而Seata的做法是在Phase1 就将本地事务提交，这样就可以省去Phase2持锁的时间，整体提高效率。



## 分布式事务解决方案之TCC

TCC是Try、Confirm、Cancel三个词语的缩写，TCC要求每个分支事务实现三个操作：预处理Try、确认Confirm、撤销Cancel。Try操作做业务检查及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相反的操作即回滚操作。TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所有分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Confirm操作，其中Confirm/Cancel操作若执行失败，TM会进行重试, 其本质是一个应用层面上的 2PC.

<img src="http://www.milky.show/images/distributed/transaction/tran_8.png" alt="http://www.milky.show/images/distributed/transaction/tran_8.png" style="zoom: 50%;" />

分支事务失败的情况：

<img src="http://www.milky.show/images/distributed/transaction/tran_9.png" alt="http://www.milky.show/images/distributed/transaction/tran_9.png" style="zoom: 50%;" />



TCC分为三个阶段：

1. Try 阶段是做业务检查(一致性)及资源预留(隔离)，此阶段仅是一个初步操作，它和后续的Confirm 一起才能真正构成一个完整的业务逻辑。

2.  Confirm 阶段是做确认提交，Try阶段所有分支事务执行成功后开始执行 Confirm。通常情况下，采用TCC则认为 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需引入重试机制或人工处理。

3.  Cancel 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用TCC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理。

4.  TM事务管理器

    TM事务管理器可以实现为独立的服务，也可以让全局事务发起方充当TM的角色，TM独立出来是为了成为公用组件，是为了考虑系统结构和软件复用。

    TM在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条，用来记录事务上下文，追踪和记录状态，由于Confirm 和cancel失败需进行重试，因此需要实现为幂等，幂等性是指同一个操作无论请求多少次，其结果都相同。





这里有个关键问题，既然 TCC 是一种服务层面上的 2PC，它是如何解决 2PC 无法应对宕机问题的缺陷的呢？答案是不断重试。由于 try 操作锁住了全局事务涉及的所有资源，保证了业务操作的所有前置条件得到满足，因此无论是 confirm 阶段失败还是 cancel 阶段失败都能通过不断重试直至 confirm 或 cancel 成功（所谓成功就是所有的服务都对 confirm 或者 cancel 返回了 ACK）。

这里还有个关键问题，在不断重试 confirm 和 cancel 的过程中（考虑到网络二将军问题的存在）有可能重复进行了 confirm 或 cancel，因此还要再保证 confirm 和 cancel 操作具有幂等性，也就是整个全局事务中，每个参与者只进行一次 confirm 或者 cancel。实现 confirm 和 cancel 操作的幂等性，有很多解决方案，例如每个参与者可以维护一个去重表（可以利用数据库表实现也可以使用内存型 KV 组件实现），记录每个全局事务（以全局事务标记 XID 区分）是否进行过 confirm 或 cancel 操作，若已经进行过，则不再重复执行。

TCC 由支付宝团队提出，被广泛应用于金融系统中。我们用银行账户余额购买基金时，会注意到银行账户中用于购买基金的那部分余额首先会被冻结，由此我们可以猜想，这个过程大概就是 TCC 的第一阶段。



### TCC 解决方案

目前市面上的TCC框架众多比如下面这几种：

| 框架名称        | Github 地址                                     | star 数量 |
| --------------- | ----------------------------------------------- | --------- |
| tcc-transaction | https://github.com/changmingxie/tcc-transaction | 3850      |
| Hmily           | https://github.com/yu199195/hmily               | 2407      |
| ByteTCC         | https://github.com/liuyangming/ByteTCC          | 1947      |
| EasyTransaction | https://github.com/QNJR-GROUP/EasyTransaction   | 1690      |

上一节所讲的Seata也支持TCC，但Seata的TCC模式对Spring Cloud并没有提供支持。我们的目标是理解TCC的原理以及事务协调运作的过程，因此更请倾向于轻量级易于理解的框架，因此最终确定了Hmily。

Hmily是一个高性能分布式事务TCC开源框架。基于Java语言来开发（JDK1.8），支持Dubbo，Spring Cloud等RPC框架进行分布式事务。它目前支持以下特性：

*   支持嵌套事务(Nested transaction support).

*   采用disruptor框架进行事务日志的异步读写，与RPC框架的性能毫无差别。

*   支持SpringBoot-starter 项目启动，使用简单。

*   RPC框架支持 : dubbo,motan,springcloud。

*   本地事务存储支持 : redis,mongodb,zookeeper,file,mysql。

*   事务日志序列化支持 ：java，hessian，kryo，protostuff。

*   采用Aspect AOP 切面思想与Spring无缝集成，天然支持集群。

*   RPC事务恢复，超时异常恢复等。

Hmily利用AOP对参与分布式事务的本地方法与远程方法进行拦截处理，通过多方拦截，事务参与者能透明的调用到另一方的Try、Confirm、Cancel方法；传递事务上下文；并记录事务日志，酌情进行补偿，重试等。

Hmily不需要事务协调服务，但需要提供一个数据库(mysql/mongodb/zookeeper/redis/file)来进行日志存储。

Hmily实现的TCC服务与普通的服务一样，只需要暴露一个接口，也就是它的Try业务。Confirm/Cancel业务逻辑，只是因为全局事务提交/回滚的需要才提供的，因此Confirm/Cancel业务只需要被Hmily TCC事务框架发现即可，不需要被调用它的其他业务服务所感知。



### TCC需要注意三种异常处理

#### 空回滚：

在没有调用 TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel 方法，Cancel 方法需要识别出这是一个空回滚，然后直接返回成功。

出现原因是当一个分支事务所在服务宕机或网络异常，分支事务调用记录为失败，这个时候其实是没有执行Try阶段，当故障恢复后，分布式事务进行回滚则会调用二阶段的Cancel方法，从而形成空回滚。

解决思路是关键就是要识别出这个空回滚。思路很简单就是需要知道一阶段是否执行，如果执行了，那就是正常回滚；如果没执行，那就是空回滚。前面已经说过TM在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条。再额外增加一张分支事务记录表，其中有全局事务 ID 和分支事务 ID，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。

#### 幂等：

通过前面介绍已经了解到，为了保证TCC二阶段提交重试机制不会引发数据不一致，要求 TCC 的二阶段 Try、Confirm 和 Cancel 接口保证幂等，这样不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致数据不一致等严重问题。

解决思路在上述“分支事务记录”中增加执行状态，每次执行前都查询该状态。

#### 悬挂：

悬挂就是对于一个分布式事务，其二阶段 Cancel 接口比 Try 接口先执行。

出现原因是在 RPC 调用分支事务try时，先注册分支事务，再执行RPC调用，如果此时 RPC 调用的网络发生拥堵，通常 RPC 调用是有超时时间的，RPC 超时以后，TM就会通知RM回滚该分布式事务，可能回滚完成后，RPC 请求才到达参与者真正执行，而一个 Try 方法预留的业务资源，只有该分布式事务才能使用，该分布式事务第一阶段预留的业务资源就再也没有人能够处理了，对于这种情况，我们就称为悬挂，即业务资源预留后没法继续处理。

解决思路是如果二阶段执行完成，那一阶段就不能再继续执行。在执行一阶段事务时判断在该全局事务下，“分支事务记录”表中是否已经有二阶段事务记录，如果有则不执行Try。



**举例，场景为 A 转账 30 元给 B，A和B账户在不同的服务。**

**方案1：**

账户A

```sql
try：
	检查余额是否够30元
    扣减30元
confirm：
	空
cancel：
	增加30元
```

账户B

```java
try：
	增加30元
confirm：
	空
cancel：
	减少30元
```

**方案1说明：**

1.  账户A，这里的余额就是所谓的业务资源，按照前面提到的原则，在第一阶段需要检查并预留业务资源，因此，我们在扣钱 TCC 资源的 Try 接口里先检查 A 账户余额是否足够，如果足够则扣除 30 元。 Confirm 接口表示正式提交，由于业务资源已经在 Try 接口里扣除掉了，那么在第二阶段的 Confirm 接口里可以什么都不用做。Cancel接口的执行表示整个事务回滚，账户A回滚则需要把 Try 接口里扣除掉的 30 元还给账户。

2.  账号B，在第一阶段 Try 接口里实现给账户B加钱，Cancel 接口的执行表示整个事务回滚，账户B回滚则需要把Try 接口里加的 30 元再减去。

**方案1的问题分析：**

1. 如果账户A的try没有执行在cancel则就多加了30元。

2.  由于try，cancel、confirm都是由单独的线程去调用，且会出现重复调用，所以都需要实现幂等。

3.  账号B在try中增加30元，当try执行完成后可能会其它线程给消费了。

4.  如果账户B的try没有执行在cancel则就多减了30元。

**问题解决：**

1.  账户A的cancel方法需要判断try方法是否执行，正常执行try后方可执行cancel。

2.  try，cancel、confirm方法实现幂等。

3.  账号B在try方法中不允许更新账户金额，在confirm中更新账户金额。

4.  账户B的cancel方法需要判断try方法是否执行，正常执行try后方可执行cancel。



**优化方案：**

账户A

```
try：
	try幂等校验
	try悬挂处理
	检查余额是否够30元
	扣减30元
confirm：
	空
cancel：
	cancel幂等校验
	cancel空回滚处理
	增加可用余额30元
```

账户B

```
try：
	空
confirm：
	confirm幂等校验
	正式增加30元
cancel：
	空
```



## 分布式事务解决方案之可靠消息最终一致性

可靠消息最终一致性方案是指当事务发起方执行完成本地事务后并发出一条消息，事务参与方(消息消费者)一定能够接收消息并处理事务成功，此方案强调的是只要消息发给事务参与方最终事务要达到一致。

此方案是利用消息中间件完成，如下图：

事务发起方（消息生产方）将消息发给消息中间件，事务参与方从消息中间件接收消息，事务发起方和消息中间件之间，事务参与方（消息消费方）和消息中间件之间都是通过网络通信，由于网络通信的不确定性会导致分布式事务问题。

![http://www.milky.show/images/distributed/transaction/tran_10.png](http://www.milky.show/images/distributed/transaction/tran_10.png)

因此可靠消息最终一致性方案要解决以下几个问题：

1.  本地事务与消息发送的原子性问题

    本地事务与消息发送的原子性问题即：事务发起方在本地事务执行成功后消息必须发出去，否则就丢弃消息。即实现本地事务和消息发送的原子性，要么都成功，要么都失败。本地事务与消息发送的原子性问题是实现可靠消息最终一致性方案的关键问题。

    先来尝试下这种操作，先发送消息，再操作数据库：

    ```
    begin transaction；
    //1.发送MQ
    //2.数据库操作
    commit transation;
    ```

    这种情况下无法保证数据库操作与发送消息的一致性，因为可能发送消息成功，数据库操作失败。

    你立马想到第二种方案，先进行数据库操作，再发送消息：

    ```
    begin transaction；
    //1.数据库操作
    //2.发送MQ
    commit transation;
    ```

    这种情况下貌似没有问题，如果发送MQ消息失败，就会抛出异常，导致数据库事务回滚。但如果是超时异常，数据库回滚，但MQ其实已经正常发送了，同样会导致不一致。

2.  事务参与方接收消息的可靠性

    事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息。

3.  消息重复消费的问题

    由于网络2的存在，若某一个消费节点超时但是消费成功，此时消息中间件会重复投递此消息，就导致了消息的重复消费。

    要解决消息重复消费的问题就要实现事务参与方的方法幂等性。

### 本地消息表方案

本地消息表这个方案最初是eBay提出的，此方案的核心是通过本地事务保证数据业务操作和消息的一致性，然后通过定时任务将消息发送至消息中间件，待确认消息发送给消费方成功再将消息删除。

下面以注册送积分为例来说明：

下例共有两个微服务交互，用户服务和积分服务，用户服务负责添加用户，积分服务负责增加积分。

<img src="http://www.milky.show/images/distributed/transaction/tran_11.png" alt="http://www.milky.show/images/distributed/transaction/tran_11.png" style="zoom: 50%;" />

交互流程如下：

1.  用户注册

    用户服务在本地事务新增用户和增加 ”积分消息日志“。（用户表和消息表通过本地事务保证一致）

    ```
    begin transaction；
    //1.新增用户
    //2.存储积分消息日志
    commit transation;
    ```

    这种情况下，本地数据库操作与存储积分消息日志处于同一个事务中，本地数据库操作与记录消息日志操作具备原子性。

2.  定时任务扫描日志

    如何保证将消息发送给消息队列呢？

    经过第一步消息已经写到消息日志表中，可以启动独立的线程，定时对消息日志表中的消息进行扫描并发送至消息中间件，在消息中间件反馈发送成功后删除该消息日志，否则等待定时任务下一周期重试。

3.  消费消息

    如何保证消费者一定能消费到消息呢？

    这里可以使用MQ的ack（即消息确认）机制，消费者监听MQ，如果消费者接收到消息并且业务处理完成后向MQ发送ack（即消息确认），此时说明消费者正常消费消息完成，MQ将不再向消费者推送消息，否则消费者会不断重试向消费者来发送消息。

    积分服务接收到”增加积分“消息，开始增加积分，积分增加成功后向消息中间件回应ack，否则消息中间件将重复投递此消息。

    由于消息会重复投递，积分服务的”增加积分“功能需要实现幂等性。

### RocketMQ事务消息方案

RocketMQ 是一个来自阿里巴巴的分布式消息中间件，于 2012 年开源，并在 2017 年正式成为 Apache 顶级项目。据了解，包括阿里云上的消息产品以及收购的子公司在内，阿里集团的消息产品全线都运行在 RocketMQ 之上，并且最近几年的双十一大促中，RocketMQ 都有抢眼表现。Apache RocketMQ 4.3之后的版本正式支持事务消息，为分布式事务实现提供了便利性支持。

RocketMQ 事务消息设计则主要是为了解决 Producer 端的消息发送与本地事务执行的原子性问题，RocketMQ 的设计中 broker 与 producer 端的双向通信能力，使得 broker 天生可以作为一个事务协调者存在；而 RocketMQ本身提供的存储机制为事务消息提供了持久化能力；RocketMQ 的高可用机制以及可靠消息设计则为事务消息在系统发生异常时依然能够保证达成事务的最终一致性。

在RocketMQ 4.3后实现了完整的事务消息，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部，解决 Producer 端的消息发送与本地事务执行的原子性问题。

<img src="http://www.milky.show/images/distributed/transaction/tran_12.png" alt="http://www.milky.show/images/distributed/transaction/tran_12.png" style="zoom: 50%;" />

为方便理解我们还以注册送积分的例子来描述 整个流程。

Producer 即MQ发送方，本例中是用户服务，负责新增用户。MQ订阅方即消息消费方，本例中是积分服务，负责新增积分。

1.  Producer 发送事务消息

    Producer （MQ发送方）发送事务消息至MQ Server，MQ Server将消息状态标记为Prepared（预备状态），注意此时这条消息消费者（MQ订阅方）是无法消费到的。本例中，Producer 发送 ”增加积分消息“ 到MQ Server。

2.  MQ Server回应消息发送成功

    MQ Server接收到Producer 发送给的消息则回应发送成功表示MQ已接收到消息。

3.  Producer 执行本地事务

    Producer 端执行业务代码逻辑，通过本地数据库事务控制。本例中，Producer 执行添加用户操作。

4.  消息投递

    若Producer 本地事务执行成功则自动向MQServer发送commit消息，MQ Server接收到commit消息后将”增加积分消息“ 状态标记为可消费，此时MQ订阅方（积分服务）即正常消费消息；若Producer 本地事务执行失败则自动向MQServer发送rollback消息，MQ Server接收到rollback消息后 将删除”增加积分消息“ 。MQ订阅方（积分服务）消费消息，消费成功则向MQ回应ack，否则将重复接收消息。这里ack默认自动回应，即程序执行正常则自动回应ack。

5.  事务回查

    如果执行Producer端本地事务过程中，执行端挂掉，或者超时，MQ Server将会不停的询问同组的其他 Producer来获取事务执行状态，这个过程叫事务回查。MQ Server会根据事务回查结果来决定是否投递消息。

以上主干流程已由RocketMQ实现，对用户侧来说，用户需要分别实现本地事务执行以及本地事务回查方法，因此只需关注本地事务的执行状态即可。

RoacketMQ提供RocketMQLocalTransactionListener接口：

```java
public interface RocketMQLocalTransactionListener {
    
    /**
     ‐ 发送prepare消息成功此方法被回调，该方法用于执行本地事务
     ‐ @param msg 回传的消息，利用transactionId即可获取到该消息的唯一Id
     ‐ @param arg 调用send方法时传递的参数，当send时候若有额外的参数可以传递到send方法中，这里能获取到
     ‐ @return 返回事务状态，COMMIT：提交 ROLLBACK：回滚 UNKNOW：回调
     */
    RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg);
    
    /**
     ‐ @param msg 通过获取transactionId来判断这条消息的本地事务执行状态
     ‐ @return 返回事务状态，COMMIT：提交 ROLLBACK：回滚 UNKNOW：回调
     */
    RocketMQLocalTransactionState checkLocalTransaction(Message msg);
}
```



## 分布式事务解决方案之最大努力通知

最大努力通知也是一种解决分布式事务的方案，下边是一个是充值的例子：

<img src="http://www.milky.show/images/distributed/transaction/tran_13.png" alt="http://www.milky.show/images/distributed/transaction/tran_13.png" style="zoom:67%;" />

交互流程:

1.  账户系统调用充值系统接口

2.  充值系统完成支付处理向账户系统发起充值结果通知

若通知失败，则充值系统按策略进行重复通知

3.  账户系统接收到充值结果通知修改充值状态。

4.  账户系统未接收到通知会主动调用充值系统的接口查询充值结果。

通过上边的例子我们总结最大努力通知方案的目标：

目标：发起通知方通过一定的机制最大努力将业务处理结果通知到接收方。

具体包括：

1.  有一定的消息重复通知机制。

    因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知。

2.  消息校对机制。

    如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。

最大努力通知与可靠消息一致性有什么不同？

1.  解决方案思想不同

    可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证。

    最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。

2.  两者的业务应用场景不同

    可靠消息一致性关注的是交易过程的事务一致，以异步的方式完成交易。

    最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知出去。

3.  技术解决方向不同

    可靠消息一致性要解决消息从发出到接收的一致性，即消息发出并且被接收到。

    最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。可靠机制是，最大努力的将消息通知给接收方，当消息无法被接收方接收时，由接收方主动查询消息（业务处理结果）。

### 解决方案

通过对最大努力通知的理解，采用MQ的ack机制就可以实现最大努力通知。

**方案1：**

<img src="http://www.milky.show/images/distributed/transaction/tran_14.png" alt="http://www.milky.show/images/distributed/transaction/tran_14.png" style="zoom:50%;" />

本方案是利用MQ的ack机制由MQ向接收通知方发送通知，流程如下：

1.  发起通知方将通知发给MQ。

    使用普通消息机制将通知发给MQ。

    注意：如果消息没有发出去可由接收通知方主动请求发起通知方查询业务执行结果。（后边会讲）

2.  接收通知方监听 MQ。

3.  接收通知方接收消息，业务处理完成回应ack。

4.  接收通知方若没有回应ack则MQ会重复通知。

    MQ会按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔 （如果MQ采用rocketMq，在broker中可进行配置），直到达到通知要求的时间窗口上限。

5.  接收通知方可通过消息校对接口来校对消息的一致性。

**方案2：**

本方案也是利用MQ的ack机制，与方案1不同的是应用程序向接收通知方发送通知，如下图：

<img src="http://www.milky.show/images/distributed/transaction/tran_15.png" alt="http://www.milky.show/images/distributed/transaction/tran_15.png" style="zoom: 50%;" />



交互流程如下：

1.  发起通知方将通知发给MQ。

    使用可靠消息一致方案中的事务消息保证本地事务与消息的原子性，最终将通知先发给MQ。

2.  通知程序监听 MQ，接收MQ的消息。

    方案1中接收通知方直接监听MQ，方案2中由通知程序监听MQ。

    通知程序若没有回应ack则MQ会重复通知。

3.  通知程序通过互联网接口协议（如http、webservice）调用接收通知方案接口，完成通知。

    通知程序调用接收通知方案接口成功就表示通知成功，即消费MQ消息成功，MQ将不再向通知程序投递通知消息。

4.  接收通知方可通过消息校对接口来校对消息的一致性。

方案1和方案2的不同点：

1.  方案1中接收通知方与MQ接口，即接收通知方案监听 MQ，此方案主要应用与内部应用之间的通知。

2.  方案2中由通知程序与MQ接口，通知程序监听MQ，收到MQ的消息后由通知程序通过互联网接口协议调用接收通知方。此方案主要应用于外部应用之间的通知，例如支付宝、微信的支付结果通知。



## 分布式事务解决方案的关系

### DTP-XA-二阶段提交协议(2pc tcc)

#### DTP模型

分布式事务处理模型标准, 由几个巨头公司提出来的一种标准

##### 模型元素(5 个)

应用程序(Application Program, 简称 AP):

资源管理器(Resource Manager, 简称 RM): 如数据库, 文件系统等, 并提供访问资源的方式

事务管理器(Transaction Manager, 简称 TM): 负责分配事务唯一标识, 监控事务的执行进度, 并负责事务的提交, 回滚等.

通信资源管理器(Communication Resource Manager, 简称 CRM): 控制一个 TM 域(TM domain)内或者跨 TM 域的分布式应用之间的通信

通信协议(Communication Protocol, 简称 CP):

##### 模型实例

<img src="http://www.milky.show/images/distributed/transaction/tran_39.png" alt="http://www.milky.show/images/distributed/transaction/tran_39.png" style="zoom:50%;" />

#### XA 规范

XA 规范的最主要作用是定义了 RM-TM 之间的交互交口, 是 DTP 模型的一部分

<img src="http://www.milky.show/images/distributed/transaction/tran_40.png" alt="http://www.milky.show/images/distributed/transaction/tran_40.png" style="zoom:50%;" />

#### XA 规范与二阶段提交协议的关系

XA 规范定义了两阶段提交协议中需要使用到的接口, XA 和 2PC 是相互参考的

<img src="http://www.milky.show/images/distributed/transaction/tran_41.png" alt="http://www.milky.show/images/distributed/transaction/tran_41.png" style="zoom:50%;" />

### XA-JTA-atomikos 的关系

JTA, Java Transaction Api, XA 的 java 实现版, 某种程度上可以认为 JTA 规范是 XA 规范的 Java 版, 在 JTA 中, 事物管理器抽象为 javax.transaction.TransactionManager 接口, 并通过底层事物服务(即 JTS)实现

JTA 仅仅定义了接口

具体的实现如下

*   J2EE 容器所提供的 JTA 实现 JBOSS
*   第三方独立的 JTA 实现, JOTM, Atomikos, 用于 Tomcat, Jetty 以及普通的 Java 引用
*   Atomikos, JTA 的实现, 用于 tomcat 容器



### 二阶段 2pc 与 tcc 的关系

tcc 是二阶段协议的一种, 只不过 tcc 做了一些优化, 在 try 阶段只锁定了一部分资源, 剩余的资源其他事务还可以使用.

**二阶段尽量保证了数据一致性, 适合对数据一致要求很高的关键领域, 实现复杂, 牺牲了可用性, 对性能影响较大, 不适合高并发场景, 如分布式系统跨接口调用**

**tcc 跟 2pc 比起来, 实现及流程相对接单一些, 但数据的一致性比 2PC 差一些, 在 2,3 步骤中都有可能失败, TCC 属于应用层的一种补偿方式, 需要程序员在实现的时候写很多的补偿代码, 在一些场景中, 一些业务流程可能用 TCC 不太好定义及处理, 在代码无法完成时, 可以通过手工干预.**



## 事务传播机制

如果有两个service方法, serviceA的方法调用serviceB的方法, 这两个service的方法都是在事务中执行的,

事务是如何在这两个事务中传播的就是事务传播机制解决的问题

```java
// 如果A开启事务B就加入, A不开启B就开启新事务, 默认就是这个级别
int PROPAGATION_REQUIRED = 0;
// 如果A开启事务B就加入, A不开启B就不开启
int PROPAGATION_SUPPORTS = 1;
// A必须在事务中, 如果不在事务中B会报错, 一般用在被调用者上
int PROPAGATION_MANDATORY = 2;
// 不管A在不在事务中, B都会新建事务
int PROPAGATION_REQUIRES_NEW = 3;
// A不管在不在事务中, B都会挂起事务
int PROPAGATION_NOT_SUPPORTED = 4;
// A在事务中就会抛出异常, A不在事务中就可以正常运行, 一般用在被调用者上
int PROPAGATION_NEVER = 5;
// 如果当前存在事务, 则在嵌套事务内执行。如果当前没有事务, 则执行与PROPAGATION_REQUIRED类似的操作。(这个和REQUIRED区别在于一个是加入到一个事务, 一个是在嵌套事务运行)
int PROPAGATION_NESTED = 6;
```

可以这么理解, 大多数情况下, 效果和REQUIRED一样。但是有一种情况, 就是上述代码中, 被调用者事务传播属性为NESTED, 当出现异常时,  调用者把departmentService try, catch了。这个区别与REQUIRED的并不会报错, 而且addEmpByNested方法不会回滚, 只有addDeptByNested回滚了。
 大概原理：当被调用者使用PROPAGATION_NESTED时, 底层的数据源必须基于JDBC 3.0, 并且实现者需要支持保存点事务机制。按上述代码来说(去掉try, catch), 当执行到addDeptByNested这个方法时, Spring会为它创建一个内部的嵌套事务, 如果addDeptByNested执行失败, 则事务回滚到addDeptByNested之前的点, 此时如果不抛异常, 则不会回滚。这个嵌套事务, 是addEmpByNested的一部分, 只有外层事务提交了, 内层的嵌套事务才会一起提交, 这也是与REQUIRED(加入事务), REQUIRES_NEW(开启新事务)的区别。
 还值得一提的是, NESTED是嵌套的意思, 其实并不是只有NESTED用于嵌套, 只要理解上述7个传播机制的意思, 都可以嵌套用。

| 传播属性                  | 调用者                                                       | 被调用者  |
| ------------------------- | ------------------------------------------------------------ | --------- |
| PROPAGATION_REQUIRED      | T1                                                           | T1        |
|                           | 无                                                           | T2        |
| PROPAGATION_SUPPORTS      | T1                                                           | T1        |
|                           | 无                                                           | 无        |
| PROPAGATION_MANDATORY     | T1                                                           | T1        |
|                           | 无                                                           | Exception |
| PROPAGATION_REQUIRES_NEW  | T1                                                           | T2        |
|                           | 无                                                           | T2        |
| PROPAGATION_NOT_SUPPORTED | T1                                                           | 无        |
|                           | 无                                                           | 无        |
| PROPAGATION_NEVER         | T1                                                           | Exception |
|                           | 无                                                           | 无        |
| NESTED                    | 设置 savePoint, 一旦事务回滚, 事务将回滚到 savePoint 处, 交由客户响应提交/回滚 |           |

