---
layout: post
title: "Netty 网络编程"
categories: [Network]
description:
keywords:
---

* content
{:toc}


## Netty 的介绍

Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github上的独立项目。

Netty 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 IO 程序。

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_1.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_1.png" />

Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。

Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_2.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_2.png" />

要透彻理解Netty ， 需要先学习 NIO ， 这样我们才能阅读 Netty 的源码。 



## Netty 的应用场景

### 互联网行业

互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。

典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信

### 游戏行业

无论是手游服务端还是大型的网络游戏，Java 语言得到了越来越广泛的应用

Netty 作为高性能的基础通信组件，提供了 TCP/UDP 和 HTTP 协议栈，方便定制和开发私有协议栈，账号登录服务器

地图服务器之间可以方便的通过 Netty 进行高性能的通信

### 大数据领域

经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨界点通信

它的 Netty Service 基于 Netty 框架二次封装实现。

### 其它开源项目使用到Netty

网址: [https://](https://netty.io/wiki/related-projects.html)[netty.io/wiki/related-projects.html](https://netty.io/wiki/related-projects.html)



## I/O模型

### I/O模型基本说明

I/O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能

Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO

Java BIO ： 同步并阻塞(**传统阻塞型**)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 【简单示意图】

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_4.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_4.png" />

Java NIO ： **同步非阻塞**，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理 【简单示意图】

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_5.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_5.png" />

Java AIO(NIO.2) ： **异步非阻塞**，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用



### BIO、NIO、AIO 适用场景分析

BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。

NIO 方式适用于**连接数目多且连接比较短**（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。

AIO 方式使用于**连接数目多且连接比较长**（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。



## JavaBIO 编程模型

### Java BIO **基本介绍**

Java BIO 就是**传统的 java io 编程**，其相关的类和接口在 java.io 

BIO(blocking I/O) ： **同****步阻塞**，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过**线程池机制改**善(实现多个客户连接服务器)。 【**后有应用实例**】

BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解

### Java BIO 工作机制

#### 工作原理图

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_3.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_3.png" />

#### BIO 编程简单流程

服务器端启动一个ServerSocket

客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯

客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝

如果有响应，客户端线程会等待请求结束后，在继续执行



### Java BIO 应用实例

#### 实例说明

使用BIO模型编写一个服务器端，监听6666端口，当有客户端连接时，就启动一个线程与之通讯。

要求使用线程池机制改善，可以连接多个客户端.

服务器端可以接收客户端发送的数据(telnet 方式即可)。

代码演示





#### JavaBIO 问题分析

1)每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。

2)当并发数较大时，需要**创建大量线程来处理连接**，系统资源占用较大。

3)连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费























## 零拷贝

零拷贝是网络编程的关键，很多性能优化都离不开。

在 Java 程序中，常用的零拷贝有 mmap(内存映射) 和 sendFile。那么，他们在 OS 里，到底是怎么样的一个的设计？我们分析 mmap 和 sendFile 这两个零拷贝

我们看下NIO 中如何使用零拷贝

### 传统 IO 数据拷贝

```java
File file = new File("test.txt");
RandomAccessFile raf = new RandomAccessFile(file, "rw");

byte[] arr = new byte[(int) file.length()];
raf.read(arr);

Socket socket = new ServerSocket(8080).accept();
socket.getOutputStream().write(arr);
```

