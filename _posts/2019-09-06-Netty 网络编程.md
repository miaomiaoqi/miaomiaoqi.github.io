---
layout: post
title: "Netty 网络编程"
categories: [Network]
description:
keywords:
---

* content
{:toc}


## Netty 的介绍

Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github上的独立项目。

Netty 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 IO 程序。

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_1.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_1.png" />

Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。

Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_2.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_2.png" />

要透彻理解Netty ， 需要先学习 NIO ， 这样我们才能阅读 Netty 的源码。 



## Netty 的应用场景

### 互联网行业

互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。

典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信

### 游戏行业

无论是手游服务端还是大型的网络游戏，Java 语言得到了越来越广泛的应用

Netty 作为高性能的基础通信组件，提供了 TCP/UDP 和 HTTP 协议栈，方便定制和开发私有协议栈，账号登录服务器

地图服务器之间可以方便的通过 Netty 进行高性能的通信

### 大数据领域

经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨界点通信

它的 Netty Service 基于 Netty 框架二次封装实现。

### 其它开源项目使用到Netty

网址: [https://](https://netty.io/wiki/related-projects.html)[netty.io/wiki/related-projects.html](https://netty.io/wiki/related-projects.html)



## I/O模型

### I/O模型基本说明

I/O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能

Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO

Java BIO ： 同步并阻塞(**传统阻塞型**)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 【简单示意图】

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_4.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_4.png" />

Java NIO ： **同步非阻塞**，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理 【简单示意图】

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_5.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_5.png" />

Java AIO(NIO.2) ： **异步非阻塞**，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用



### BIO、NIO、AIO 适用场景分析

BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。

NIO 方式适用于**连接数目多且连接比较短**（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。

AIO 方式使用于**连接数目多且连接比较长**（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。



## Java BIO 编程模型

### Java BIO **基本介绍**

Java BIO 就是**传统的 java io 编程**，其相关的类和接口在 java.io 

BIO(blocking I/O) ： **同****步阻塞**，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过**线程池机制改**善(实现多个客户连接服务器)。 【**后有应用实例**】

BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解

### Java BIO 工作机制

#### 工作原理图

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_3.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_3.png" />

#### BIO 编程简单流程

服务器端启动一个ServerSocket

客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯

客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝

如果有响应，客户端线程会等待请求结束后，在继续执行



### Java BIO 应用实例

**实例说明**

使用BIO模型编写一个服务器端，监听6666端口，当有客户端连接时，就启动一个线程与之通讯。

要求使用线程池机制改善，可以连接多个客户端.

服务器端可以接收客户端发送的数据(telnet 方式即可)。

代码演示

```java
public class BIOServer {

    public static void main(String[] args) throws IOException {
        // 线程池机制

        // 思路
        // 1. 创建一个线程池
        // 2. 如果有客户端连接, 就创建一个线程, 与之通讯(单独写一个方法)
        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();

        // 创建 ServerSocket
        ServerSocket serverSocket = new ServerSocket(6666);
        System.out.println("服务器启动了");
        while (true) {
            // 监听, 等待客户端连接
            Socket socket = serverSocket.accept();
            System.out.println("连接到一个客户端");

            newCachedThreadPool.execute(() -> {
                // 可以和客户端通信
                handler(socket);
            });
        }
    }

    // 编写一个 handler 方法, 和客户端通信
    public static void handler(Socket socket) {
        try {
            System.out.println("线程信息, id = " + Thread.currentThread().getId() + " 名字 = " + Thread.currentThread().getName());
            byte[] bytes = new byte[1024];
            // 通过 socket 获取输入流
            InputStream inputStream = socket.getInputStream();
            // 循环读取客户端发送的数据
            while (true) {
                int read = inputStream.read(bytes);
                if (read != -1) {
                    // 输出客户端数据
                    System.out.print(new String(bytes, 0, read));
                } else {
                    break;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            System.out.println("关闭和 client 的连接");
            try {
                socket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            ;
        }

    }

}
```



### Java BIO 问题分析

每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。

当并发数较大时，需要**创建大量线程来处理连接**，系统资源占用较大。

连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费



## Java NIO 编程

### Java NIO 基本介绍

Java NIO 全称java non-blocking IO，是指JDK 提供的新API。从JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为NIO(即New IO)，是同步非阻塞的

NIO 相关类都被放在java.nio 包及子包下，并且对原java.io 包中的很多类进行改写。【基本案例】

NIO 有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器)

NIO 是面向缓冲区，或者面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络

Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】

通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有10000 个请求过来,根据实际情况，可以分配50 或者100 个线程来处理。不像之前的阻塞IO 那样，非得分配10000 个。

HTTP2.0 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1 大了好几个数量级

案例说明NIO 的Buffer

```java
package com.atguigu.nio;

import java.nio.IntBuffer;

public class BasicBuffer {

    public static void main(String[] args) {
        // 举例说明 Buffer 的使用(简单说明)
        // 创建一个 Buffer, 大小为 5, 即可以存放 5 个 int
        IntBuffer intBuffer = IntBuffer.allocate(5);

        // 向 buffer 中存放数据
        // intBuffer.put(10);
        // intBuffer.put(11);
        // intBuffer.put(12);
        // intBuffer.put(13);
        // intBuffer.put(14);
        for (int i = 0; i < intBuffer.capacity(); i++) {
            intBuffer.put(i * 2);
        }
        // 如何从 buffer 读取数据
        // 将 buffer 转换, 读写切换
        intBuffer.flip();
        while (intBuffer.hasRemaining()) {
            System.out.println(intBuffer.get());
        }
    }

}
```

### NIO 和 BIO 的比较

BIO 以流的方式处理数据,而NIO 以块的方式处理数据,块I/O 的效率比流I/O 高很多

BIO 是阻塞的，NIO 则是非阻塞的

BIO 基于字节流和字符流进行操作，而NIO 基于Channel(通道)和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道



### NIO 三大核心原理示意图

一张图描述NIO 的Selector 、Channel 和Buffer 的关系

#### Selector 、Channel 和Buffer 的关系图(简单版)

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_6.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_6.png" />

1.   每个channel 都会对应一个Buffer

2.   Selector 对应一个线程， 一个线程对应多个channel(连接)

3.   该图反应了有三个channel 注册到该selector //程序

4.   程序切换到哪个channel 是有事件决定的, Event 就是一个重要的概念

5.   Selector 会根据不同的事件，在各个通道上切换

6.   Buffer 就是一个内存块， 底层是有一个数组

7.   数据的读取写入是通过Buffer, 这个和BIO , BIO 中要么是输入流，或者是输出流, 不能双向，但是NIO 的Buffer 是可以读也可以写, 需要flip 方法切换channel 是双向的, 可以返回底层操作系统的情况, 比如Linux ， 底层的操作系



### 缓冲区(Buffer)

#### 基本介绍

缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个容器对象(含数组)，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由Buffer，如图: 【后面举例说明】

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_7.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_7.png" />

#### Buffer 类及其子类

在NIO 中，Buffer 是一个顶层父类，它是一个抽象类, 类的层级关系图

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_8.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_8.png" />

Buffer 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_9.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_9.png" />

Buffer 类相关方法一览

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_10.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_10.png" />

#### ByteBuffer

从前面可以看出对于Java 中的基本数据类型(boolean 除外)，都有一个Buffer 类型与之相对应，最常用的自然是ByteBuffer 类（二进制数据），该类的主要方法如下

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_11.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_11.png" />



### 通道(Channel)

#### 基本介绍

NIO 的通道类似于流，但有些区别如下：

*   通道可以同时进行读写，而流只能读或者只能写

*   通道可以实现异步读写数据

*   通道可以从缓冲读数据，也可以写数据到缓冲:

BIO 中的stream 是单向的，例如FileInputStream 对象只能进行读取数据的操作，而NIO 中的通道(Channel)是双向的，可以读操作，也可以写操作。

Channel 在NIO 中是一个接口 public interface Channel extends Closeable{}

常用的Channel 类有： FileChannel 、DatagramChannel 、ServerSocketChannel 和SocketChannel 。【ServerSocketChanne 类似ServerSocket , SocketChannel 类似Socket】

FileChannel 用于文件的数据读写， DatagramChannel 用于UDP 的数据读写， ServerSocketChannel 和 SocketChannel 用于TCP 的数据读写。

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_12.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_12.png" />

#### FileChannel 类

FileChannel 主要用来对本地文件进行IO 操作，常见的方法有

*   public int read(ByteBuffer dst) ，从通道读取数据并放到缓冲区中
*   public int write(ByteBuffer src) ，把缓冲区的数据写到通道中
*   public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道中复制数据到当前通道
*   public long transferTo(long position, long count, WritableByteChannel target)，把数据从当前通道复制给目标通道

#### 应用实例1-本地文件写数据

实例要求:

1.   使用前面学习后的ByteBuffer(缓冲) 和FileChannel(通道)， 将"hello,尚硅谷" 写入到file01.txt 中

2.   文件不存在就创建

3.   代码演示

     ```java
     package com.atguigu.nio;
     
     import java.io.FileOutputStream;
     import java.nio.ByteBuffer;
     import java.nio.channels.FileChannel;
     
     public class NIOFileChannel01 {
     
         public static void main(String[] args) throws Exception {
             String str = "hello, 尚硅谷";
             // 创建一个输出流 -> channel
             FileOutputStream fileOutputStream = new FileOutputStream(
                     "/Users/miaoqi/Documents/study/language/java/communication/atguigu-netty/file01.txt");
             // 通过 fileoutputstream 获取对应的 FileChannel
             // 这个 fileChannel 的真实类型是 FileChannelImpl
             FileChannel fileChannel = fileOutputStream.getChannel();
             // 创建一个缓冲区 ByteBuffer
             ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
             // 将 str 放入 byteBuffer
             byteBuffer.put(str.getBytes());
             // 对 byteBuffer 进行反转
             byteBuffer.flip();
             // 将 byteBuffer 的数据写入到 fileChannel
             fileChannel.write(byteBuffer);
             fileOutputStream.close();
         }
     
     }
     ```



#### 应用实例2-本地文件读数据

实例要求:

1)   使用前面学习后的ByteBuffer(缓冲) 和FileChannel(通道)， 将file01.txt 中的数据读入到程序，并显示在控制台屏幕

2)   假定文件已经存在

3)   代码演示

     ```java
     package com.atguigu.nio;
     
     import java.io.File;
     import java.io.FileInputStream;
     import java.nio.ByteBuffer;
     import java.nio.channels.FileChannel;
     
     public class NIOFileChannel02 {
     
         public static void main(String[] args) throws Exception {
     
             // 创建文件的输入流
             File file = new File("/Users/miaoqi/Documents/study/language/java/communication/atguigu-netty/file01.txt");
             FileInputStream fileInputStream = new FileInputStream(file);
             // 通过 fileInputStream 获取对应的 FileChannel -> 实际类型 FileChannelImpl
             FileChannel fileChannel = fileInputStream.getChannel();
             // 创建缓冲区
             ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length());
             // 将通道的数据读入到 Buffer 中
             fileChannel.read(byteBuffer);
             // 将 ByteBuffer 的字节数据转成 String
             System.out.println(new String(byteBuffer.array()));
             // 将 byteBuffer 的数据写入到 fileChannel
             fileInputStream.close();
         }
     
     }
     ```

     

#### 应用实例3-使用一个Buffer 完成文件读取、写入

实例要求:

1.   使用FileChannel(通道) 和方法read , write，完成文件的拷贝

2.   拷贝一个文本文件1.txt , 放在项目下即可

3.   代码演示

     <img src="https://miaomiaoqi.github.io/images/net/netty/netty_13.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_13.png" />

     ```java
     package com.atguigu.nio;
     
     import java.io.FileInputStream;
     import java.io.FileOutputStream;
     import java.nio.ByteBuffer;
     import java.nio.channels.FileChannel;
     
     public class NIOFileChannel03 {
     
         public static void main(String[] args) throws Exception {
             FileInputStream fileInputStream = new FileInputStream("/Users/miaoqi/Documents/study/language/java/communication/atguigu-netty/1.txt");
             FileChannel fileInputStreamChannel = fileInputStream.getChannel();
     
             FileOutputStream fileOutputStream = new FileOutputStream("/Users/miaoqi/Documents/study/language/java/communication/atguigu-netty/2.txt");
             FileChannel fileOutputStreamChannel = fileOutputStream.getChannel();
     
             ByteBuffer byteBuffer = ByteBuffer.allocate(512);
             while (true) { // 循环读取
                 // 这里有一个重要的操作, 清空 buffer
                 byteBuffer.clear();
                 int read = fileInputStreamChannel.read(byteBuffer);
                 if (read == -1) {
                     // 读完了
                     break;
                 }
                 // 将 buffer 中的数据写入到 filechannel 中
                 byteBuffer.flip();
                 fileOutputStreamChannel.write(byteBuffer);
             }
             // 关闭相关的流
             fileInputStream.close();
             fileOutputStream.close();
         }
     
     }
     
     ```

     

#### 应用实例4-拷贝文件transferFrom 方法

实例要求:

1.   使用FileChannel(通道) 和方法transferFrom ，完成文件的拷贝

2.   拷贝一张图片

3.   代码演示

     ```java
     package com.atguigu.nio;
     
     import java.io.FileInputStream;
     import java.io.FileOutputStream;
     import java.nio.channels.FileChannel;
     
     public class NIOFileChannel04 {
     
         public static void main(String[] args) throws Exception {
             FileInputStream fileInputStream = new FileInputStream("/Users/miaoqi/Documents/study/language/java/communication/atguigu-netty/Koala.jpg");
             FileChannel fileInputStreamChannel = fileInputStream.getChannel();
     
             FileOutputStream fileOutputStream = new FileOutputStream(
                     "/Users/miaoqi/Documents/study/language/java/communication/atguigu-netty/Koala2.jpg");
             FileChannel fileOutputStreamChannel = fileOutputStream.getChannel();
     
             // 使用 transferFrom 完成拷贝
             fileOutputStreamChannel.transferFrom(fileInputStreamChannel, 0, fileInputStreamChannel.size());
     
             // 关闭相关的流
             fileInputStream.close();
             fileOutputStream.close();
         }
     
     }
     
     ```



#### 关于Buffer 和Channel 的注意事项和细节

ByteBuffer 支持类型化的put 和get, put 放入的是什么数据类型，get 就应该使用相应的数据类型来取出，否则可能有BufferUnderflowException 异常。[举例说明]

```java
package com.atguigu.nio;

import java.nio.ByteBuffer;

public class NIOByteBufferPutGet {

    public static void main(String[] args) {
        // 创建一个 buffer
        ByteBuffer byteBuffer = ByteBuffer.allocate(64);
        // 类型化方式放入数据
        byteBuffer.putInt(100);
        byteBuffer.putLong(9);
        byteBuffer.putChar('苗');
        byteBuffer.putShort((short) 4);

        // 取出
        byteBuffer.flip();

        System.out.println();

        System.out.println(byteBuffer.getInt());
        System.out.println(byteBuffer.getLong());
        System.out.println(byteBuffer.getChar());
        System.out.println(byteBuffer.getShort());
    }

}

```



可以将一个普通Buffer 转成只读Buffer [举例说明]

```java
package com.atguigu.nio;

import java.nio.ByteBuffer;

public class ReadOnlyBuffer {

    public static void main(String[] args) {
        // 创建一个 buffer
        ByteBuffer buffer = ByteBuffer.allocate(64);
        for (int i = 0; i < 64; i++) {
            buffer.put((byte) i);
        }
        // 读取
        buffer.flip();
        // 得到一个只读的 buffer
        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();
        System.out.println(readOnlyBuffer.getClass());
        // 读取
        while (readOnlyBuffer.hasRemaining()) {
            System.out.println(readOnlyBuffer.get());
        }
    }

}

```



NIO 还提供了MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进行修改， 而如何同步到文件由NIO 来完成. [举例说明]

```java
package com.atguigu.nio;

import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;

/**
 * 1. MapperByteBuffer 可以直接让文件在内存(堆外内存)修改, 操作系统不需要拷贝一次
 *
 * @author miaoqi
 * @date 2024-01-16 11:22:10
 */
public class MapperByteBuffer {

    public static void main(String[] args) throws Exception {
        RandomAccessFile rw = new RandomAccessFile("/Users/miaoqi/Documents/study/language/java/communication/atguigu-netty/1.txt", "rw");
        FileChannel channel = rw.getChannel();

        // 参数 1: FileChannel.MapMode.READ_WRITE 使用的读写模式
        // 参数 2: 0 可以直接修改的起始位置
        // 参数 3: 5 是映射到内存的大小, 即将 1.txt 的多少个字节映射到内存
        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 5);
        mappedByteBuffer.put(0, (byte) 'H');
        mappedByteBuffer.put(3, (byte) '9');

        rw.close();
    }

}

```



前面我们讲的读写操作，都是通过一个Buffer 完成的，NIO 还支持通过多个Buffer (即Buffer 数组) 完成读写操作，即Scattering 和Gathering 【举例说明】

```java
package com.atguigu.nio;


import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Arrays;

/**
 * Scattering: 将数据写入到 buffer 时, 可以采用 buffer 数组, 依次写
 * Gathering: 从 buffer 读取数据时, 可以采用 buffer 数组 依次读
 *
 * @author miaoqi
 * @date 2024-01-16 12:0:46
 */
public class ScatteringAndGatheringTest {

    public static void main(String[] args) throws IOException {
        // 使用 ServerSocketChannel 和 SocketChannel
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        InetSocketAddress inetSocketAddress = new InetSocketAddress(7000);
        // 绑定端口到 socket 并启动
        serverSocketChannel.socket().bind(inetSocketAddress);
        // 创建 buffer 数组
        ByteBuffer[] byteBuffers = new ByteBuffer[2];
        byteBuffers[0] = ByteBuffer.allocate(5);
        byteBuffers[1] = ByteBuffer.allocate(3);
        // 等待客户端连接, 使用 telnet
        SocketChannel socketChannel = serverSocketChannel.accept();
        int messageLength = 8; // 假定从客户端接收 8 个字节
        // 循环读取
        while (true) {
            int byteRead = 0;
            while (byteRead < messageLength) {
                long l = socketChannel.read(byteBuffers);
                byteRead += l; // 累计读取的字节数
                System.out.println("byteRead = " + byteRead);
                // 使用流打印, 看看当前这个 buffer 的 position 和 limit
                Arrays.asList(byteBuffers).stream().map(buffer -> "position = " + buffer.position() + ", limit = " + buffer.limit()).forEach(
                        System.out::println);
            }
            // 将所有的 buffer 进行反转
            Arrays.asList(byteBuffers).forEach(buffer -> buffer.flip());
            // 将数据读出显示到客户端
            long byteWrite = 0;
            while (byteWrite < messageLength) {
                long l = socketChannel.write(byteBuffers);
                byteWrite += l;
            }
            // 将所有的 buffer 进行 clear
            Arrays.asList(byteBuffers).forEach(buffer -> buffer.clear());
            System.out.println("byteRead = " + byteRead + ", byteWrite = " + byteWrite + ", messageLength = " + messageLength);
        }

    }

}

```



### Selector(选择器)

#### 基本介绍

Java 的NIO，用非阻塞的IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到Selector(选择器)

Selector 能够检测多个注册的通道上是否有事件发生(注意:多个Channel 以事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。【示意图】

只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程

避免了多线程之间的上下文切换导致的开销



#### Selector 示意图和特点说明

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_14.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_14.png" />

Netty 的IO 线程NioEventLoop 聚合了Selector(选择器，也叫多路复用器)，可以同时并发处理成百上千个客户端连接。

当线程从某客户端Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。

线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以单独的线程可以管理多个输入和输出通道。

由于读写操作都是非阻塞的，这就可以充分提升IO 线程的运行效率，避免由于频繁I/O 阻塞导致的线程挂起。

一个I/O 线程可以并发处理N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。



#### Selector 类相关方法

Selector 类是一个抽象类, 常用方法和说明如下:

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_15.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_15.png" />

#### 注意事项

NIO 中的ServerSocketChannel 功能类似ServerSocket，SocketChannel 功能类似Socket

selector 相关方法说明

*   selector.select()//阻塞
*   selector.select(1000);//阻塞1000 毫秒，在1000 毫秒后返回
*   selector.wakeup();//唤醒selector
*   selector.selectNow();//不阻塞，立马返还



### NIO 非阻塞网络编程原理分析图

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_16.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_16.png" />

对上图的说明:

1.   当客户端连接时，会通过ServerSocketChannel 得到SocketChannel
2.   Selector 进行监听select 方法, 返回有事件发生的通道的个数.
3.   将socketChannel 注册到Selector 上, register(Selector sel, int ops), 一个selector 上可以注册多个SocketChannel
4.   注册后返回一个SelectionKey, 会和该Selector 关联(集合)
5.   进一步得到各个SelectionKey (有事件发生)
6.   在通过SelectionKey 反向获取SocketChannel , 方法channel()
7.   可以通过得到的channel , 完成业务处理
8.   代码撑腰。。。



### NIO 非阻塞网络编程快速入门

案例要求:

1)   编写一个NIO 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）

2)   目的：理解NIO 非阻塞网络编程机制

3)   代码演示

     ```java
     package com.atguigu.nio;
     
     import java.net.InetSocketAddress;
     import java.nio.ByteBuffer;
     import java.nio.channels.SelectionKey;
     import java.nio.channels.Selector;
     import java.nio.channels.ServerSocketChannel;
     import java.nio.channels.SocketChannel;
     import java.util.Iterator;
     import java.util.Set;
     
     public class NIOServer {
     
         public static void main(String[] args) throws Exception {
             // 创建 ServerSocketChannel -> ServerSocket
             ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
             // 得到一个 Selector 对象
             Selector selector = Selector.open();
             // 绑定一个端口 6666, 在服务器端监听
             serverSocketChannel.socket().bind(new InetSocketAddress(6666));
             // 设置为非阻塞
             serverSocketChannel.configureBlocking(false);
             // 把 ServerSocketChannel 注册到 selector 关心时间为 OP_ACCEPT
             serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
             // 循环等待客户端连接
             while (true) {
                 // 这里我们等待 1s, 如果没有事件发生, 返回
                 if (selector.select(1000) == 0) {
                     System.out.println("服务器等待了 1s, 无连接");
                     continue;
                 }
                 // 如果返回的 > 0, 就获取到相关的 selectionKey 集合
                 // 1. 如果返回 > 0, 表示已经获取到关注的事件
                 // 2. selector.selectedKeys() 关注事件的集合
                 // 通过 selectionKeys 反向获取通道
                 Set<SelectionKey> selectionKeys = selector.selectedKeys();
                 // 遍历 selectionKeys
                 Iterator<SelectionKey> keyIterator = selectionKeys.iterator();
                 while (keyIterator.hasNext()) {
                     // 获取到 SelectionKey
                     SelectionKey key = keyIterator.next();
                     // 根据 key 对应的通道发生的事件做相应的处理
                     if (key.isAcceptable()) { // 如果是 OP_ACCEPT, 代表有客户端连接
                         // 给该客户端生成一个 SocketChannel
                         SocketChannel socketChannel = serverSocketChannel.accept();
                         // 将 socketChannel 设置为非阻塞
                         socketChannel.configureBlocking(false);
                         // 将 SocketChannel 注册到 Selector 上, 关注事件为 OP_READ, 同时给 SocketChannel 关联一个 Buffer
                         socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024));
                     }
                     if (key.isReadable()) { // 发生 OP_READ
                         // 通过 key, 反向获取到对应的 Channel
                         SocketChannel channel = (SocketChannel) key.channel();
                         // 获取到该 channel 关联的 buffer
                         ByteBuffer byteBuffer = (ByteBuffer) key.attachment();
                         // 读取数据
                         channel.read(byteBuffer);
                         System.out.println("from 客户端 " + new String(byteBuffer.array()));
                     }
                     // 手动从集合当中移除当前的 selectionKey, 防止重复操作
                     keyIterator.remove();
                 }
             }
         }
     
     }
     
     ```

     ```java
     package com.atguigu.nio;
     
     import java.io.IOException;
     import java.net.InetSocketAddress;
     import java.nio.ByteBuffer;
     import java.nio.channels.SocketChannel;
     
     public class NIOClient {
     
         public static void main(String[] args) throws IOException {
             // 得到一个网络通道
             SocketChannel socketChannel = SocketChannel.open();
             // 设置非阻塞模式
             socketChannel.configureBlocking(false);
             // 提供服务器端 ip, port
             InetSocketAddress inetSocketAddress = new InetSocketAddress("127.0.0.1", 6666);
             // 可以连接服务器了
             if (!socketChannel.connect(inetSocketAddress)) {
                 while (!socketChannel.finishConnect()) {
                     System.out.println("因为连接需要时间, 客户端不会阻塞, 可以坐其他工作");
                 }
             }
             // 如果连接成功, 就发送数据
             String str = "hello, 尚硅谷";
             ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());
             // 发送数据, 将 buffer 数据写入 channel
             socketChannel.write(buffer);
             System.in.read();
         }
     
     }
     
     ```



### SelectionKey

SelectionKey，表示Selector 和网络通道的注册关系, 共四种:

*   int OP_ACCEPT：有新的网络连接可以accept，值为16
*   int OP_CONNECT：代表连接已经建立，值为8
*   int OP_READ：代表读操作，值为1
*   int OP_WRITE：代表写操作，值为4

源码中：

*   public static final int OP_READ = 1 << 0;
*   public static final int OP_WRITE = 1 << 2;
*   public static final int OP_CONNECT = 1 << 3;
*   public static final int OP_ACCEPT = 1 << 4;

SelectionKey 相关方法

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_17.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_17.png" />



### ServerSocketChannel

ServerSocketChannel 在服务器端监听新的客户端Socket 连接

相关方法如下

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_18.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_18.png" />

### SocketChannel

SocketChannel，网络IO 通道，具体负责进行读写操作。NIO 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。

相关方法如下

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_19.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_19.png" />

### NIO 网络编程应用实例-群聊系统

实例要求:

1.   编写一个NIO 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）

2.   实现多人群聊

3.   服务器端：可以监测用户上线，离线，并实现消息转发功能

4.   客户端：通过channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(有服务器转发得到)

5.   目的：进一步理解NIO 非阻塞网络编程机制

6.   示意图分析和代码

     <img src="https://miaomiaoqi.github.io/images/net/netty/netty_20.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_20.png" />

     ```java
     package com.atguigu.nio.groupchat;
     
     import java.io.IOException;
     import java.net.InetSocketAddress;
     import java.nio.ByteBuffer;
     import java.nio.channels.Channel;
     import java.nio.channels.SelectionKey;
     import java.nio.channels.Selector;
     import java.nio.channels.ServerSocketChannel;
     import java.nio.channels.SocketChannel;
     import java.util.Iterator;
     
     public class GroupChatServer {
     
         // 定义属性
         private Selector selector;
         private ServerSocketChannel listenChannel;
         private static final int PORT = 6667;
     
         // 构造器, 初始化工作
         public GroupChatServer() {
             try {
                 // 得到选择器
                 selector = Selector.open();
                 // ServerSocketChannel
                 listenChannel = ServerSocketChannel.open();
                 // 绑定端口
                 listenChannel.socket().bind(new InetSocketAddress(PORT));
                 // 设置非阻塞模式
                 listenChannel.configureBlocking(false);
                 // 将该 listenChannel 注册到 selector
                 listenChannel.register(selector, SelectionKey.OP_ACCEPT);
             } catch (IOException e) {
                 e.printStackTrace();
             }
         }
     
         // 监听
         public void listen() {
             try {
                 // 循环处理
                 while (true) {
                     int count = selector.select();
                     if (count > 0) { // 有事件处理
                         // 遍历得到 selectionKey 集合
                         Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
                         while (iterator.hasNext()) {
                             // 取出 SelectionKey
                             SelectionKey key = iterator.next();
                             // 监听到 accept
                             if (key.isAcceptable()) {
                                 SocketChannel socketChannel = listenChannel.accept();
                                 // 将该 sc 注册到 selector
                                 socketChannel.configureBlocking(false);
                                 socketChannel.register(selector, SelectionKey.OP_READ);
                                 // 提示
                                 System.out.println(socketChannel.getRemoteAddress() + " 上线");
                             }
                             if (key.isReadable()) { // 通道发生 read 事件, 即通道是可读事件s
                                 // 处理读, 专门写方法
                                 readData(key);
                             }
                             // 当前的 key 删除, 防止重复读
                             iterator.remove();
                         }
                     } else {
                         System.out.println("等待...");
                     }
                 }
             } catch (Exception e) {
                 e.printStackTrace();
             } finally {
     
             }
         }
     
         // 读取客户端信息
         private void readData(SelectionKey selectionKey) {
             // 定义一个 SocketChannel
             SocketChannel channel = null;
             try {
                 // 取到关联的 channel
                 channel = (SocketChannel) selectionKey.channel();
                 // 创建 buffer
                 ByteBuffer buffer = ByteBuffer.allocate(1024);
                 int count = channel.read(buffer);
                 // 根据 count 的值做处理
                 if (count > 0) {
                     // 把缓存区数据转成字符串
                     String msg = new String(buffer.array());
                     // 输出该消息F
                     System.out.println("from 客户端: " + msg);
                     // 向其他客户端转发消息(去掉自己), 专门写一个方法处理
                     sendInfoToOtherClients(msg, channel);
                 }
             } catch (IOException e) {
                 try {
                     System.out.println(channel.getRemoteAddress() + " 离线了");
                     // 取消注册
                     selectionKey.cancel();
                     // 关闭通道
                     channel.close();
                 } catch (IOException ex) {
                     ex.printStackTrace();
                 }
             }
         }
     
         // 转发消息给其他客户(通道)
         private void sendInfoToOtherClients(String msg, SocketChannel self) throws IOException {
             System.out.println("服务器转发消息");
             // 遍历所有注册到 selector 上的 SocketChannel, 并排除 self
             for (SelectionKey key : selector.keys()) {
                 // 通过 key 取出对应的 socketChannel
                 Channel targetChannel = key.channel();
                 // 排除自己
                 if (targetChannel instanceof SocketChannel && targetChannel != self) {
                     // 转型
                     SocketChannel dest = (SocketChannel) targetChannel;
                     // 将 msg 存储到 buffer
                     ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());
                     // 将 buffer 的数据写入到通道
                     dest.write(buffer);
                 }
             }
         }
     
         public static void main(String[] args) {
             // 创建服务器对象
             GroupChatServer groupChatServer = new GroupChatServer();
             groupChatServer.listen();
         }
     
     }
     
     
     ```

     ```java
     package com.atguigu.nio.groupchat;
     
     import java.net.InetSocketAddress;
     import java.nio.ByteBuffer;
     import java.nio.channels.SelectionKey;
     import java.nio.channels.Selector;
     import java.nio.channels.SocketChannel;
     import java.util.Iterator;
     import java.util.Scanner;
     
     public class GroupChatClient {
     
         // 定义相关属性
         private final String HOST = "127.0.0.1";
         private final int PORT = 6667;
         private Selector selector;
         private SocketChannel socketChannel;
         private String username;
     
         // 构造器, 完成初始化操作
         public GroupChatClient() throws Exception {
             selector = Selector.open();
             // 连接服务器
             socketChannel = SocketChannel.open(new InetSocketAddress(HOST, PORT));
             // 设置非阻塞
             socketChannel.configureBlocking(false);
             // 将 channel 注册到 selector
             socketChannel.register(selector, SelectionKey.OP_READ);
             // 得到 username
             username = socketChannel.getLocalAddress().toString().substring(1);
             System.out.println(username + " is ok...");
         }
     
         // 向服务器发送数据
         public void sendInfo(String info) {
             info = username + " 说: " + info;
             try {
                 socketChannel.write(ByteBuffer.wrap(info.getBytes()));
             } catch (Exception e) {
                 e.printStackTrace();
             }
         }
     
         // 从服务器读取数据
         public void readInfo() {
             try {
                 int readChannels = selector.select();
                 if (readChannels > 0) { // 有可以用的通道
                     Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
                     while (iterator.hasNext()) {
                         SelectionKey key = iterator.next();
                         if (key.isReadable()) {
                             // 得到相关的通道
                             SocketChannel socketChannel = (SocketChannel) key.channel();
                             // 得到一个 buffer
                             ByteBuffer buffer = ByteBuffer.allocate(1024);
                             // 读取数据
                             socketChannel.read(buffer);
                             // 把读到的数据转成字符串
                             String msg = new String(buffer.array());
                             System.out.println(msg.trim());
                         }
                         iterator.remove();
                     }
                 } else {
                     System.out.println("没有可以用的通道");
                 }
             } catch (Exception e) {
                 e.printStackTrace();
             }
         }
     
         public static void main(String[] args) throws Exception {
             // 启动客户端
             GroupChatClient chatClient = new GroupChatClient();
             // 启动一个线程, 每隔 3s, 从服务器端读取数据
             new Thread() {
                 public void run() {
                     while (true) {
                         chatClient.readInfo();
                         try {
                             Thread.currentThread().sleep(3000L);
                         } catch (InterruptedException e) {
                             e.printStackTrace();
                         }
                     }
                 }
             }.start();
     
             // 发送数据给服务器
             Scanner scanner = new Scanner(System.in);
             while (scanner.hasNextLine()) {
                 String s = scanner.nextLine();
                 chatClient.sendInfo(s);
             }
     
         }
     
     }
     
     
     ```



### NIO 与零拷贝

#### 零拷贝基本介绍

零拷贝是网络编程的关键，很多性能优化都离不开。

在Java 程序中，常用的零拷贝有mmap(内存映射) 和sendFile。那么，他们在OS 里，到底是怎么样的一个的设计？我们分析mmap 和sendFile 这两个零拷贝

另外我们看下NIO 中如何使用零拷贝

#### 传统IO 数据读写

Java 传统IO 和网络编程的一段代码

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_21.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_21.png" />

#### 传统IO 模型

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_22.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_22.png" />

DMA: direct memory access 直接内存拷贝(不使用CPU)

#### mmap 优化

mmap 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图

mmap 示意图

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_23.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_23.png" />

#### sendFile 优化

Linux 2.1 版本提供了sendFile 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换

示意图和小结

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_24.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_24.png" />

提示：零拷贝从操作系统角度，是没有cpu 拷贝

Linux 在2.4 版本中，做了一些修改，避免了从内核缓冲区拷贝到Socket buffer 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_25.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_25.png" />

这里其实有一次cpu 拷贝

*   kernel buffer -> socket buffer
*   但是，拷贝的信息很少，比如lenght , offset , 消耗低，可以忽略



#### 零拷贝的再次理解

我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有kernel buffer 有一份数据）。

零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的CPU 缓存伪共享以及无CPU 校验和计算。



#### mmap 和 sendFile 的区别

mmap 适合小数据量读写，sendFile 适合大文件传输。

mmap 需要4 次上下文切换，3 次数据拷贝；sendFile 需要3 次上下文切换，最少2 次数据拷贝。

sendFile 可以利用DMA 方式，减少CPU 拷贝，mmap 则不能（必须从内核拷贝到Socket 缓冲区）。



#### NIO 零拷贝案例

案例要求：

1)   使用传统的IO 方法传递一个大文件
2)   使用NIO 零拷贝方式传递(transferTo)一个大文件



### Java AIO 基本介绍

JDK 7 引入了Asynchronous I/O，即AIO。在进行I/O 编程中，常用到两种模式：Reactor 和Proactor。Java 的NIO 就是Reactor，当有事件触发时，服务器端得到通知，进行相应的处理

AIO 即NIO2.0，叫做异步不阻塞的IO。AIO 引入异步通道的概念，采用了Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用

目前AIO 还没有广泛应用，Netty 也是基于NIO, 而不是AIO， 因此我们就不详解AIO 了，有兴趣的同学可以参考<<Java 新一代网络编程模型AIO 原理及Linux 系统AIO 介绍>> http://www.52im.net/thread-306-1-1.html



### BIO、NIO、AIO 对比表

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_26.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_26.png" />



## Netty 概述

### 原生 NIO 存在的问题

NIO 的类库和API 繁杂，使用麻烦：需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。

需要具备其他的额外技能：要熟悉Java 多线程编程，因为NIO 编程涉及到Reactor 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的NIO 程序。

开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。

JDK NIO 的Bug：例如臭名昭著的Epoll Bug，它会导致Selector 空轮询，最终导致CPU 100%。直到JDK 1.7版本该问题仍旧存在，没有被根本解决

### Netty 官网说明

官网：https://netty.io/

Netty is an asynchronous event-driven network application framework

for rapid development of maintainable high performance protocol servers & clients

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_27.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_27.png" />

### Netty 的优点

Netty 对JDK 自带的NIO 的API 进行了封装，解决了上述问题。

1)   设计优雅：适用于各种传输类型的统一API 阻塞和非阻塞Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型- 单线程，一个或多个线程池.
2)   使用方便：详细记录的Javadoc，用户指南和示例；没有其他依赖项，JDK 5（Netty 3.x）或6（Netty 4.x）就足够了
3)   高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。
4)   安全：完整的SSL/TLS 和StartTLS 支持。
5)   社区活跃、不断更新：社区活跃，版本迭代周期短，发现的Bug 可以被及时修复，同时，更多的新功能会被加入

### Netty 版本说明

1)   netty 版本分为netty3.x 和netty4.x、netty5.x
2)   因为Netty5 出现重大bug，已经被官网废弃了，目前推荐使用的是Netty4.x 的稳定版本
3)   目前在官网可下载的版本netty3.x netty4.0.x 和netty4.1.x
4)   在本套课程中，我们讲解Netty4.1.x 版本
5)   netty 下载地址： https://bintray.com/netty/downloads/netty/



## Netty 高性能架构设计

### 线程模型基本介绍

1)   不同的线程模式，对程序的性能有很大影响，为了搞清Netty 线程模式，我们来系统的讲解下各个线程模式，最后看看Netty 线程模型有什么优越性.
2)   目前存在的线程模型有：
     *   传统阻塞I/O 服务模型
     *   Reactor 模式
3)   根据Reactor 的数量和处理资源池线程的数量不同，有3 种典型的实现
     *   单 Reactor 单线程；
     *   单 Reactor 多线程；
     *   主从 Reactor 多线程
4)   Netty 线程模式(Netty 主要基于主从Reactor 多线程模型做了一定的改进，其中主从Reactor 多线程模型有多个Reactor)



### 传统阻塞I/O 服务模型

#### 工作原理图

黄色的框表示对象， 蓝色的框表示线程

白色的框表示方法(API)

#### 模型特点

采用阻塞IO 模式获取输入的数据

每个连接都需要独立的线程完成数据的输入，业务处理,数据返回

#### 问题分析

当并发数很大，就会创建大量的线程，占用很大系统资源

连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在read 操作，造成线程资源浪费

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_28.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_28.png" />



### Reactor 模式

#### 针对传统阻塞I/O 服务模型的2 个缺点，解决方案：

基于I/O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理Reactor 对应的叫法: 1. 反应器模式2. 分发者模式(Dispatcher) 3. 通知者模式(notifier)

基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_29.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_29.png" />



#### I/O 复用结合线程池，就是Reactor 模式基本设计思想，如图

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_30.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_30.png" />

对上图说明:

1)   Reactor 模式，通过一个或多个输入同时传递给服务处理器的模式(基于事件驱动)
2)   服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程， 因此Reactor 模式也叫Dispatcher模式
3)   Reactor 模式使用IO 复用监听事件, 收到事件后，分发给某个线程(进程), 这点就是网络服务器高并发处理关键



#### Reactor 模式中核心组成

Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；

Handlers：处理程序执行I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I/O 事件，处理程序执行非阻塞操作。



#### Reactor 模式分类

根据Reactor 的数量和处理资源池线程的数量不同，有3 种典型的实现

1)   单Reactor 单线程
2)   单Reactor 多线程
3)   主从Reactor 多线程



### 单 Reactor 单线程

#### 原理图，并使用NIO 群聊系统验证

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_31.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_31.png" />

#### 方案说明

1)   Select 是前面I/O 复用模型介绍的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求
2)   Reactor 对象通过Select 监控客户端请求事件，收到事件后通过Dispatch 进行分发
3)   如果是建立连接请求事件，则由Acceptor 通过Accept 处理连接请求，然后创建一个Handler 对象处理连接完成后的后续业务处理
4)   如果不是建立连接事件，则Reactor 会分发调用连接对应的Handler 来响应
5)   Handler 会完成Read→业务处理→Send 的完整业务流程

结合实例：服务器端用一个线程通过多路复用搞定所有的IO 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的NIO 案例就属于这种模型。

#### 方案优缺点分析

1)   优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成
2)   缺点：性能问题，只有一个线程，无法完全发挥多核CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈
3)   缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障
4)   使用场景：客户端的数量有限，业务处理非常快速，比如Redis 在业务处理的时间复杂度O(1) 的情况

### 单 Reactor 多线程

#### 原理图

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_32.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_32.png" />

#### 对上图的小结

1)   Reactor 对象通过select 监控客户端请求事件, 收到事件后，通过dispatch 进行分发
2)   如果建立连接请求, 则右Acceptor 通过accept 处理连接请求, 然后创建一个Handler 对象处理完成连接后的各种事件
3)   如果不是连接请求，则由reactor 分发调用连接对应的handler 来处理
4)   handler 只负责响应事件，不做具体的业务处理, 通过read 读取数据后，会分发给后面的worker 线程池的某个线程处理业务
5)   worker 线程池会分配独立线程完成真正的业务，并将结果返回给handler
6)   handler 收到响应后，通过send 将结果返回给client

#### 方案优缺点分析

1)   优点：可以充分的利用多核cpu 的处理能力
2)   缺点：多线程数据共享和访问比较复杂， reactor 处理所有的事件的监听和响应，在单线程运行， 在高并发场景容易出现性能瓶颈.



### 主从Reactor 多线程

#### 工作原理图

针对单Reactor 多线程模型中，Reactor 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让Reactor 在多线程中运行

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_33.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_33.png" />

#### 上图的方案说明

1)   Reactor 主线程MainReactor 对象通过select 监听连接事件, 收到事件后，通过Acceptor 处理连接事件
2)   当Acceptor 处理连接事件后，MainReactor 将连接分配给SubReactor
3)   subreactor 将连接加入到连接队列进行监听,并创建handler 进行各种事件处理
4)   当有新事件发生时， subreactor 就会调用对应的handler 处理
5)   handler 通过read 读取数据，分发给后面的worker 线程处理
6)   worker 线程池分配独立的worker 线程进行业务处理，并返回结果
7)   handler 收到响应的结果后，再通过send 将结果返回给client
8)   Reactor 主线程可以对应多个Reactor 子线程, 即MainRecator 可以关联多个SubReactor

#### Scalable IO in Java 对Multiple Reactors 的原理图解

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_34.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_34.png" />

#### 方案优缺点说明

1)   优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。
2)   优点：父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。
3)   缺点：编程复杂度较高
4)   结合实例：这种模型在许多项目中广泛使用，包括Nginx 主从Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持

### Reactor 模式小结

#### 3 种模式用生活案例来理解

1)   单Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服
2)   单Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待
3)   主从Reactor 多线程，多个前台接待员，多个服务生



#### Reactor 模式具有如下的优点

响应快，不必为单个同步时间所阻塞，虽然Reactor 本身依然是同步的

可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销

扩展性好，可以方便的通过增加Reactor 实例个数来充分利用CPU 资源

复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性



### Netty 模型

#### 工作原理示意图1-简单版

Netty 主要基于主从Reactors 多线程模型（如图）做了一定的改进，其中主从Reactor 多线程模型有多个Reactor

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_35.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_35.png" />

#### 对上图说明

1)   BossGroup 线程维护Selector , 只关注Accecpt
2)   当接收到Accept 事件，获取到对应的SocketChannel, 封装成NIOScoketChannel 并注册到Worker 线程(事件循环), 并进行维护
3)   当Worker 线程监听到selector 中通道发生自己感兴趣的事件后，就进行处理(就由handler)， 注意handler 已经加入到通道

#### 工作原理示意图2-进阶版

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_36.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_36.png" />

#### 工作原理示意图-详细版

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_37.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_37.png" />

#### 对上图的说明小结

1)   Netty 抽象出两组线程池BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写
2)   BossGroup 和WorkerGroup 类型都是NioEventLoopGroup
3)   NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环，每一个事件循环是NioEventLoop
4)   NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个NioEventLoop 都有一个selector , 用于监听绑定在其上的socket 的网络通讯
5)   NioEventLoopGroup 可以有多个线程, 即可以含有多个NioEventLoop
6)   每个Boss NioEventLoop 循环执行的步骤有3 步
     *   轮询accept 事件
     *   处理accept 事件, 与client 建立连接, 生成NioScocketChannel , 并将其注册到某个worker NIOEventLoop 上的selector
     *   处理任务队列的任务， 即runAllTasks
7)   每个Worker NIOEventLoop 循环执行的步骤
     *   轮询read, write 事件
     *   处理i/o 事件， 即read , write 事件，在对应NioScocketChannel 处理
     *   处理任务队列的任务， 即runAllTasks
8)   每个Worker NIOEventLoop 处理业务时，会使用pipeline(管道), pipeline 中包含了channel , 即通过pipeline可以获取到对应通道, 管道中维护了很多的处理器

#### Netty 快速入门实例-TCP 服务

实例要求：使用IDEA 创建Netty 项目

1)   Netty 服务器在6668 端口监听，客户端能发送消息给服务器"hello, 服务器~"
2)   服务器可以回复消息给客户端"hello, 客户端~"
3)   目的：对Netty 线程模型有一个初步认识, 便于理解Netty 模型理论
4)   5.1 编写服务端5.2 编写客户端5.3 对netty 程序进行分析，看看netty 模型特点

说明: 创建Maven 项目，并引入Netty 包

```java
package com.atguigu.netty.simple;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;

public class NettyServer {

    public static void main(String[] args) throws InterruptedException {
        // 创建 BossGroup 和 WorkerGroup
        // 1. 创建了两个线程组 bossGroup 和 workerGroup
        // 2. bossGroup 只是处理连接请求, 真正的和客户端的业务处理, 会交给 workerGroup
        // 3. 两个都是无限循环
        // 4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数默认是 cpu 核数 * 2
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();

        try {
            // 创建服务器端启动对象, 配置参数
            ServerBootstrap bootstrap = new ServerBootstrap();
            // 使用链式编程来进行设置
            bootstrap.group(bossGroup, workerGroup) // 设置两个线程组
                    .channel(NioServerSocketChannel.class) // 使用 NioSocketChannel 作为服务器的通道实现
                    .option(ChannelOption.SO_BACKLOG, 128) // 设置线程队列等待连接个数
                    .childOption(ChannelOption.SO_KEEPALIVE, true) // 设置保持活动连接状态
                    .childHandler(new ChannelInitializer<SocketChannel>() { // 创建一个通道测试对象(匿名对象)
                        // 向 pipeline 设置处理器
                        @Override
                        protected void initChannel(SocketChannel channel) throws Exception {
                            channel.pipeline().addLast(new NettyServerHandler());
                        }
                    }); // 给我们的 WorkerGroup 的 EventLopp 的管道设置处理器

            System.out.println("...服务器 is ready");

            // 绑定一个端口, 并且同步, 生成了一个 ChannelFuture 对象
            // 启动服务器(并绑定端口)
            ChannelFuture channelFuture = bootstrap.bind(6668).sync();
            // 对关闭通道进行监听
            channelFuture.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }

}

```



```java
package com.atguigu.netty.simple;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.CharsetUtil;

/**
 * 我们自定义一个 Handler 需要继承 netty 规定好的某个 HandlerAdapter
 * 这时我们自定义的一个 Handler, 才能被称为一个 Handler
 *
 * @author miaoqi
 * @date 2024-01-17 11:57:29
 */
public class NettyServerHandler extends ChannelInboundHandlerAdapter {

    /**
     * 读取数据实际(这里我们可以读取客户端发送的消息)
     * ChannelHandlerContext ctx: 上下文对象, 含有管道 pipeline, 通道 channel, 地址
     * Object msg: 就是客户端发送的数据 默认 Object
     *
     * @author miaoqi
     * @date 2024-01-17 11:59:17
     *
     * @return
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        System.out.println("server ctx = " + ctx);
        // 讲 msg 转成一个 ByteBuf
        // ByteBuf 是 Netty 提供的, 不是 NIO 的 ByteBuffer
        ByteBuf buf = (ByteBuf) msg;
        System.out.println("客户端发送消息是: " + buf.toString(CharsetUtil.UTF_8));
        System.out.println("客户端地址: " + ctx.channel().remoteAddress());
    }

    /**
     * 数据读取完毕
     *
     * @author miaoqi
     * @date 2024-01-17 16:13:3
     *
     * @return
     */
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        // writeAndFlush 是 write + flush
        // 讲数据写入到缓冲并刷新到 channel 中
        // 一般来讲我们对这个发送的数据编码
        ctx.writeAndFlush(Unpooled.copiedBuffer("hello 客户端~", CharsetUtil.UTF_8));
    }

    /**
     * 处理异常, 一般是需要关闭通道
     *
     * @author miaoqi
     * @date 2024-01-17 16:15:27
     *
     * @return
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        ctx.close();
    }

}

```



```java
package com.atguigu.netty.simple;

import io.netty.bootstrap.Bootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;

public class NettyClient {

    public static void main(String[] args) throws InterruptedException {
        // 客户端需要一个事件循环组
        EventLoopGroup eventExecutors = new NioEventLoopGroup();

        try {
            // 创建客户端启动对象
            // 注意客户端使用的不是 ServerBootstrap 而是 Bootstrap
            Bootstrap bootstrap = new Bootstrap();
            // 设置相关参数
            bootstrap.group(eventExecutors) // 设置线程组
                    .channel(NioSocketChannel.class) // 设置客户端通道的实现类
                    .handler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            socketChannel.pipeline().addLast(new NettyClientHandler()); // 加入自己的处理器
                        }
                    });
            System.out.println("客户端 ok...");
            // 启动客户端去连接服务器
            // 关于 ChannelFuture 要分析, 涉及到 netty 的异步模型
            ChannelFuture channelFuture = bootstrap.connect("127.0.0.1", 6668).sync();
            // 给关闭通道进行监听
            channelFuture.channel().closeFuture().sync();
        } finally {
            eventExecutors.shutdownGracefully();
        }
    }

}

```



```java
package com.atguigu.netty.simple;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.CharsetUtil;

public class NettyClientHandler extends ChannelInboundHandlerAdapter {

    /**
     * 当通道就绪时就会触发该方法
     *
     * @author miaoqi
     * @date 2024-01-17 17:12:55
     *
     * @return
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        System.out.println("client: " + ctx);
        ctx.writeAndFlush(Unpooled.copiedBuffer("hello, server: 喵", CharsetUtil.UTF_8));
    }

    /**
     * 当通道有读取事件时
     *
     * @author miaoqi
     * @date 2024-01-17 17:14:50
     *
     * @return
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf byteBuf = (ByteBuf) msg;
        System.out.println("服务器回复的消息: " + byteBuf.toString(CharsetUtil.UTF_8));
        System.out.println("服务器端地址: " + ctx.channel().remoteAddress());
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        ctx.close();
    }

}

```





#### 任务队列中的 Task 有3 种典型使用场景

1)   用户程序自定义的普通任务[举例说明]

2)   用户自定义定时任务

3)   非当前Reactor 线程调用Channel 的各种方法

     例如在推送系统的业务线程里面，根据用户的标识，找到对应的Channel 引用，然后调用Write 类方法向该用户推送消息，就会进入到这种场景。最终的Write 会提交到任务队列中后被异步消费

4)   代码演示

     ```java
     package com.atguigu.netty.simple;
     
     import io.netty.buffer.Unpooled;
     import io.netty.channel.ChannelHandlerContext;
     import io.netty.channel.ChannelInboundHandlerAdapter;
     import io.netty.util.CharsetUtil;
     
     import java.util.concurrent.TimeUnit;
     
     /**
      * 我们自定义一个 Handler 需要继承 netty 规定好的某个 HandlerAdapter
      * 这时我们自定义的一个 Handler, 才能被称为一个 Handler
      *
      * @author miaoqi
      * @date 2024-01-17 11:57:29
      */
     public class NettyServerHandler extends ChannelInboundHandlerAdapter {
     
         /**
          * 读取数据实际(这里我们可以读取客户端发送的消息)
          * ChannelHandlerContext ctx: 上下文对象, 含有管道 pipeline, 通道 channel, 地址
          * Object msg: 就是客户端发送的数据 默认 Object
          *
          * @author miaoqi
          * @date 2024-01-17 11:59:17
          *
          * @return
          */
         @Override
         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
     
             // 比如我们这里有一个非常耗时的业务 -> 异步执行 -> 提交该 channel 对应的 NIOEventLoop 的 taskQueue 中
     
             // 解决方案1: 用户程序自定义的普通任务
             ctx.channel().eventLoop().execute(() -> {
                 try {
                     Thread.sleep(10000);
                     ctx.writeAndFlush(Unpooled.copiedBuffer("hello 客户端~22222", CharsetUtil.UTF_8));
                 } catch (InterruptedException e) {
                     System.out.println("发生异常: " + e.getMessage());
                 }
             });
     
             // 用户自定义定时任务 -> 该任务是提交到 scheduleTaskQueue
             ctx.channel().eventLoop().schedule(() -> {
                 try {
                     Thread.sleep(10000);
                     ctx.writeAndFlush(Unpooled.copiedBuffer("hello 客户端~444444", CharsetUtil.UTF_8));
                 } catch (InterruptedException e) {
                     System.out.println("发生异常: " + e.getMessage());
                 }
             }, 5, TimeUnit.SECONDS);
     
             System.out.println("go on...");
     
             // System.out.println("server ctx = " + ctx);
             // // 讲 msg 转成一个 ByteBuf
             // // ByteBuf 是 Netty 提供的, 不是 NIO 的 ByteBuffer
             // ByteBuf buf = (ByteBuf) msg;
             // System.out.println("客户端发送消息是: " + buf.toString(CharsetUtil.UTF_8));
             // System.out.println("客户端地址: " + ctx.channel().remoteAddress());
         }
     
         /**
          * 数据读取完毕
          *
          * @author miaoqi
          * @date 2024-01-17 16:13:3
          *
          * @return
          */
         @Override
         public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
             // writeAndFlush 是 write + flush
             // 讲数据写入到缓冲并刷新到 channel 中
             // 一般来讲我们对这个发送的数据编码
             ctx.writeAndFlush(Unpooled.copiedBuffer("hello 客户端~", CharsetUtil.UTF_8));
         }
     
         /**
          * 处理异常, 一般是需要关闭通道
          *
          * @author miaoqi
          * @date 2024-01-17 16:15:27
          *
          * @return
          */
         @Override
         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
             ctx.close();
         }
     
     }
     
     ```

     

#### 方案再说明

1)   Netty 抽象出两组线程池，BossGroup 专门负责接收客户端连接，WorkerGroup 专门负责网络读写操作。
2)   NioEventLoop 表示一个不断循环执行处理任务的线程，每个NioEventLoop 都有一个selector，用于监听绑定在其上的socket 网络通道。

3)   NioEventLoop 内部采用串行化设计，从消息的读取->解码->处理->编码->发送，始终由IO 线程NioEventLoop负责
     *   NioEventLoopGroup 下包含多个NioEventLoop
     *   每个NioEventLoop 中包含有一个Selector，一个taskQueue
     *   每个NioEventLoop 的Selector 上可以注册监听多个NioChannel
     *   每个NioChannel 只会绑定在唯一的NioEventLoop 上
     *   每个NioChannel 都绑定有一个自己的ChannelPipeline



### 异步模型

#### 基本介绍

1)   异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。
2)   Netty 中的I/O 操作是异步的，包括Bind、Write、Connect 等操作会简单的返回一个ChannelFuture。
3)   调用者并不能立刻获得结果，而是通过Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得IO 操作结果
4)   Netty 的异步模型是建立在future 和callback 的之上的。callback 就是回调。重点说Future，它的核心思想是：假设一个方法fun，计算过程可能非常耗时，等待fun 返回显然不合适。那么可以在调用fun 的时候，立马返回一个Future，后续可以通过Future 去监控方法fun 的处理过程(即： Future-Listener 机制)

#### Future 说明

1)   表示异步的执行结果, 可以通过它提供的方法来检测执行是否完成，比如检索计算等等.
2)   ChannelFuture 是一个接口： public interface ChannelFuture extends Future\<Void>我们可以添加监听器，当监听的事件发生时，就会通知到监听器. 案例说明

#### 工作原理示意图

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_38.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_38.png" />

<img src="https://miaomiaoqi.github.io/images/net/netty/netty_39.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_39.png" />

说明:

1)   在使用Netty 进行编程时，拦截操作和转换出入站数据只需要您提供callback 或利用future 即可。这使得链式操作简单、高效, 并有利于编写可重用的、通用的代码。
2)   Netty 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来

#### Future-Listener 机制

1)   当Future 对象刚刚创建时，处于非完成状态，调用者可以通过返回的ChannelFuture 来获取操作执行的状态，注册监听函数来执行完成后的操作。
2)   常见有如下操作
     *   通过isDone 方法来判断当前操作是否完成；
     *   通过isSuccess 方法来判断已完成的当前操作是否成功；
     *   通过getCause 方法来获取已完成的当前操作失败的原因；
     *   通过isCancelled 方法来判断已完成的当前操作是否被取消；
     *   通过addListener 方法来注册监听器，当操作已完成(isDone 方法返回完成)，将会通知指定的监听器；如果Future 对象已完成，则通知指定的监听器

举例说明

演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑

```java
// 绑定一个端口, 并且同步, 生成了一个 ChannelFuture 对象
// 启动服务器(并绑定端口)
ChannelFuture channelFuture = bootstrap.bind(6668).sync();

// 给 channelFuture 注册监听器, 监控我们关心的事件
channelFuture.addListener(new ChannelFutureListener() {
    @Override
    public void operationComplete(ChannelFuture channelFuture) throws Exception {
        if (channelFuture.isSuccess()) {
            System.out.println("监听端口 6668 成功");
        } else {
            System.out.println("监听端口失败");
        }
    }
});
```



### 快速入门实例-HTTP 服务

1)   实例要求：使用IDEA 创建Netty 项目

2)   Netty 服务器在6668 端口监听，浏览器发出请求"http://localhost:6668/ "

3)   服务器可以回复消息给客户端"Hello! 我是服务器5 " , 并对特定请求资源进行过滤.

4)   目的：Netty 可以做Http 服务开发，并且理解Handler 实例和客户端及其请求的关系.

5)   看老师代码演示

     ```java
     package com.atguigu.netty.http;
     
     import io.netty.bootstrap.ServerBootstrap;
     import io.netty.channel.ChannelFuture;
     import io.netty.channel.EventLoopGroup;
     import io.netty.channel.nio.NioEventLoopGroup;
     import io.netty.channel.socket.nio.NioServerSocketChannel;
     
     public class TestServer {
     
         public static void main(String[] args) throws Exception {
             EventLoopGroup bossGroup = new NioEventLoopGroup();
             EventLoopGroup workerGroup = new NioEventLoopGroup();
     
             try {
     
                 ServerBootstrap serverBootstrap = new ServerBootstrap();
                 serverBootstrap.group(bossGroup, workerGroup) //
                         .channel(NioServerSocketChannel.class) //
                         .childHandler(new TestServerInitializer());
     
                 ChannelFuture channelFuture = serverBootstrap.bind(6668).sync();
                 channelFuture.channel().closeFuture().sync();
     
             } finally {
                 bossGroup.shutdownGracefully();
                 workerGroup.shutdownGracefully();
             }
         }
     
     }
     
     ```

     ```java
     package com.atguigu.netty.http;
     
     import io.netty.channel.ChannelInitializer;
     import io.netty.channel.ChannelPipeline;
     import io.netty.channel.socket.SocketChannel;
     import io.netty.handler.codec.http.HttpServerCodec;
     
     public class TestServerInitializer extends ChannelInitializer<SocketChannel> {
     
         @Override
         protected void initChannel(SocketChannel channel) throws Exception {
             // 香管道加入处理器
             // 得到管道
             ChannelPipeline pipeline = channel.pipeline();
             // 加入一个 netty 提供的 httpServerCodec codec -> [coder - decoder]
             // HttpServerCodec 说明
             // 1. HttpServerCodec 是 netty 提供的一个编解码器
             pipeline.addLast("MyHttpServerCodec", new HttpServerCodec());
             // 2. 增加一个自定义的 handler
             pipeline.addLast("MyTestServerHandler", new TestServerHandler());
         }
     
     }
     
     ```

     ```java
     package com.atguigu.netty.http;
     
     import io.netty.buffer.ByteBuf;
     import io.netty.buffer.Unpooled;
     import io.netty.channel.ChannelHandlerContext;
     import io.netty.channel.SimpleChannelInboundHandler;
     import io.netty.handler.codec.http.DefaultFullHttpResponse;
     import io.netty.handler.codec.http.DefaultHttpResponse;
     import io.netty.handler.codec.http.HttpHeaderNames;
     import io.netty.handler.codec.http.HttpObject;
     import io.netty.handler.codec.http.HttpRequest;
     import io.netty.handler.codec.http.HttpResponseStatus;
     import io.netty.handler.codec.http.HttpVersion;
     import io.netty.util.CharsetUtil;
     
     import java.net.URI;
     
     /**
      * SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter
      * HttpObject 是 客户端和服务器端相互通信数据被封装成 HttpObject
      *
      * @author miaoqi
      * @date 2024-01-17 21:49:53
      */
     public class TestServerHandler extends SimpleChannelInboundHandler<HttpObject> {
     
         // 读取事件触发, 读取客户端数据
         @Override
         protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
             // 判断 msg 是不是 HttpObject
             if (msg instanceof HttpRequest) {
                 System.out.println("msg 类型 = " + msg.getClass());
                 System.out.println("客户端地址: " + ctx.channel().remoteAddress());
     
                 // 获取到
                 HttpRequest httpRequest = (HttpRequest) msg;
                 // 获取 uri
                 URI uri = new URI(httpRequest.uri());
                 if ("/favicon.ico".equals(uri.getPath())) {
                     System.out.println("请求了 favicon.ico, 不做响应");
                     return;
                 }
     
                 // 回复信息给浏览器[http 协议]
                 ByteBuf content = Unpooled.copiedBuffer("hello, 我是服务器", CharsetUtil.UTF_8);
                 // 构造一个 http 的响应, 即 httpResponse
                 DefaultHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);
                 response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/plain");
                 response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());
                 // 将构建好的 response 返回
                 ctx.writeAndFlush(response);
             }
         }
     
     }
     
     ```















<img src="https://miaomiaoqi.github.io/images/net/netty/netty_.png" alt="https://miaomiaoqi.github.io/images/net/netty/netty_.png" />
