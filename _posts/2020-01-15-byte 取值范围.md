---
layout: post
title: byte 取值范围
categories: [Others]
description: byte 为什么可以表示 -128
keywords: basics
---

* content
{:toc}


## 先贴上结论

计算机规定了 0000 0000 代表 0, 1000 0000 代表的 -0 没有意义, 必须找个 ~127~127 之外的数和它对应, 「人为规定 -0 就是 -128」, 而且这么做完美适合计算机做减法运算. 

## 具体分析

1. byte 占用 8 位, 每位用 0 或 1 表示, 能够表示256(2 ^ 8)个数据
2. 如果是无符号数, 这 8 位都代表**数值位**, 范围就是从 0~255(2 ^ 8 - 1) 共表示 256 个数
3. 如果是有符号数, 这 8 位分为**符号位**(最高位)和**数值位**(剩余七位), 符号位 0 表示正数, 1 表示负数
4. 按上一步的理解, 容易得到(+127: 0111 1111, +1: 0000 0001, +0: 0000 0000, -0: 1000 0000, -1: 1000 0001, -127: 1111 1111), 计算机底层定义了+0(0000 0000)就是 0, 那么“可怜的 -0”又该何去何从呢? 计算机遇到这个二进制该如何处理呢? 总不能把这两个都对应 0 吧, 这显然是资源浪费. 
5. 到这里我们都认为最高位是不参与计算数值的, 仅仅是一个符号位, 按这种思路 byte 的八位是无论如何也表示不出 -128. 而“可怜的 -0”又不知道自己代表谁, 不得而知“可怜的 -0”就是 -128.(为什么呢? 凭什么呢? 你说代表 -128 就代表 -128 呀 为什么不能是+128, -250, +250. . . . . . . )
6. 到这里我们已经很粗浅地回答了 -128~127 中的 -128 的由来, 基本也回答了这个题目. 
7. 但是对于程序员来说, 上诉的分析首先是结论正确, 但是过程错了. 错误在于负数的二进制表示是错误的, 比如 -127: 1111 1111, 这是不对的. 计算机发现了 1111 1111 会把它认为是 -1 而不是 -127. 其次没有解释为什么 -0 最后表示成 -128. **接下来会通过补码解释为什么**
8. **计算机基础知识普及: 原码, 反码, 补码**
    * 计算机存储有符号的整数是都是存储它们的补码. Java 语言都是有符号位的
    * 正数和 0 的补码, 反码是本身原码; 所以对于正数来说, 可以理解为不存在反码和补码
    * 负数的反码是是符号位不变, 其它位取反; 补码是在负数的基础上加 1(符号位不变)
    * 计算机中用补码进行加法运算
9. 接着从人的思考方式理解下当计算机处理 1111 1111 的过程, 首位是 1, 自然是负数, 而且这是补码, 那么对应的原码就是, 先减 1, 变成 1111 1110, 符号位不变, 其他取反, 变成 1000 0001, 也就是 -1 所以从 10000001 到 11111111 依次表示 -127 到 -1
10. 最后来解决这个 -128 为什么可以用 1000 0000 表示
    * 这里我分析的是 byte, 它就 8 位. 在无符号位的二进制中 128 的表示为 1000 0000. 有符号位的情况下 byte 好像无法表示+128 或 -128
    * 如果我们假设现在 byte 不是占用8位, 而是9位, 最高位是符号位. 那么 -128 就能够是 1 1000 0000, 其补码也是 1 1000 0000, 很神奇吧, 一样的. -128 的补码尾八位就是 1000 0000. 那就规定 1000 0000 是 -128 的补码, 且 -128 是没有原码和反码的, 即不能利用 1000 0000 反推其原码和反码
11. 如果你对 10 步的推导表示不太接受, 那么简单就认为计算机规定了 1000 0000 就是 -128, 是一种人为设计没有什么道理可以言(据说是印度阿三设计的). 其实这么设计也是很巧妙的, 在于: 
    * 对于如果大于 8 位的有符号整数数据类型, -128 的补码尾八位刚好是 1000 0000. 
    * 比如 127(0111 1111) 加 1(0000 0001) 刚好得到 -128(1000 0000), -128(1000 0000 ) 加 1(0000 00001) 等于-127(1000 0001) 这样从 -128~127 的反码首尾相连, 形成了一个闭环, 就像时钟一样.   
    * 在计算机中减法运算可以转换成加法运算, 比如 8-1 -> 8 + (-1) -> 补码运算: (0000 1000) + (1111 1111) = (0000 0111) 刚好是7, -128 + 127 -> (1000 0000) + (0111 1111) = (1111 1111) 刚好是 -1, -128 的补码完美的适用于减法

## 结论

计算机中负数是用补码的形式保存, 并用它参与加减法运算的, 减法会被转换为加法, 计算机中没有加法运算

反码是为了解决减法运算, 补码是为了解决反码产生的 ±0 的问题. 参考(https://blog.csdn.net/boatalways/article/details/17027573)

对人而言二进制所代表的值一定是从原码求出的, 开头如果是 1 的二进制, 一定要说明其是原码, 反码还是补码

**在原码, 反码, 补码相互转换以及求对应的十进制求值时, 符号位是绝不参与的, 但是在加减过程中, 是参与位运算的**

计算机中规定了 -0 对应的二进制就是 0, 那么 -0 就没有意义了, 必须找一个数和它对应

byte 的最小值 -128, short 的最小值 -32768, int 的最小值 -2147483648 都是用对应的 -0 的原码来进行表示, 这是人为规定的, 人为规定的, 人为规定的。但是这么规定又很巧妙, 妙在上述 11 中的三点