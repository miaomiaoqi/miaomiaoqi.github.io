---
layout: post
title: "TCP/IP 协议"
categories: [Network]
description:
keywords:
---

* content
{:toc} 


## TCP/IP 模型

TCP/IP 协议模型(Transmission Control Protocol/Internet Protocol), 包含了一系列构成互联网基础的网络协议, 是 Internet 的核心协议. 

基于 TCP/IP 的参考模型将协议分成四个层次, 它们分别是链路层, 网络层, 传输层和应用层. 下图表示 TCP/IP 模型与 OSI 模型各层的对照关系. 

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_1.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_1.png" style="zoom: 67%;" />

TCP/IP协议族按照层次由上到下, 层层包装. 最上面的是应用层, 这里面有http, ftp 等等我们熟悉的协议. 而第二层则是传输层, 著名的TCP和UDP协议就在这个层次. 第三层是网络层, IP协议就在这里, 它负责对数据加上IP地址和其他的数据以确定传输的目标. 第四层是数据链路层, 这个层次为待传送的数据加入一个以太网协议头, 并进行CRC编码, 为最后的数据传输做准备. 

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_2.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_2.png" style="zoom: 67%;" />

上图清楚地表示了TCP/IP协议中每个层的作用, 而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程. 入栈的过程, 数据发送方每层不断地封装首部与尾部, 添加一些传输的信息, 确保能传输到目的地. 出栈的过程, 数据接收方每层不断地拆除首部与尾部, 得到最终传输的数据. 

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_3.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_3.png" style="zoom: 67%;" />

上图以HTTP协议为例, 具体说明. 



## 数据链路层

物理层负责0, 1比特流与物理设备电压高低, 光的闪灭之间的互换. 数据链路层负责将0, 1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址, 一个主机会有一个MAC地址). 

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_4.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_4.png" style="zoom: 67%;" />

- 封装成帧: 把网络层数据报加头和尾, 封装成帧,帧头中包括源MAC地址和目的MAC地址. 
- 透明传输:零比特填充, 转义字符. 
- 可靠传输: 在出错率很低的链路上很少用, 但是无线链路WLAN会保证可靠传输. 
- 差错检测(CRC):接收者检测错误,如果发现差错, 丢弃该帧. 



## 网络层

### IP协议

IP协议是TCP/IP协议的核心, 所有的TCP, UDP, IMCP, IGMP的数据都以IP数据格式传输. 要注意的是, IP不是可靠的协议, 这是说, IP协议没有提供一种数据未传达以后的处理机制, 这被认为是上层协议: TCP或UDP要做的事情. 

#### 1.1 IP地址

在数据链路层中我们一般通过MAC地址来识别不同的节点, 而在IP层我们也要有一个类似的地址标识, 这就是IP地址. 

32位IP地址分为网络位和地址位, 这样做可以减少路由器中路由表记录的数目, 有了网络地址, 就可以限定拥有相同网络地址的终端都在同一个范围内, 那么路由表只需要维护一条这个网络地址的方向, 就可以找到相应的这些终端了. 

A类IP地址: 0.0.0.0~127.0.0.0 B类IP地址:128.0.0.1~191.255.0.0 C类IP地址:192.168.0.0~239.255.255.0

#### 1.2 IP协议头

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_5.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_5.png" style="zoom: 67%;" />

这里只介绍:八位的 TTL 字段. 这个字段规定该数据包在穿过多少个路由之后才会被抛弃. 某个 IP 数据包每穿过一个路由器, 该数据包的 TTL 数值就会减少1, 当该数据包的 TTL 成为零, 它就会被自动抛弃. 

这个字段的最大值也就是 255, 也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了, 根据系统的不同, 这个数字也不一样, 一般是32或者是64. 

### ARP 及 RARP 协议

ARP 是根据 IP 地址获取 MAC 地址的一种协议. 

ARP(地址解析)协议是一种解析协议, 本来主机是完全不知道这个 IP 对应的是哪个主机的哪个接口, 当主机要发送一个 IP 包的时候, 会首先查一下自己的 ARP高速缓存(就是一个 IP-MAC 地址对应表缓存). 

如果查询的 IP－MAC 值对不存在, 那么主机就向网络发送一个 ARP 协议广播包, 这个广播包里面就有待查询的IP地址, 而直接收到这份广播的包的所有主机都会查询自己的IP地址, 如果收到广播包的某一个主机发现自己符合条件, 那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机. 

而广播主机拿到 ARP 包后会更新自己的ARP缓存(就是存放 IP-MAC 对应表的地方). 发送广播的主机就会用新的 ARP 缓存数据准备好数据链路层的的数据包发送工作. 

RARP 协议的工作与此相反, 不做赘述. 

### ICMP 协议

IP 协议并不是一个可靠的协议, 它不保证数据被送达, 那么, 自然的, 保证数据送达的工作应该由其他的模块来完成. 其中一个重要的模块就是 ICMP(网络控制报文)协议. ICMP 不是高层协议, 而是IP层的协议. 

当传送IP数据包发生错误. 比如主机不可达, 路由不可达等等, ICMP 协议将会把错误信息封包, 然后传送回给主机. 给主机一个处理错误的机会, 这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因. 

## ping

ping 可以说是 ICMP 的最著名的应用, 是 TCP/IP 协议的一部分. 利用“ping”命令可以检查网络是否连通, 可以很好地帮助我们分析和判定网络故障. 

例如: 当我们某一个网站上不去的时候. 通常会 ping 一下这个网站. ping 会回显出一些有用的信息. 一般的信息如下:

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_6.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_6.png" style="zoom: 67%;" />

ping这个单词源自声纳定位, 而这个程序的作用也确实如此, 它利用ICMP协议包来侦测另一个主机是否可达. 原理是用类型码为0的ICMP发请求, 受到请求的主机则用类型码为8的ICMP回应. 



## Traceroute

Traceroute 是用来侦测主机到目的主机之间所经路由情况的重要工具, 也是最便利的工具. 

Traceroute 的原理是非常非常的有意思, 它收到到目的主机的 IP 后, 首先给目的主机发送一个 TTL=1 的 UDP 数据包, 而经过的第一个路由器收到这个数据包以后, 就自动把 TTL 减 1, 而 TTL 变为 0 以后, 路由器就把这个包给抛弃了, 并同时产生 一个主机不可达的 ICMP 数据报给主机. 主机收到这个数据报以后再发一个TTL=2 的 UDP 数据报给目的主机, 然后刺激第二个路由器给主机发 ICMP 数据 报. 如此往复直到到达目的主机. 这样, traceroute 就拿到了所有的路由器IP. 

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_7.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_7.png" style="zoom: 67%;" />



## TCP/UDP

**用户数据报协议 UDP（User Datagram Protocol）**

是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

**传输控制协议 TCP（Transmission Control Protocol）**

是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

TCP/UDP 都是是传输层协议, 但是两者具有不同的特性, 同时也具有不同的应用场景, 下面以图表的形式对比分析. 

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_8.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_8.png" style="zoom: 67%;" />

**面向报文**

面向报文的传输方式是应用层交给 UDP 多长的报文, UDP 就照样发送, 即一次发送一个报文. 因此, 应用程序必须选择合适大小的报文. 若报文太长, 则 IP 层需要分片, 降低效率. 若太短, 会是 IP 太小. 

**面向字节流**

面向字节流的话, 虽然应用程序和 TCP 的交互是一次一个数据块(大小不等), 但 TCP 把应用程序看成是一连串的无结构的字节流. TCP 有一个缓冲, 当应用程序传送的数据块太长, TCP 就可以把它划分短一些再传送. 

关于拥塞控制, 流量控制, 是 TCP 的重点, 后面讲解. 

TCP 和 UDP 协议的一些应用

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_9.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_9.png" style="zoom:50%;" />

### 什么时候应该使用 TCP? 

当对网络通讯质量有要求的时候, 比如: 整个数据要准确无误的传递给对方, 这往往用于一些要求可靠的应用, 比如HTTP, HTTPS, FTP等传输文件的协议, POP, SMTP等邮件传输的协议. 

### 什么时候应该使用 UDP? 

当对网络通讯质量要求不高的时候, 要求网络通讯速度能尽量的快, 这时就可以使用UDP. 





## TCP 连接的建立与终止

TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。

TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。

TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接；采用四次挥手来关闭一个连接。

一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。

当 TCP 接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会（提供网络利用率这部分有讲到）。

ACK 是累积的，一个确认字节号 N 的 ACK 表示所有直到 N 的字节（不包括 N）已经成功被接收了。这样的好处是如果一个 ACK 丢失，很可能后续的 ACK 就足以确认前面的报文段了。

**一个完整的 TCP 连接是双向和对称的，数据可以在两个方向上平等地流动。****给上层应用程序提供一种双工服务。****一旦建立了一个连接，这个连接的一个方向上的每个 TCP 报文段都包含了相反方向上的报文段的一个 ACK。**

序列号的作用是使得一个 TCP 接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为 TCP 使用 IP 来传输报文段，而IP 不提供重复消除或者保证次序正确的功能。

另一方面，TCP 是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此 TCP 接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。

### 三次握手

TCP是面向连接的, 无论哪一方向另一方发送数据之前, 都必须先在双方之间建立一条连接. 在TCP/IP协议中, TCP协议提供可靠的连接服务, 连接是通过三次握手进行初始化的. 三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息. 

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_10.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_10.png" style="zoom:50%;" />

**第一次握手**: 建立连接. 客户端发送连接请求报文段, 将SYN位置为1, Sequence Number为x；然后, 客户端进入SYN_SEND状态, 等待服务器的确认；

**第二次握手**: 服务器收到SYN报文段. 服务器收到客户端的SYN报文段, 需要对这个SYN报文段进行确认, 设置Acknowledgment Number为x+1(Sequence Number+1)；同时, 自己自己还要发送SYN请求信息, 将SYN位置为1, Sequence Number为y；服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中, 一并发送给客户端, 此时服务器进入SYN_RECV状态；

**第三次握手**: 客户端收到服务器的SYN+ACK报文段. 然后将Acknowledgment Number设置为y+1, 向服务器发送ACK报文段, 这个报文段发送完毕以后, 客户端和服务器端都进入ESTABLISHED状态, 完成TCP三次握手. 

**为什么要三次握手**? 

1.  第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

2.  换个易于理解的视角来看为什么要 3 次握手。

    客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。

    第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

    第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

    第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。

    而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

    经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。

    **每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？**

    而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。

    其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。

    比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。

为了防止已失效的连接请求报文段突然又传送到了服务端, 因而产生错误. 

具体例子: “已失效的连接请求报文段”的产生在这样一种情况下: client发出的第一个连接请求报文段并没有丢失, 而是在某个网络结点长时间的滞留了, 以致延误到连接释放以后的某个时间才到达server. 本来这是一个早已失效的报文段. 但server收到此失效的连接请求报文段后, 就误认为是client再次发出的一个新的连接请求. 

于是就向client发出确认报文段, 同意建立连接. 假设不采用“三次握手”, 那么只要server发出确认, 新的连接就建立了. 由于现在client并没有发出建立连接的请求, 因此不会理睬server的确认, 也不会向server发送数据. 但server却以为新的运输连接已经建立, 并一直等待client发来数据. 这样, server的很多资源就白白浪费掉了. 采用“三次握手”的办法可以防止上述现象发生. 例如刚才那种情况, client不会向server的确认发出确认. server由于收不到确认, 就知道client并没有要求建立连接. ”



TCP 三次握手就好比两个人在街上隔着50米看见了对方, 但是因为雾霾等原因不能 100% 确认, 所以要通过招手的方式相互确定对方是否认识自己. 

<img src="https://miaomiaoqi.github.io/images/net/tcp/1.png" alt="https://miaomiaoqi.github.io/images/net/tcp/1.png" style="zoom: 33%;" />

张三首先向李四招手(syn), 李四看到张三向自己招手后, 向对方点了点头挤出了一个微笑(ack). 张三看到李四微笑后确认了李四成功辨认出了自己(进入estalished状态). 

但是李四还有点狐疑, 向四周看了一看, 有没有可能张三是在看别人呢, 他也需要确认一下. 所以李四也向张三招了招手(syn), 张三看到李四向自己招手后知道对方是在寻求自己的确认, 于是也点了点头挤出了微笑(ack), 李四看到对方的微笑后确认了张三就是在向自己打招呼(进入established状态). 

于是两人加快步伐, 走到了一起, 相互拥抱. 

我们看到这个过程中一共是四个动作, 张三招手--李四点头微笑--李四招手--张三点头微笑. 其中李四连续进行了2个动作, 先是点头微笑(回复对方), 然后再次招手(寻求确认), 实际上可以将这两个动作合一, 招手的同时点头和微笑(syn+ack). 于是四个动作就简化成了三个动作, 张三招手--李四点头微笑并招手--张三点头微笑. 这就是三次握手的本质, 中间的一次动作是两个动作的合并. 

我们看到有两个中间状态, syn_sent和syn_rcvd, 这两个状态叫着「半打开」状态, 就是向对方招手了, 但是还没来得及看到对方的点头微笑. syn_sent是主动打开方的「半打开」状态, syn_rcvd是被动打开方的「半打开」状态. 客户端是主动打开方, 服务器是被动打开方. 

* syn_sent: syn package has been sent

* syn_rcvd: syn package has been received

### 四次挥手

当客户端和服务器通过三次握手建立了TCP连接以后, 当数据传送完毕, 肯定是要断开TCP连接的啊. 那对于TCP的断开连接, 这里就有了神秘的“四次分手”. 

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_11.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_11.png" style="zoom:50%;" />

**第一次分手**: 主机1(可以使客户端, 也可以是服务器端), 设置Sequence Number, 向主机2发送一个FIN报文段；此时, 主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；

**第二次分手**: 主机2收到了主机1发送的FIN报文段, 向主机1回一个ACK报文段, Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1, 我“同意”你的关闭请求；**第三次分手**: 主机2向主机1发送FIN报文段, 请求关闭连接, 同时主机2进入LAST_ACK状态；

**第四次分手**: 主机1收到主机2发送的FIN报文段, 向主机2发送ACK报文段, 然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后, 就关闭连接；此时, 主机1等待2MSL后依然没有收到回复, 则证明Server端已正常关闭, 那好, 主机1也可以关闭连接了. 





TCP 断开链接的过程和建立链接的过程比较类似, 只不过中间的两部并不总是会合成一步走, 所以它分成了 4 个动作, 张三挥手(fin)——李四伤感地微笑(ack)——李四挥手(fin)——张三伤感地微笑(ack). 

<img src="https://miaomiaoqi.github.io/images/net/tcp/3.png" alt="https://miaomiaoqi.github.io/images/net/tcp/3.png" style="zoom: 33%;" />

之所以中间的两个动作没有合并, 是因为tcp存在「半关闭」状态, 也就是单向关闭. 张三已经挥了手, 可是人还没有走, 只是不再说话, 但是耳朵还是可以继续听, 李四呢继续喊话. 等待李四累了, 也不再说话了, 朝张三挥了挥手, 张三伤感地微笑了一下, 才彻底结束了. 

上面有一个非常特殊的状态 time_wait, **它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态, 这个状态标准的持续时间是 4 分钟**, 4 分钟后才会进入到 closed 状态, 释放套接字资源. 不过在具体实现上这个时间是可以调整的. 

它就好比主动分手方要承担的责任, 是你提出的要分手, 你得付出代价. 这个后果就是持续 4 分钟的 time_wait 状态, 不能释放套接字资源(端口), 就好比守寡期, 这段时间内套接字资源(端口)不得回收利用. 

**它的作用是重传最后一个 ack 报文, 确保对方可以收到**. 因为如果对方没有收到ack的话, 会重传fin报文, 处于 time_wait 状态的套接字会立即向对方重发 ack 报文. 

同时在这段时间内, 该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖, 数据报文走的时间太长, 重传的报文都收到了, 原始报文还在路上)传过来时, 都会被立即丢弃掉. 4分钟的时间足以使得这些残留报文彻底消逝. 不然当新的端口被重复利用时, 这些残留报文可能会干扰新的链接. 

4 分钟就是 2 个MSL, 每个MSL是 2 分钟. MSL 就是 maximium segment lifetime——最长报文寿命. 这个时间是由官方RFC协议规定的. 2MSL 是因为最后一个 ack 的最大传输时间是 1 个 MSL, 如果被动一方没有收到会重发一个 fin, 这个 fin 的最大传输时间也是 1 个 MSL 时间, 两者加起来是 2MSL, 主动的一方如果在2MSL时间内没有收到被动一方重发的 fin, 代表 ack 成功, 所以主动一方需要等待 2MSL 时间

四次挥手也并不总是四次挥手, 中间的两个动作有时候是可以合并一起进行的, 这个时候就成了三次挥手, 主动关闭方就会从 fin_wait_1 状态直接进入到time_wait 状态, 跳过了 fin_wait_2 状态. 


1. LISTENING 状态

    FTP 服务启动后首先处于侦听(LISTENING)状态. 

2. ESTABLISHED 状态

    ESTABLISHED的意思是建立连接. 表示两台机器正在通信. 

3. CLOSE_WAIT

    对方主动关闭连接或者网络异常导致连接中断, 这时我方的状态会变成 CLOSE_WAIT 此时我方要调用 close() 来使得连接正确关闭

4. TIME_WAIT

    我方主动调用 close() 断开连接, 收到对方确认后状态变为 TIME_WAIT. TCP 协议规定 TIME_WAIT 状态会一直持续 2MSL(即两倍的分段最大生存期), 以此来确保旧的连接状态不会对新连接产生影响. 处于 TIME_WAIT 状态的连接占用的资源不会被内核释放, 所以作为服务器, 在可能的情况下, 尽量不要主动断开连接, 以减少 TIME_WAIT 状态造成的资源浪费. 



### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

1.  TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。

2.  这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，也就是说，服务端收到客户端的 FIN 标志，知道客户端想要断开这次连接了，但是，我服务端，我还想发数据呢？我等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK确认关闭连接。

    注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。

3.  客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

4.  因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发。

TCP协议是一种面向连接的, 可靠的, 基于字节流的运输层通信协议. TCP是全双工模式, 这就意味着, 当主机1发出FIN报文段时, 只是表示主机1已经没有数据要发送了, 主机1告诉主机2, 它的数据已经全部发送完毕了；但是, 这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时, 表示它已经知道主机1没有数据发送了, 但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时, 这个时候就表示主机2也没有数据要发送了, 就会告诉主机1, 我也没有数据要发送了, 之后彼此就会愉快的中断这次TCP连接. 

### 为什么要等待 2MSL? 

MSL: 报文段最大生存时间, 它是任何报文段被丢弃前在网络内的最长时间. 原因有二: 

- 保证TCP协议的全双工连接能够可靠关闭
- 保证这次连接的重复数据段从网络中消失

第一点: 如果主机1直接CLOSED了, 那么由于IP协议的不可靠性或者是其它网络原因, 导致主机2没有收到主机1最后回复的ACK. 那么主机2就会在超时之后继续发送FIN, 此时由于主机1已经CLOSED了, 就找不到与重发的FIN对应的连接. 所以, 主机1不是直接进入CLOSED, 而是要保持TIME_WAIT, 当再次收到FIN的时候, 能够保证对方收到ACK, 最后正确的关闭连接. 

第二点: 如果主机 1 直接 CLOSED, 然后又再向主机 2 发起一个新连接, 我们不能保证这个新连接与刚关闭的连接的端口号是不同的. 也就是说有可能新连接和老连接的端口号是相同的. 一般来说不会发生什么问题, 但是还是有特殊情况出现: 假设新连接和已经关闭的老连接端口号是一样的, 如果前一次连接的某些数据仍然滞留在网络中, 这些延迟数据在建立新连接之后才到达主机 2, 由于新连接和老连接的端口号是一样的, TCP 协议就认为那个延迟的数据是属于新连接的, 这样就和真正的新连接的数据包发生混淆了. 所以 TCP 连接还要在 TIME_WAIT 状态等待 2 倍 MSL, 这样可以保证本次连接的所有数据都从网络中消失. 



## TCP 短连接和长连接的区别

**短连接：**Client 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。

短连接的优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。

**长连接：**Client 与 Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

在长连接的应用场景下，Client 端一般不会主动关闭它们之间的连接，Client 与 Server 之间的连接如果一直不关闭的话，随着客户端连接越来越多，Server 压力也越来越大，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；如果条件再允许可以以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务。

长连接和短连接的产生在于 Client 和 Server 采取的关闭策略，具体的应用场景采用具体的策略。



## TCP 粘包、拆包及解决办法

**为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？**

由前两节可知，UDP 是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。

而 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；另外从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。

**什么是粘包、拆包？**

假设 Client 向 Server 连续发送了两个数据包，用 packet1 和 packet2 来表示，那么服务端收到的数据可以分为三种情况，现列举如下：

第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_17.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_17.png" style="zoom: 33%;" />

第二种情况，接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_18.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_18.png" style="zoom: 33%;" />

第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_19.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_19.png" style="zoom: 33%;" />

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_20.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_20.png" style="zoom: 33%;" />

**为什么会发生 TCP 粘包、拆包？**

-   要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
-   待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
-   要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
-   接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

**粘包、拆包解决办法**

由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：

-   **消息定长：**发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
-   **设置消息边界：**服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。
-   **将消息分为消息头和消息体：**消息头中包含表示消息总长度（或者消息体长度）的字段。
-   更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。



## TCP 数据传输

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_21.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_21.png" style="zoom: 33%;" />

其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_22.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_22.png" style="zoom: 33%;" />

其中 RTTd 为偏差的加权平均值。



TCP 数据传输就是两个人隔空对话, 差了一点距离, 所以需要对方反复确认听见了自己的话. 

<img src="https://miaomiaoqi.github.io/images/net/tcp/2.png" alt="https://miaomiaoqi.github.io/images/net/tcp/2.png" style="zoom: 25%;" />

张三喊了一句话(data), 李四听见了之后要向张三回复自己听见了(ack). 

如果张三喊了一句, 半天没听到李四回复, 张三就认为自己的话被大风吹走了, 李四没听见, 所以需要重新喊话, 这就是tcp重传. 

也有可能是李四听到了张三的话, 但是李四向张三的回复被大风吹走了, 以至于张三没听见李四的回复. 张三并不能判断究竟是自己的话被大风吹走了还是李四的回复被大风吹走了, 张三也不用管, 重传一下就是. 

既然会重传, 李四就有可能同一句话听见了两次, 这就是「去重」. 「重传」和「去重」工作操作系统的网络内核模块都已经帮我们处理好了, 用户层是不用关心的. 



张三可以向李四喊话, 同样李四也可以向张三喊话, 因为tcp链接是「双工的」, 双方都可以主动发起数据传输. 不过无论是哪方喊话, 都需要收到对方的确认才能认为对方收到了自己的喊话. 

张三可能是个高射炮, 一说连说了八句话, 这时候李四可以不用一句一句回复, 而是连续听了这八句话之后, 一起向对方回复说前面你说的八句话我都听见了, 这就是批量ack. 但是张三也不能一次性说了太多话, 李四的脑子短时间可能无法消化太多, 两人之间需要有协商好的合适的发送和接受速率, 这个就是「TCP窗口大小」. 

网络环境的数据交互同人类之间的对话还要复杂一些, 它存在数据包乱序的现象. 同一个来源发出来的不同数据包在「网际路由」上可能会走过不同的路径, 最终达到同一个地方时, 顺序就不一样了. 操作系统的网络内核模块会负责对数据包进行排序, 到用户层时顺序就已经完全一致了. 



## TCP 滑动窗口

TCP 协议中使用

维持发送方/接收方缓冲区, 解决网络传输中不可靠问题

如果没有滑动窗口就需要发送方每发送一个包, 接收方就要确认一次, 吞吐率非常低, 改进后可以一次发送多个包, 接收方一次确认多个包就可以了, 但一次发送多个包就会有顺序, 重复, 丢包的现象产生, 通过滑动窗口可以解决一次发送多个包带来的问题

假设窗口的长度是 7, 那么最多一次可以发送 7 个数据包, 发送方按顺序将数据包发送, 接收方必须按顺序返回 ACK, 滑动窗口右移继续发送数据包, 当发送失败或 ack 失败时, 发送方会进行重发数据包, 接收方按顺序返回时, 发送方的滑动窗口右移继续发送剩下的数据包

<img src="https://miaomiaoqi.github.io/images/imooc/interview/net_1.png" alt="https://miaomiaoqi.github.io/images/imooc/interview/net_1.png" style="zoom: 25%;" />

<img src="https://miaomiaoqi.github.io/images/imooc/interview/net_2.png" alt="https://miaomiaoqi.github.io/images/imooc/interview/net_2.png" style="zoom: 25%;" />





## TCP 流量控制

如果发送方把数据发送得过快, 接收方可能会来不及接收, 这就会造成数据的丢失. 所谓流量控制就是让发送方的发送速率不要太快, 要让接收方来得及接收. 

利用**滑动窗口机制**可以很方便地在TCP连接上实现对发送方的流量控制. 

设A向B发送数据. 在连接建立时, B告诉了A: “我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) . 因此, 发送方的发送窗口不能超过接收方给出的接收窗口的数值. 请注意, TCP的窗口单位是字节, 不是报文段. 假设每一个报文段为100字节长, 而数据报文段序号的初始值设为1. 大写ACK表示首部中的确认位ACK, 小写ack表示确认字段的值ack. 



<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_12.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_12.png" style="zoom: 67%;" />

从图中可以看出, B进行了三次流量控制. 第一次把窗口减少到 rwnd = 300 , 第二次又减到了 rwnd = 100 , 最后减到 rwnd = 0 , 即不允许发送方再发送数据了. 这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止. B向A发送的三个报文段都设置了 ACK = 1 , 只有在ACK=1时确认号字段才有意义. 

TCP为每一个连接设有一个持续计时器(persistence timer). 只要TCP连接的一方收到对方的零窗口通知, 就启动持续计时器. 若持续计时器设置的时间到期, 就发送一个零窗口控测报文段(携1字节的数据), 那么收到这个报文段的一方就重新设置持续计时器. 



## TCP 拥塞控制

发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量. 拥塞窗口的大小取决于网络的拥塞程度, 并且动态地在变化. 发送方让自己的发送窗口等于拥塞窗口. 

发送方控制拥塞窗口的原则是: 只要网络没有出现拥塞, 拥塞窗口就再增大一些, 以便把更多的分组发送出去. 但只要网络出现拥塞, 拥塞窗口就减小一些, 以减少注入到网络中的分组数. 

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

**慢开始算法** 

当主机开始发送数据时, 如果立即所大量数据字节注入到网络, 那么就有可能引起网络拥塞, 因为现在并不清楚网络的负荷情况. 因此, 较好的方法是 先探测一下, 即由小到大逐渐增大发送窗口, 也就是说, 由小到大逐渐增大拥塞窗口数值. 

发送方控制拥塞窗口的原则是

* 只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。
* 但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。

通常在刚刚开始发送报文段时, 先把拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值. 而在每收到一个对新的报文段的确认后, 把拥塞窗口增加至多一个MSS 的数值. 用这样的方法逐步增大发送方的拥塞窗口 cwnd , 可以使分组注入到网络的速率更加合理. 

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_13.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_13.png" style="zoom:50%;" />

每经过一个传输轮次, 拥塞窗口 cwnd 就加倍. 一个传输轮次所经历的时间其实就是往返时间 **RTT**. 不过“传输轮次”更加强调: 把拥塞窗口cwnd所允许发送的报文段都连续发送出去, 并收到了对已发送的最后一个字节的确认. 

另, 慢开始的“慢”并不是指 cwnd 的增长速率慢, 而是指在 TCP 开始发送报文段时先设置 cwnd=1, 使得发送方在开始时只发送一个报文段(目的是试探一下网络的拥塞情况), 然后再逐渐增大 cwnd. 

为了防止拥塞窗口 cwnd 增长过大引起网络拥塞, 还需要设置一个慢开始门限 ssthresh 状态变量. 慢开始门限 ssthresh 的用法如下: 

- 当 cwnd < ssthresh 时, 使用上述的慢开始算法. 
- 当 cwnd > ssthresh 时, 停止使用慢开始算法而改用拥塞避免算法. 
- 当 cwnd = ssthresh 时, 既可使用慢开始算法, 也可使用拥塞控制避免算法. 拥塞避免

**拥塞避免算法**

让拥塞窗口cwnd缓慢地增大, 即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1, 而不是加倍. 这样拥塞窗口cwnd按线性规律缓慢增长, 比慢开始算法的拥塞窗口增长速率缓慢得多. 

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_14.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_14.png" style="zoom: 67%;" />

无论在慢开始阶段还是在拥塞避免阶段, 只要发送方判断网络出现拥塞(其根据就是没有收到确认), 就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半(但不能小于2). 然后把拥塞窗口cwnd重新设置为1, 执行慢开始算法. 

这样做的目的就是要迅速减少主机发送到网络中的分组数, 使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕. 

发送端判断网络拥塞的依据：

* 传送超时，即TCP重传定时器溢出
* 收到重复的确认报文

如下图, 用具体数值说明了上述拥塞控制的过程. 现在发送窗口的大小和拥塞窗口一样大. 

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_15.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_15.png" style="zoom: 67%;" />



**快重传算法**

快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时才进行捎带确认. 

<img src="https://miaomiaoqi.github.io/images/net/tcp/tcp_16.png" alt="https://miaomiaoqi.github.io/images/net/tcp/tcp_16.png" style="zoom: 67%;" />

接收方收到了 M1 和 M2 后都分别发出了确认. 现在假定接收方没有收到 M3 但接着收到了 M4. 

显然, 接收方不能确认 M4, 因为 M4 是收到的失序报文段. 根据 可靠传输原理, 接收方可以什么都不做, 也可以在适当时机发送一次对M2的确认. 

但按照快重传算法的规定, 接收方应及时发送对M2的重复确认, 这样做可以让 发送方及早知道报文段M3没有到达接收方. 发送方接着发送了M5和M6. 接收方收到这两个报文后, 也还要再次发出对M2的重复确认. 这样, 发送方共收到了 接收方的四个对M2的确认, 其中后三个都是重复确认. 

快重传算法还规定, 发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3, 而不必 继续等待M3设置的重传计时器到期. 

由于发送方尽早重传未被确认的报文段, 因此采用快重传后可以使整个网络吞吐量提高约20%. 

**快恢复算法**

与快重传配合使用的还有快恢复算法, 其过程有以下两个要点: 

- 当发送方连续收到三个重复确认, 就执行“乘法减小”算法, 把慢开始门限 ssthresh 减半. 
- 与慢开始不同之处是现在不执行慢开始算法(即拥塞窗口cwnd现在不设置为1), 而是把 cwnd 值设置为 慢开始门限ssthresh减半后的数值, 然后开始执行拥塞避免算法(“加法增大”), 使拥塞窗口缓慢地线性增大. 

