---
layout: post
title: "TCP/IP 协议"
categories: [Network]
description:
keywords:
---

* content
{:toc} 


## TCP/IP 模型

TCP/IP 协议模型(Transmission Control Protocol/Internet Protocol), 包含了一系列构成互联网基础的网络协议, 是 Internet 的核心协议. 

基于 TCP/IP 的参考模型将协议分成四个层次, 它们分别是链路层, 网络层, 传输层和应用层. 下图表示 TCP/IP 模型与 OSI 模型各层的对照关系. 

<img src="http://www.milky.show/images/net/tcp/tcp_1.png" alt="http://www.milky.show/images/net/tcp/tcp_1.png" style="zoom: 67%;" />

TCP/IP协议族按照层次由上到下, 层层包装. 最上面的是应用层, 这里面有http, ftp 等等我们熟悉的协议. 而第二层则是传输层, 著名的TCP和UDP协议就在这个层次. 第三层是网络层, IP协议就在这里, 它负责对数据加上IP地址和其他的数据以确定传输的目标. 第四层是数据链路层, 这个层次为待传送的数据加入一个以太网协议头, 并进行CRC编码, 为最后的数据传输做准备. 

<img src="http://www.milky.show/images/net/tcp/tcp_2.png" alt="http://www.milky.show/images/net/tcp/tcp_2.png" style="zoom: 67%;" />

上图清楚地表示了TCP/IP协议中每个层的作用, 而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程. 入栈的过程, 数据发送方每层不断地封装首部与尾部, 添加一些传输的信息, 确保能传输到目的地. 出栈的过程, 数据接收方每层不断地拆除首部与尾部, 得到最终传输的数据. 

<img src="http://www.milky.show/images/net/tcp/tcp_3.png" alt="http://www.milky.show/images/net/tcp/tcp_3.png" style="zoom: 67%;" />

上图以HTTP协议为例, 具体说明. 



## 数据链路层

物理层负责0, 1比特流与物理设备电压高低, 光的闪灭之间的互换. 数据链路层负责将0, 1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址, 一个主机会有一个MAC地址). 

<img src="http://www.milky.show/images/net/tcp/tcp_4.png" alt="http://www.milky.show/images/net/tcp/tcp_4.png" style="zoom: 67%;" />

- 封装成帧: 把网络层数据报加头和尾, 封装成帧,帧头中包括源MAC地址和目的MAC地址. 
- 透明传输:零比特填充, 转义字符. 
- 可靠传输: 在出错率很低的链路上很少用, 但是无线链路WLAN会保证可靠传输. 
- 差错检测(CRC):接收者检测错误,如果发现差错, 丢弃该帧. 



## 网络层

### IP协议

IP协议是TCP/IP协议的核心, 所有的TCP, UDP, IMCP, IGMP的数据都以IP数据格式传输. 要注意的是, IP不是可靠的协议, 这是说, IP协议没有提供一种数据未传达以后的处理机制, 这被认为是上层协议: TCP或UDP要做的事情. 

#### 1.1 IP地址

在数据链路层中我们一般通过MAC地址来识别不同的节点, 而在IP层我们也要有一个类似的地址标识, 这就是IP地址. 

32位IP地址分为网络位和地址位, 这样做可以减少路由器中路由表记录的数目, 有了网络地址, 就可以限定拥有相同网络地址的终端都在同一个范围内, 那么路由表只需要维护一条这个网络地址的方向, 就可以找到相应的这些终端了. 

A类IP地址: 0.0.0.0~127.0.0.0 B类IP地址:128.0.0.1~191.255.0.0 C类IP地址:192.168.0.0~239.255.255.0

#### 1.2 IP协议头

<img src="http://www.milky.show/images/net/tcp/tcp_5.png" alt="http://www.milky.show/images/net/tcp/tcp_5.png" style="zoom: 67%;" />

这里只介绍:八位的 TTL 字段. 这个字段规定该数据包在穿过多少个路由之后才会被抛弃. 某个 IP 数据包每穿过一个路由器, 该数据包的 TTL 数值就会减少1, 当该数据包的 TTL 成为零, 它就会被自动抛弃. 

这个字段的最大值也就是 255, 也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了, 根据系统的不同, 这个数字也不一样, 一般是32或者是64. 

### ARP 及 RARP 协议

ARP 是根据 IP 地址获取 MAC 地址的一种协议. 

ARP(地址解析)协议是一种解析协议, 本来主机是完全不知道这个 IP 对应的是哪个主机的哪个接口, 当主机要发送一个 IP 包的时候, 会首先查一下自己的 ARP高速缓存(就是一个 IP-MAC 地址对应表缓存). 

如果查询的 IP－MAC 值对不存在, 那么主机就向网络发送一个 ARP 协议广播包, 这个广播包里面就有待查询的IP地址, 而直接收到这份广播的包的所有主机都会查询自己的IP地址, 如果收到广播包的某一个主机发现自己符合条件, 那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机. 

而广播主机拿到 ARP 包后会更新自己的ARP缓存(就是存放 IP-MAC 对应表的地方). 发送广播的主机就会用新的 ARP 缓存数据准备好数据链路层的的数据包发送工作. 

RARP 协议的工作与此相反, 不做赘述. 

### ICMP 协议

IP 协议并不是一个可靠的协议, 它不保证数据被送达, 那么, 自然的, 保证数据送达的工作应该由其他的模块来完成. 其中一个重要的模块就是 ICMP(网络控制报文)协议. ICMP 不是高层协议, 而是IP层的协议. 

当传送IP数据包发生错误. 比如主机不可达, 路由不可达等等, ICMP 协议将会把错误信息封包, 然后传送回给主机. 给主机一个处理错误的机会, 这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因. 

## ping

ping 可以说是 ICMP 的最著名的应用, 是 TCP/IP 协议的一部分. 利用“ping”命令可以检查网络是否连通, 可以很好地帮助我们分析和判定网络故障. 

例如: 当我们某一个网站上不去的时候. 通常会 ping 一下这个网站. ping 会回显出一些有用的信息. 一般的信息如下:

<img src="http://www.milky.show/images/net/tcp/tcp_6.png" alt="http://www.milky.show/images/net/tcp/tcp_6.png" style="zoom: 67%;" />

ping这个单词源自声纳定位, 而这个程序的作用也确实如此, 它利用ICMP协议包来侦测另一个主机是否可达. 原理是用类型码为0的ICMP发请求, 受到请求的主机则用类型码为8的ICMP回应. 



## Traceroute

Traceroute 是用来侦测主机到目的主机之间所经路由情况的重要工具, 也是最便利的工具. 

Traceroute 的原理是非常非常的有意思, 它收到到目的主机的 IP 后, 首先给目的主机发送一个 TTL=1 的 UDP 数据包, 而经过的第一个路由器收到这个数据包以后, 就自动把 TTL 减 1, 而 TTL 变为 0 以后, 路由器就把这个包给抛弃了, 并同时产生 一个主机不可达的 ICMP 数据报给主机. 主机收到这个数据报以后再发一个TTL=2 的 UDP 数据报给目的主机, 然后刺激第二个路由器给主机发 ICMP 数据 报. 如此往复直到到达目的主机. 这样, traceroute 就拿到了所有的路由器IP. 

<img src="http://www.milky.show/images/net/tcp/tcp_7.png" alt="http://www.milky.show/images/net/tcp/tcp_7.png" style="zoom: 67%;" />



## TCP/UDP

TCP/UDP 都是是传输层协议, 但是两者具有不同的特性, 同时也具有不同的应用场景, 下面以图表的形式对比分析. 

<img src="http://www.milky.show/images/net/tcp/tcp_8.png" alt="http://www.milky.show/images/net/tcp/tcp_8.png" style="zoom: 67%;" />

**面向报文**

面向报文的传输方式是应用层交给UDP多长的报文, UDP就照样发送, 即一次发送一个报文. 因此, 应用程序必须选择合适大小的报文. 若报文太长, 则IP层需要分片, 降低效率. 若太短, 会是IP太小. 

**面向字节流**

面向字节流的话, 虽然应用程序和TCP的交互是一次一个数据块(大小不等), 但 TCP 把应用程序看成是一连串的无结构的字节流. TCP 有一个缓冲, 当应用程序传送的数据块太长, TCP 就可以把它划分短一些再传送. 

关于拥塞控制, 流量控制, 是TCP的重点, 后面讲解. 

TCP 和 UDP 协议的一些应用

<img src="http://www.milky.show/images/net/tcp/tcp_9.png" alt="http://www.milky.show/images/net/tcp/tcp_9.png" style="zoom:50%;" />

### 什么时候应该使用 TCP？

当对网络通讯质量有要求的时候, 比如: 整个数据要准确无误的传递给对方, 这往往用于一些要求可靠的应用, 比如HTTP, HTTPS, FTP等传输文件的协议, POP, SMTP等邮件传输的协议. 

### 什么时候应该使用 UDP？

当对网络通讯质量要求不高的时候, 要求网络通讯速度能尽量的快, 这时就可以使用UDP. 



## DNS

DNS(Domain Name System, 域名系统), 因特网上作为域名和 IP 地址相互映射的一个分布式数据库, 能够使用户更方便的访问互联网, 而不用去记住能够被机器直接读取的IP数串. 通过主机名, 最终得到该主机名对应的IP地址的过程叫做域名解析(或主机名解析). DNS 协议运行在 UDP 协议之上, 使用端口号 53. 



## TCP连接的建立与终止

### 三次握手

TCP是面向连接的, 无论哪一方向另一方发送数据之前, 都必须先在双方之间建立一条连接. 在TCP/IP协议中, TCP协议提供可靠的连接服务, 连接是通过三次握手进行初始化的. 三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息. 

<img src="http://www.milky.show/images/net/tcp/tcp_10.png" alt="http://www.milky.show/images/net/tcp/tcp_10.png" style="zoom:50%;" />

**第一次握手**: 建立连接. 客户端发送连接请求报文段, 将SYN位置为1, Sequence Number为x；然后, 客户端进入SYN_SEND状态, 等待服务器的确认；

**第二次握手**: 服务器收到SYN报文段. 服务器收到客户端的SYN报文段, 需要对这个SYN报文段进行确认, 设置Acknowledgment Number为x+1(Sequence Number+1)；同时, 自己自己还要发送SYN请求信息, 将SYN位置为1, Sequence Number为y；服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中, 一并发送给客户端, 此时服务器进入SYN_RECV状态；

**第三次握手**: 客户端收到服务器的SYN+ACK报文段. 然后将Acknowledgment Number设置为y+1, 向服务器发送ACK报文段, 这个报文段发送完毕以后, 客户端和服务器端都进入ESTABLISHED状态, 完成TCP三次握手. 

> 为什么要三次握手？

为了防止已失效的连接请求报文段突然又传送到了服务端, 因而产生错误. 

具体例子: “已失效的连接请求报文段”的产生在这样一种情况下: client发出的第一个连接请求报文段并没有丢失, 而是在某个网络结点长时间的滞留了, 以致延误到连接释放以后的某个时间才到达server. 本来这是一个早已失效的报文段. 但server收到此失效的连接请求报文段后, 就误认为是client再次发出的一个新的连接请求. 

于是就向client发出确认报文段, 同意建立连接. 假设不采用“三次握手”, 那么只要server发出确认, 新的连接就建立了. 由于现在client并没有发出建立连接的请求, 因此不会理睬server的确认, 也不会向server发送数据. 但server却以为新的运输连接已经建立, 并一直等待client发来数据. 这样, server的很多资源就白白浪费掉了. 采用“三次握手”的办法可以防止上述现象发生. 例如刚才那种情况, client不会向server的确认发出确认. server由于收不到确认, 就知道client并没有要求建立连接. ”



TCP 三次握手就好比两个人在街上隔着50米看见了对方, 但是因为雾霾等原因不能 100% 确认, 所以要通过招手的方式相互确定对方是否认识自己. 

<img src="http://www.milky.show/images/net/tcp/1.png" alt="http://www.milky.show/images/net/tcp/1.png" style="zoom: 33%;" />

张三首先向李四招手(syn), 李四看到张三向自己招手后, 向对方点了点头挤出了一个微笑(ack). 张三看到李四微笑后确认了李四成功辨认出了自己(进入estalished状态). 

但是李四还有点狐疑, 向四周看了一看, 有没有可能张三是在看别人呢, 他也需要确认一下. 所以李四也向张三招了招手(syn), 张三看到李四向自己招手后知道对方是在寻求自己的确认, 于是也点了点头挤出了微笑(ack), 李四看到对方的微笑后确认了张三就是在向自己打招呼(进入established状态). 

于是两人加快步伐, 走到了一起, 相互拥抱. 

我们看到这个过程中一共是四个动作, 张三招手--李四点头微笑--李四招手--张三点头微笑. 其中李四连续进行了2个动作, 先是点头微笑(回复对方), 然后再次招手(寻求确认), 实际上可以将这两个动作合一, 招手的同时点头和微笑(syn+ack). 于是四个动作就简化成了三个动作, 张三招手--李四点头微笑并招手--张三点头微笑. 这就是三次握手的本质, 中间的一次动作是两个动作的合并. 

我们看到有两个中间状态, syn_sent和syn_rcvd, 这两个状态叫着「半打开」状态, 就是向对方招手了, 但是还没来得及看到对方的点头微笑. syn_sent是主动打开方的「半打开」状态, syn_rcvd是被动打开方的「半打开」状态. 客户端是主动打开方, 服务器是被动打开方. 

* syn_sent: syn package has been sent

* syn_rcvd: syn package has been received

### 四次挥手

当客户端和服务器通过三次握手建立了TCP连接以后, 当数据传送完毕, 肯定是要断开TCP连接的啊. 那对于TCP的断开连接, 这里就有了神秘的“四次分手”. 

<img src="http://www.milky.show/images/net/tcp/tcp_11.png" alt="http://www.milky.show/images/net/tcp/tcp_11.png" style="zoom:50%;" />

**第一次分手**: 主机1(可以使客户端, 也可以是服务器端), 设置Sequence Number, 向主机2发送一个FIN报文段；此时, 主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；

**第二次分手**: 主机2收到了主机1发送的FIN报文段, 向主机1回一个ACK报文段, Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1, 我“同意”你的关闭请求；**第三次分手**: 主机2向主机1发送FIN报文段, 请求关闭连接, 同时主机2进入LAST_ACK状态；

**第四次分手**: 主机1收到主机2发送的FIN报文段, 向主机2发送ACK报文段, 然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后, 就关闭连接；此时, 主机1等待2MSL后依然没有收到回复, 则证明Server端已正常关闭, 那好, 主机1也可以关闭连接了. 





TCP 断开链接的过程和建立链接的过程比较类似, 只不过中间的两部并不总是会合成一步走, 所以它分成了 4 个动作, 张三挥手(fin)——李四伤感地微笑(ack)——李四挥手(fin)——张三伤感地微笑(ack). 

<img src="http://www.milky.show/images/net/tcp/3.png" alt="http://www.milky.show/images/net/tcp/3.png" style="zoom: 33%;" />

之所以中间的两个动作没有合并, 是因为tcp存在「半关闭」状态, 也就是单向关闭. 张三已经挥了手, 可是人还没有走, 只是不再说话, 但是耳朵还是可以继续听, 李四呢继续喊话. 等待李四累了, 也不再说话了, 朝张三挥了挥手, 张三伤感地微笑了一下, 才彻底结束了. 

上面有一个非常特殊的状态 time_wait, **它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态, 这个状态标准的持续时间是 4 分钟**, 4 分钟后才会进入到 closed 状态, 释放套接字资源. 不过在具体实现上这个时间是可以调整的. 

它就好比主动分手方要承担的责任, 是你提出的要分手, 你得付出代价. 这个后果就是持续 4 分钟的 time_wait 状态, 不能释放套接字资源(端口), 就好比守寡期, 这段时间内套接字资源(端口)不得回收利用. 

**它的作用是重传最后一个 ack 报文, 确保对方可以收到**. 因为如果对方没有收到ack的话, 会重传fin报文, 处于 time_wait 状态的套接字会立即向对方重发 ack 报文. 

同时在这段时间内, 该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖, 数据报文走的时间太长, 重传的报文都收到了, 原始报文还在路上)传过来时, 都会被立即丢弃掉. 4分钟的时间足以使得这些残留报文彻底消逝. 不然当新的端口被重复利用时, 这些残留报文可能会干扰新的链接. 

4 分钟就是 2 个MSL, 每个MSL是 2 分钟. MSL 就是 maximium segment lifetime——最长报文寿命. 这个时间是由官方RFC协议规定的. 2MSL 是因为最后一个 ack 的最大传输时间是 1 个 MSL, 如果被动一方没有收到会重发一个 fin, 这个 fin 的最大传输时间也是 1 个 MSL 时间, 两者加起来是 2MSL, 主动的一方如果在2MSL时间内没有收到被动一方重发的 fin, 代表 ack 成功, 所以主动一方需要等待 2MSL 时间

四次挥手也并不总是四次挥手, 中间的两个动作有时候是可以合并一起进行的, 这个时候就成了三次挥手, 主动关闭方就会从 fin_wait_1 状态直接进入到time_wait 状态, 跳过了 fin_wait_2 状态. 


1. LISTENING 状态

    FTP 服务启动后首先处于侦听(LISTENING)状态. 

2. ESTABLISHED 状态

    ESTABLISHED的意思是建立连接. 表示两台机器正在通信. 

3. CLOSE_WAIT

    对方主动关闭连接或者网络异常导致连接中断, 这时我方的状态会变成 CLOSE_WAIT 此时我方要调用 close() 来使得连接正确关闭

4. TIME_WAIT

    我方主动调用 close() 断开连接, 收到对方确认后状态变为 TIME_WAIT. TCP 协议规定 TIME_WAIT 状态会一直持续 2MSL(即两倍的分段最大生存期), 以此来确保旧的连接状态不会对新连接产生影响. 处于 TIME_WAIT 状态的连接占用的资源不会被内核释放, 所以作为服务器, 在可能的情况下, 尽量不要主动断开连接, 以减少 TIME_WAIT 状态造成的资源浪费. 



### 为什么要四次分手？

TCP协议是一种面向连接的, 可靠的, 基于字节流的运输层通信协议. TCP是全双工模式, 这就意味着, 当主机1发出FIN报文段时, 只是表示主机1已经没有数据要发送了, 主机1告诉主机2, 它的数据已经全部发送完毕了；但是, 这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时, 表示它已经知道主机1没有数据发送了, 但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时, 这个时候就表示主机2也没有数据要发送了, 就会告诉主机1, 我也没有数据要发送了, 之后彼此就会愉快的中断这次TCP连接. 

### 为什么要等待2MSL？

MSL: 报文段最大生存时间, 它是任何报文段被丢弃前在网络内的最长时间. 原因有二: 

- 保证TCP协议的全双工连接能够可靠关闭
- 保证这次连接的重复数据段从网络中消失

第一点: 如果主机1直接CLOSED了, 那么由于IP协议的不可靠性或者是其它网络原因, 导致主机2没有收到主机1最后回复的ACK. 那么主机2就会在超时之后继续发送FIN, 此时由于主机1已经CLOSED了, 就找不到与重发的FIN对应的连接. 所以, 主机1不是直接进入CLOSED, 而是要保持TIME_WAIT, 当再次收到FIN的时候, 能够保证对方收到ACK, 最后正确的关闭连接. 

第二点: 如果主机 1 直接 CLOSED, 然后又再向主机 2 发起一个新连接, 我们不能保证这个新连接与刚关闭的连接的端口号是不同的. 也就是说有可能新连接和老连接的端口号是相同的. 一般来说不会发生什么问题, 但是还是有特殊情况出现: 假设新连接和已经关闭的老连接端口号是一样的, 如果前一次连接的某些数据仍然滞留在网络中, 这些延迟数据在建立新连接之后才到达主机 2, 由于新连接和老连接的端口号是一样的, TCP 协议就认为那个延迟的数据是属于新连接的, 这样就和真正的新连接的数据包发生混淆了. 所以 TCP 连接还要在 TIME_WAIT 状态等待 2 倍 MSL, 这样可以保证本次连接的所有数据都从网络中消失. 



## TCP 数据传输

TCP 数据传输就是两个人隔空对话, 差了一点距离, 所以需要对方反复确认听见了自己的话. 

<img src="http://www.milky.show/images/net/tcp/2.png" alt="http://www.milky.show/images/net/tcp/2.png" style="zoom: 33%;" />

张三喊了一句话(data), 李四听见了之后要向张三回复自己听见了(ack). 

如果张三喊了一句, 半天没听到李四回复, 张三就认为自己的话被大风吹走了, 李四没听见, 所以需要重新喊话, 这就是tcp重传. 

也有可能是李四听到了张三的话, 但是李四向张三的回复被大风吹走了, 以至于张三没听见李四的回复. 张三并不能判断究竟是自己的话被大风吹走了还是李四的回复被大风吹走了, 张三也不用管, 重传一下就是. 

既然会重传, 李四就有可能同一句话听见了两次, 这就是「去重」. 「重传」和「去重」工作操作系统的网络内核模块都已经帮我们处理好了, 用户层是不用关心的. 



张三可以向李四喊话, 同样李四也可以向张三喊话, 因为tcp链接是「双工的」, 双方都可以主动发起数据传输. 不过无论是哪方喊话, 都需要收到对方的确认才能认为对方收到了自己的喊话. 

张三可能是个高射炮, 一说连说了八句话, 这时候李四可以不用一句一句回复, 而是连续听了这八句话之后, 一起向对方回复说前面你说的八句话我都听见了, 这就是批量ack. 但是张三也不能一次性说了太多话, 李四的脑子短时间可能无法消化太多, 两人之间需要有协商好的合适的发送和接受速率, 这个就是「TCP窗口大小」. 

网络环境的数据交互同人类之间的对话还要复杂一些, 它存在数据包乱序的现象. 同一个来源发出来的不同数据包在「网际路由」上可能会走过不同的路径, 最终达到同一个地方时, 顺序就不一样了. 操作系统的网络内核模块会负责对数据包进行排序, 到用户层时顺序就已经完全一致了. 



## TCP 滑动窗口

TCP 协议中使用

维持发送方/接收方缓冲区, 解决网络传输中不可靠问题

如果没有滑动窗口就需要发送方每发送一个包, 接收方就要确认一次, 吞吐率非常低, 改进后可以一次发送多个包, 接收方一次确认多个包就可以了, 但一次发送多个包就会有顺序, 重复, 丢包的现象产生, 通过滑动窗口可以解决一次发送多个包带来的问题

假设窗口的长度是 7, 那么最多一次可以发送 7 个数据包, 发送方按顺序将数据包发送, 接收方必须按顺序返回 ACK, 滑动窗口右移继续发送数据包, 当发送失败或 ack 失败时, 发送方会进行重发数据包, 接收方按顺序返回时, 发送方的滑动窗口右移继续发送剩下的数据包

<img src="http://www.milky.show/images/imooc/interview/net_1.png" alt="http://www.milky.show/images/imooc/interview/net_1.png" style="zoom:33%;" />

<img src="http://www.milky.show/images/imooc/interview/net_2.png" alt="http://www.milky.show/images/imooc/interview/net_2.png" style="zoom: 33%;" />





## TCP 流量控制

如果发送方把数据发送得过快, 接收方可能会来不及接收, 这就会造成数据的丢失. 所谓流量控制就是让发送方的发送速率不要太快, 要让接收方来得及接收. 

利用**滑动窗口机制**可以很方便地在TCP连接上实现对发送方的流量控制. 

设A向B发送数据. 在连接建立时, B告诉了A: “我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) . 因此, 发送方的发送窗口不能超过接收方给出的接收窗口的数值. 请注意, TCP的窗口单位是字节, 不是报文段. 假设每一个报文段为100字节长, 而数据报文段序号的初始值设为1. 大写ACK表示首部中的确认位ACK, 小写ack表示确认字段的值ack. 



<img src="http://www.milky.show/images/net/tcp/tcp_12.png" alt="http://www.milky.show/images/net/tcp/tcp_12.png" style="zoom: 67%;" />

从图中可以看出, B进行了三次流量控制. 第一次把窗口减少到 rwnd = 300 , 第二次又减到了 rwnd = 100 , 最后减到 rwnd = 0 , 即不允许发送方再发送数据了. 这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止. B向A发送的三个报文段都设置了 ACK = 1 , 只有在ACK=1时确认号字段才有意义. 

TCP为每一个连接设有一个持续计时器(persistence timer). 只要TCP连接的一方收到对方的零窗口通知, 就启动持续计时器. 若持续计时器设置的时间到期, 就发送一个零窗口控测报文段(携1字节的数据), 那么收到这个报文段的一方就重新设置持续计时器. 



## TCP 拥塞控制

发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量. 拥塞窗口的大小取决于网络的拥塞程度, 并且动态地在变化. 发送方让自己的发送窗口等于拥塞窗口. 

发送方控制拥塞窗口的原则是: 只要网络没有出现拥塞, 拥塞窗口就再增大一些, 以便把更多的分组发送出去. 但只要网络出现拥塞, 拥塞窗口就减小一些, 以减少注入到网络中的分组数. 

**慢开始算法** 

当主机开始发送数据时, 如果立即所大量数据字节注入到网络, 那么就有可能引起网络拥塞, 因为现在并不清楚网络的负荷情况. 因此, 较好的方法是 先探测一下, 即由小到大逐渐增大发送窗口, 也就是说, 由小到大逐渐增大拥塞窗口数值. 

发送方控制拥塞窗口的原则是

* 只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。
* 但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。

通常在刚刚开始发送报文段时, 先把拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值. 而在每收到一个对新的报文段的确认后, 把拥塞窗口增加至多一个MSS 的数值. 用这样的方法逐步增大发送方的拥塞窗口 cwnd , 可以使分组注入到网络的速率更加合理. 

<img src="http://www.milky.show/images/net/tcp/tcp_13.png" alt="http://www.milky.show/images/net/tcp/tcp_13.png" style="zoom:50%;" />

每经过一个传输轮次, 拥塞窗口 cwnd 就加倍. 一个传输轮次所经历的时间其实就是往返时间 **RTT**. 不过“传输轮次”更加强调: 把拥塞窗口cwnd所允许发送的报文段都连续发送出去, 并收到了对已发送的最后一个字节的确认. 

另, 慢开始的“慢”并不是指 cwnd 的增长速率慢, 而是指在 TCP 开始发送报文段时先设置 cwnd=1, 使得发送方在开始时只发送一个报文段(目的是试探一下网络的拥塞情况), 然后再逐渐增大 cwnd. 

为了防止拥塞窗口 cwnd 增长过大引起网络拥塞, 还需要设置一个慢开始门限 ssthresh 状态变量. 慢开始门限 ssthresh 的用法如下: 

- 当 cwnd < ssthresh 时, 使用上述的慢开始算法. 
- 当 cwnd > ssthresh 时, 停止使用慢开始算法而改用拥塞避免算法. 
- 当 cwnd = ssthresh 时, 既可使用慢开始算法, 也可使用拥塞控制避免算法. 拥塞避免

**拥塞避免算法**

让拥塞窗口cwnd缓慢地增大, 即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1, 而不是加倍. 这样拥塞窗口cwnd按线性规律缓慢增长, 比慢开始算法的拥塞窗口增长速率缓慢得多. 

<img src="http://www.milky.show/images/net/tcp/tcp_14.png" alt="http://www.milky.show/images/net/tcp/tcp_14.png" style="zoom: 67%;" />

无论在慢开始阶段还是在拥塞避免阶段, 只要发送方判断网络出现拥塞(其根据就是没有收到确认), 就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半(但不能小于2). 然后把拥塞窗口cwnd重新设置为1, 执行慢开始算法. 

这样做的目的就是要迅速减少主机发送到网络中的分组数, 使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕. 

发送端判断网络拥塞的依据：

* 传送超时，即TCP重传定时器溢出
* 收到重复的确认报文

如下图, 用具体数值说明了上述拥塞控制的过程. 现在发送窗口的大小和拥塞窗口一样大. 

<img src="http://www.milky.show/images/net/tcp/tcp_15.png" alt="http://www.milky.show/images/net/tcp/tcp_15.png" style="zoom: 67%;" />



**快重传算法**

快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时才进行捎带确认. 

<img src="http://www.milky.show/images/net/tcp/tcp_16.png" alt="http://www.milky.show/images/net/tcp/tcp_16.png" style="zoom: 67%;" />

接收方收到了 M1 和 M2 后都分别发出了确认. 现在假定接收方没有收到 M3 但接着收到了 M4. 

显然, 接收方不能确认 M4, 因为 M4 是收到的失序报文段. 根据 可靠传输原理, 接收方可以什么都不做, 也可以在适当时机发送一次对M2的确认. 

但按照快重传算法的规定, 接收方应及时发送对M2的重复确认, 这样做可以让 发送方及早知道报文段M3没有到达接收方. 发送方接着发送了M5和M6. 接收方收到这两个报文后, 也还要再次发出对M2的重复确认. 这样, 发送方共收到了 接收方的四个对M2的确认, 其中后三个都是重复确认. 

快重传算法还规定, 发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3, 而不必 继续等待M3设置的重传计时器到期. 

由于发送方尽早重传未被确认的报文段, 因此采用快重传后可以使整个网络吞吐量提高约20%. 

**快恢复算法**

与快重传配合使用的还有快恢复算法, 其过程有以下两个要点: 

- 当发送方连续收到三个重复确认, 就执行“乘法减小”算法, 把慢开始门限 ssthresh 减半. 
- 与慢开始不同之处是现在不执行慢开始算法(即拥塞窗口cwnd现在不设置为1), 而是把 cwnd 值设置为 慢开始门限ssthresh减半后的数值, 然后开始执行拥塞避免算法(“加法增大”), 使拥塞窗口缓慢地线性增大. 

