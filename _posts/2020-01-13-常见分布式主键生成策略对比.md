---
layout: post
title: "常见分布式主键生成策略对比"
categories: [Distributed]
description:
keywords:
---

* content
{:toc}


## 分布式主键

全局唯一的 ID 几乎是所有系统都会遇到的刚需。这个 id 在搜索, 存储数据, 加快检索速度 等等很多方面都有着重要的意义。工业上有多种策略来获取这个全局唯一的id

所谓全局唯一的 id 其实往往对应是**生成唯一记录标识的业务需求**。

这个 id 常常是数据库的**主键**，数据库上会建立聚集索引（cluster index），即在物理存储上以这个字段排序。这个记录标识上的查询，往往又有分页或者排序的业务需求。所以往往要有一个time字段，并且在time字段上建立普通索引（non-cluster index）。普通索引存储的是实际记录的指针，其访问效率会比聚集索引慢，如果记录标识在生成时能够基本按照时间有序，则可以省去这个time字段的索引查询。   

这就引出了记录标识生成的两大核心需求：

- **全局唯一**
- **趋势有序**

## 常见生成策略

### 数据库自增

**优点：**

1. 此方法使用数据库原有的功能，所以相对简单
2. 能够保证唯一性
3. 能够保证递增性
4. id 之间的步长是固定且可自定义的

**缺点：**

1. 可用性难以保证：数据库常见架构是 一主多从 + 读写分离，生成自增 ID 是写请求**主库挂了就玩不转了**
2. 扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定 ID 的生成性能上限，并且**难以扩展**

**改进方案:**

* 冗余主库，避免写入单点

* 数据水平切分，保证各主库生成的ID不重复, 方法一改进方案的结构图

    ![http://www.milky.show/images/distributed/id_generator/id_1.png](http://www.milky.show/images/distributed/id_generator/id_1.png)

    如上图所述，由1个写库变成3个写库，**每个写库设置不同的 auto_increment 初始值，以及相同的增长步长**，以保证每个数据库生成的ID是不同的（上图中DB 01生成0,3,6,9…，DB 02生成1,4,7,10，DB 03生成2,5,8,11…）

改进后的架构保证了可用性，但缺点是

* 丧失了 ID 生成的“绝对递增性”：先访问 DB01 生成0, 3，再访问 DB02 生成 1，可能导致在非常短的时间内，ID 生成不是绝对递增的（这个问题不大，目标是趋势递增，不是绝对递增)
* 数据库的写压力依然很大，每次生成ID都要访问数据库

### 单点批量主键生成服务

分布式系统之所以难，很重要的原因之一是“没有一个全局时钟，难以保证绝对的时序”，要想保证绝对的时序，还是只能使用单点服务，用本地时钟保证“绝对时序”。
数据库写压力大，是因为每次生成ID都访问了数据库，可以**使用批量的方式降低数据库写压力**。

![http://www.milky.show/images/distributed/id_generator/id_2.png](http://www.milky.show/images/distributed/id_generator/id_2.png)

如上图所述，数据库使用双master保证可用性，数据库中只存储当前ID的最大值，例如4

ID生成服务假设每次批量拉取5个ID，服务访问数据库，将当前ID的最大值修改为4，这样应用访问ID生成服务索要ID，ID生成服务不需要每次访问数据库，就能依次派发0,1,2,3,4这些ID了。

当ID发完后，再将ID的最大值修改为11，就能再次派发6,7,8,9,10,11这些ID了，于是数据库的压力就降低到原来的1/6。

第一次内存中没值, 将数据库 id + 5, 内存中有 5 个可以派发, 派发完后内存又没值, 数据库 id 再次 + 5, 这次又有 5 个可以派发

优点：

- 保证了主键生成的绝对递增有序
- 大大降低了数据库的压力，主键生成可以做到每秒生成几万几十万个

缺点：

- 服务仍然是单点
- 如果服务挂了，服务重启之后，继续生成的主键可能会不连续，中间出现空洞（服务内存保存着0,1,2,3,4，数据库中最大主键是4，分配到3时，服务重启了，下次会从5开始分配，3和4就成了空洞，不过这个问题不大）
- 虽然每秒可以生成几万几十万个主键，但还是有性能上限，无法进行水平扩展

改进方案

* 单点服务的常用高可用优化方案是“备用服务”，也叫“影子服务”，所以我们能用以下方法优化上述缺点：

    ![http://www.milky.show/images/distributed/id_generator/id_3.png](http://www.milky.show/images/distributed/id_generator/id_3.png)

    如上图，对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了的时候影子服务顶上。这个切换的过程对调用方是透明的，可以自动完成，常用的技术是 **vip+keepalived**。另外，id generate service 也可以进行水平扩展，以解决上述缺点，但会引发一致性问题。

### UUID / GUID

不管是通过数据库，还是通过服务来生成ID，业务方Application都需要进行一次远程调用，比较耗时。uuid是一种常见的本地生成ID的方法。

`UUID uuid = UUID.randomUUID()`

优点：

- 本地生成，不需要进行远程调用，时延低
- 扩展性好，基本可以认为没有性能上限

缺点：

- 无法保证趋势递增
- UUID 过长，往往用字符串表示，作为主键建立索引查询效率低；常见优化方案为“转化为两个uint64整数存储”或者“折半存储”，但折半后不能保证唯一性

### 取当前毫秒数

uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？ - 取当前毫秒数是一种常见方案。

优点：

- 本地生成，不需要进行远程调用，时延低
- 生成的主键趋势递增
- 生成的主键是整数，建立索引后查询效率高

缺点：

- 如果并发量超过1000(1s = 1000ms)，会生成重复的主键；改用微秒可以降低冲突概率，但每秒最多只能生成100万个主键，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题。

### 使用 Redis 自增

当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于**Redis是单线程的**，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 **INCR** 和 **INCRBY** 来实现。

优点：

- 不依赖数据库，灵活方便，且性能优于数据库
- 天然排序，对分页或者需要排序的结果很有帮助

缺点：

- 如果系统中没有Redis，还需要引入新的组件，增加系统复杂度
- 需要编码和配置的工作量比较大

### Twitter 开源的 Snowflake 算法