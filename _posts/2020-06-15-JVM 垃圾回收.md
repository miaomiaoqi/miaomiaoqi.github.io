---
layout: post
title: JVM 垃圾回收
categories: [Java]
description: 
keywords: 
---

* content
{:toc}












## 前言

Java 相比 C/C++ 最显著的特点便是引入了自动垃圾回收 (下文统一用 GC 指代自动垃圾回收), 它解决了 C/C++ 最令人头疼的内存管理问题, 让程序员专注于程序本身, 不用关心内存回收这些恼人的问题, 这也是 Java 能大行其道的重要原因之一, GC 真正让程序员的生产力得到了释放, 但是程序员很难感知到它的存在, 这就好比, 我们吃完饭后在桌上放下餐盘即走, 服务员会替你收拾好这些餐盘, 你不会关心服务员什么时候来收, 怎么收. 

有人说既然 GC 已经自动我们完成了清理,不了解 GC 貌似也没啥问题. 在大多数情况下确实没问题, 不过如果涉及到一些性能调优, 问题排查等, 深入地了解 GC 还是必不可少的, 曾经美团通过调整 JVM 相关 GC 参数让服务响应时间 TP90, TP99都下降了10ms+, 服务可用性得到了很大的提升！所以深入了解 GC 是成为一名优秀 Java 程序员的必修课！

垃圾回收分上下篇, 上篇会先讲垃圾回收理论, 主要包括

1.  GC 的几种主要的收集方法: 标记清除、标记整理、复制算法的原理与特点, 各自的优劣势
2.  为啥会有 Serial , CMS, G1 等各式样的回收器, 各自的优劣势是什么, 为啥没有一个统一的万能的垃圾回收器
3.  新生代为啥要设置成 Eden, S0,S1 这三个区, 基于什么考虑呢
4.  堆外内存不受 GC 控制, 那该怎么释放呢
5.  对象可回收, 就一定会被回收吗? 
6.  什么是 SafePoint,什么是 Stop The World

下篇主要讲垃圾回收的实践, 主要包括

1.  GC 日志格式怎么看
2.  主要有哪些发生 OOM 的场景
3.  发生 OOM, 如何定位, 常用的内存调试工具有哪些



## 什么是垃圾回收

垃圾回收(Garbage Collection, GC), 顾名思义就是释放垃圾占用的空间, 防止内存泄露. 有效的使用可以使用的内存, 对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收. 

Java 语言出来之前, 大家都在拼命的写 C 或者 C++ 的程序, 而此时存在一个很大的矛盾, C++ 等语言创建对象要不断的去开辟空间, 不用的时候又需要不断的去释放控件, 既要写构造函数, 又要写析构函数, 很多时候都在重复的 allocated, 然后不停的析构. 于是, 有人就提出, 能不能写一段程序实现这块功能, 每次创建, 释放控件的时候复用这段代码, 而无需重复的书写呢? 

1960年, 基于 MIT 的 Lisp 首先提出了垃圾回收的概念, 而这时 Java 还没有出世呢！**所以实际上 GC 并不是Java的专利, GC 的历史远远大于 Java 的历史！**



## JVM 内存区域

要搞懂垃圾回收的机制, 我们首先要知道垃圾回收主要回收的是哪些数据, 这些数据主要在哪一块区域, 所以我们一起来看下 JVM 的内存区域

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_1.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_1.png" style="zoom:67%;" />

-   虚拟机栈: 描述的是方法执行时的内存模型,是线程私有的, 生命周期与线程相同,每个方法被执行的同时会创建**栈桢**(下文会看到), 主要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息,方法执行时入栈, 方法执行完出栈, 出栈就相当于清空了数据, 入栈出栈的时机很明确, 所以这块区域**不需要进行 GC**. 

-   本地方法栈: 与虚拟机栈功能非常类似, 主要区别在于虚拟机栈为虚拟机执行 Java 方法时服务, 而本地方法栈为虚拟机执行本地方法时服务的. 这块区域也**不需要进行 GC**

-   程序计数器: 线程独有的, 可以把它看作是当前线程执行的字节码的行号指示器, 比如如下字节码内容, 在每个字节码`前面都有一个数字(行号), 我们可以认为它就是程序计数器存储的内容

    ![https://miaomiaoqi.github.io/images/jvm/gc/gc_2.png](https://miaomiaoqi.github.io/images/jvm/gc/gc_2.png)

    记录这些数字(指令地址)有啥用呢, 我们知道 Java 虚拟机的多线程是通过线程轮流切换并分配处理器的时间来完成的, 在任何一个时刻, 一个处理器只会执行一个线程, 如果这个线程被分配的时间片执行完了(线程被挂起), 处理器会切换到另外一个线程执行, 当下次轮到执行被挂起的线程(唤醒线程)时, 怎么知道上次执行到哪了呢, 通过记录在程序计数器中的行号指示器即可知道, 所以程序计数器的主要作用是记录线程运行时的状态, 方便线程被唤醒时能从上一次被挂起时的状态继续执行, 需要注意的是, 程序计数器是**唯一一个**在 Java 虚拟机规范中没有规定任何 OOM 情况的区域, 所以这块区域也**不需要进行 GC**

-   本地内存: 线程共享区域, Java 8 中, 本地内存, 也是我们通常说的**堆外内存**, 包含元空间和直接内存,注意到上图中 Java 8 和 Java 8 之前的 JVM 内存区域的区别了吗, 在 Java 8 之前有个**永久代**的概念, 实际上指的是 HotSpot 虚拟机上的永久代, 它用永久代实现了 JVM 规范定义的方法区功能, 主要存储类的信息, 常量, 静态变量, 即时编译器编译后代码等, 这部分由于是在堆中实现的, 受 GC 的管理, 不过由于永久代有 -XX:MaxPermSize 的上限, 所以如果动态生成类(将类信息放入永久代)或大量地执行 **String.intern** (将字段串放入永久代中的常量区), 很容易造成 OOM, 有人说可以把永久代设置得足够大, 但很难确定一个合适的大小, 受类数量, 常量数量的多少影响很大. 所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中, 这样方法区就不受 JVM 的控制了,也就不会进行 GC, 也因此提升了性能(发生 GC 会发生 Stop The Word,造成性能受到一定影响, 后文会提到), 也就不存在由于永久代限制大小而导致的 OOM 异常了(假设总内存1G, JVM 被分配内存 100M, 理论上元空间可以分配 2G-100M = 1.9G, 空间大小足够), 也方便在元空间中统一管理. 综上所述, 在 Java 8 以后这一区域也**不需要进行 GC**

-   堆: 前面几块数据区域都不进行 GC, 那只剩下堆了, 是的, 这里是 GC 发生的区域！对象实例和数组都是在堆上分配的, GC 也主要对这两类数据进行回收, 这块也是我们之后重点需要分析的区域



## 如何判断对象可以回收

上一节我们详细讲述了 JVM 的内存区域, 知道了 GC 主要发生在堆, 那么 GC 该怎么判断堆中的对象实例或数据是不是垃圾呢, 或者说判断某些数据是否是垃圾的方法有哪些. 

### 引用计数算法

引用计数算法(Reachability Counting)是通过在对象头中分配一个空间来保存该对象被引用的次数(Reference Count). 如果该对象被其它对象引用, 则它的引用计数加1, 如果删除对该对象的引用, 那么它的引用计数就减1, 当该对象的引用计数为0时, 那么该对象就会被回收. 

```java
String m = new String("jack");
```

先创建一个字符串, 这时候"jack"有一个引用, 就是 m. 

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_1.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_1.png" style="zoom:67%;" />

然后将 m 设置为 null, 这时候"jack"的引用次数就等于0了, 在引用计数算法中, 意味着这块内容就需要被回收了. 

```java
m = null;
```

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_2.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_2.png" style="zoom:67%;" />

**引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了, 而不是在进行垃圾收集时, 要挂起整个应用的运行, 直到对堆中所有对象的处理都结束. 因此, 采用引用计数的垃圾收集不属于严格意义上的"Stop-The-World"的垃圾收集机制. **

**看似很美好, 但我们知道JVM的垃圾回收就是"Stop-The-World"的, 那是什么原因导致我们最终放弃了引用计数算法呢? 看下面的例子. **

```java
public class ReferenceCountingGC {

    public Object instance;

    public ReferenceCountingGC(String name){}
}

public static void testGC(){

    ReferenceCountingGC a = new ReferenceCountingGC("objA");
    ReferenceCountingGC b = new ReferenceCountingGC("objB");

    a.instance = b;
    b.instance = a;

    a = null;
    b = null;
}
```

1. 定义 2 个对象

2. 相互引用

3. 置空各自的声明引用

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_3.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_3.png" style="zoom:67%;" />

**我们可以看到, 最后这 2 个对象已经不可能再被访问了, 但由于他们相互引用着对方, 导致它们的引用计数永远都不会为 0, 通过引用计数算法, 也就永远无法通知 GC 收集器回收它们. **

### 可达性分析算法

可达性分析算法(Reachability Analysis)的基本思路是, 通过一些被称为引用链(GC Roots)的对象作为起点, 从这些节点开始向下搜索, 搜索走过的路径被称为(Reference Chain), 当一个对象到 GC Roots 没有任何引用链相连时(即从 GC Roots 节点到该节点不可达)则证明该对象是不可用的. 

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_4.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_4.png" style="zoom:67%;" />

通过可达性算法, 成功解决了引用计数所无法解决的问题-“循环依赖”, 只要你无法与 GC Root 建立直接或间接的连接, 系统就会判定你为可回收对象. 那这样就引申出了另一个问题, 哪些属于 GC Root. 

#### Java 内存区域

在 Java 语言中, 可作为 GC Root 的对象包括以下4种: 

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI(即一般说的 Native 方法)引用的对象

**GC Roots 并不包括堆中对象所引用的对象, 这样就不会有循环引用的问题. **

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_5.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_5.png" style="zoom:67%;" />

**虚拟机栈(栈帧中的本地变量表)中引用的对象**

如下代码所示, a 是栈帧中的本地变量, 当 a = null 时, 由于此时 a 充当了 **GC Root** 的作用, a 与原来指向的实例 **new Test()** 断开了连接, 所以对象会被回收. 

```java
public class Test {
    public static  void main(String[] args) {
	    Test a = new Test();
	    a = null;
    }
}
```

**方法区中类静态属性引用的对象**

如下代码所示, 当栈帧中的本地变量 a = null 时, 由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接, 所以 a 原来指向的对象会被回收, 而由于我们给 s 赋值了变量的引用, s 在此时是类静态属性引用, 充当了 GC Root 的作用, 它指向的对象依然存活!

```java
public class Test {
    public static Test s;
    public static  void main(String[] args) {
	    Test a = new Test();
	    a.s = new Test();
	    a = null;
    }
}
```

**方法区中常量引用的对象**

如下代码所示, 常量 s 指向的对象并不会因为 a 指向的对象被回收而回收

```java
public class Test {
	public static final Test s = new Test();
    public static void main(String[] args) {
	    Test a = new Test();
	    a = null;
    }
}
```

**本地方法栈中引用的对象**

这是简单给不清楚本地方法为何物的童鞋简单解释一下: 所谓本地方法就是一个 java 调用非 java 代码的接口, 该方法并非 Java 实现的, 可能由 C 或 Python等其他语言实现的, Java 通过 JNI 来调用本地方法, 而本地方法是以库文件的形式存放的(在 WINDOWS 平台上是 DLL 文件形式, 在 UNIX 机器上是 SO 文件形式). 通过调用本地的库文件的内部方法, 使 JAVA 可以实现和本地机器的紧密联系, 调用系统级的各接口方法, 还是不明白? 见文末参考, 对本地方法定义与使用有详细介绍. 

当调用 Java 方法时, 虚拟机会创建一个栈桢并压入 Java 栈, 而当它调用的是本地方法时, 虚拟机会保持 Java 栈不变, 不会在 Java 栈祯中压入新的祯, 虚拟机只是简单地动态连接并直接调用指定的本地方法. 

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_6.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_6.png" style="zoom:67%;" />

```java
JNIEXPORT void JNICALL Java_com_pecuyu_jnirefdemo_MainActivity_newStringNative(JNIEnv *env, jobject instance, jstring jmsg) {
...
   // 缓存String的class
   jclass jc = (*env)->FindClass(env, STRING_PATH);
}
```

如上代码所示, 当 java 调用以上本地方法时, jc 会被本地方法栈压入栈中, jc 就是我们说的本地方法栈中 JNI 的对象引用, 因此只会在此本地方法执行完成后才会被释放. 

### 四种引用

1.  强引用

    只有所有 GC Roots 对象都不通过【强引用】引用该对象, 该对象才能被垃圾回收, 就算出现了 OOM 也不会对该对象进行回收

2.  软引用(SoftReference)

    仅有软引用引用该对象时, 在垃圾回收后, 内存仍不足时会再次出发垃圾回收, 回收软引用对象

    可以配合引用队列来释放软引用自身

3.  弱引用(WeakReference)

    仅有弱引用引用该对象时, 在垃圾回收时, 无论内存是否充足, 都会回收弱引用对象

    可以配合引用队列来释放弱引用自身

4.  虚引用(PhantomReference)

    必须配合引用队列使用, 主要配合 ByteBuffer 使用, 被引用对象回收时, 会将虚引用入队, 由 Reference Handler 线程调用虚引用相关方法释放直接内存

5.  终结器引用(FinalReference)

    无需手动编码, 但其内部配合引用队列使用, 在垃圾回收时, 终结器引用入队(被引用对象暂时没有被回收), 再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize方法, 第二次 GC 时才能回收被引用对象



## 垃圾回收算法

在确定了哪些垃圾可以被回收后, 垃圾收集器要做的事情就是开始进行垃圾回收, 但是这里面涉及到一个问题是: 如何高效地进行垃圾回收. 由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定, 因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器, 这里我们讨论几种常见的垃圾收集算法的核心思想

### 标记清除(Mark Sweep)



<img src="https://miaomiaoqi.github.io/images/jvm/jvm_7.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_7.png" style="zoom:67%;" />

标记清除算法(Mark-Sweep)是最基础的一种垃圾回收算法, 它分为2部分, 先把内存区域中的这些对象进行标记, 哪些属于可回收标记出来, 然后把这些垃圾拎出来清理掉. 就像上图一样, 清理掉的垃圾就变成未使用的内存区域, 等待被再次使用. 

这逻辑再清晰不过了, 并且也很好操作, 速度很快, **但它存在一个很大的问题, 那就是内存碎片. **

上图中等方块的假设是 2M, 小一些的是 1M, 大一些的是 4M. 等我们回收完, 内存就会切成了很多段. 我们知道开辟内存空间时, 需要的是连续的内存区域, 这时候我们需要一个 2M的内存区域, 其中有2个 1M 是没法用的. 这样就导致, 其实我们本身还有这么多的内存的, 但却用不了. 



### 标记整理清除(Mark Compact)

速度慢

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_9.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_9.png" style="zoom:67%;" />

标记整理算法(Mark-Compact)标记过程仍然与标记 --- 清除算法一样, 但后续步骤不是直接对可回收对象进行清理, 而是让所有存活的对象都向一端移动, 再清理掉端边界以外的内存区域. 

标记整理算法一方面在标记-清除算法上做了升级, 解决了内存碎片的问题, 也规避了复制算法只能利用一半内存区域的弊端. 看起来很美好, 但从上图可以看到, 它对内存变动更频繁, 需要整理所有存活对象的引用地址, 在效率上比复制算法要差很多. 

这是一种老年代的垃圾收集算法. 老年代的对象一般寿命比较长, 因此每次垃圾回收会有大量对象存活, 如果采用复制算法, 每次需要复制大量存活的对象, 效率很低. 



### 复制(Copy)

不会有内存碎片

需要占用双倍内存空间

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_8.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_8.png" style="zoom:67%;" />

复制算法(Copying)是在标记清除算法上演化而来, 解决标记清除算法的内存碎片问题. 它将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块. 当这一块的内存用完了, 就将还存活着的对象复制到另外一块上面, 然后再把已使用过的内存空间一次清理掉. **保证了内存的连续可用, 内存分配时也就不用考虑内存碎片等复杂情况, 逻辑清晰, 运行高效**. 

上面的图很清楚, 也很明显的暴露了另一个问题, 合着我这140平的大三房, 只能当70平米的小两房来使? 代价实在太高. 



为了解决空间利用率问题, 可以将内存分为三块: Eden、From Survivor、To Survivor, 比例是 8:1:1, 每次使用 Eden 和其中一块 Survivor. 回收时, 将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上, 最后清理掉 Eden 和刚才使用的 Survivor 空间. 这样只有 10% 的内存被浪费. 

但是我们无法保证每次回收都只有不多于 10% 的对象存活, 当 Survivor 空间不够, 需要依赖其他内存(指老年代)进行**分配担保**. 

**分配担保**

在发生 MinorGC 之前, 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间, 如果大于, 那么Minor GC 可以确保是安全的,如果不大于, 那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败. 如果允许, 那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小, 如果大于则进行 Minor GC, 否则可能进行一次 Full GC. 

**-XX:+HandlePromotionFailure 是否开启空间分配担保**







### 分代收集算法分代收集算法(Generational Collection)

严格来说并不是一种思想或理论, 而是融合上述3种基础的算法思想, 而产生的针对不同情况所采用不同算法的一套组合拳. 对象存活周期的不同将内存划分为几块. 一般是把 Java 堆分为新生代和老年代, 这样就可以根据各个年代的特点采用最适当的收集算法. **在新生代中, 每次垃圾收集时都发现有大批对象死去, 只有少量存活, 那就选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集. 而老年代中因为对象存活率高、没有额外空间对它进行分配担保, 就必须使用标记-清理或者标记 --- 整理算法来进行回收. **so, 另一个问题来了, 那内存区域到底被分为哪几块, 每一块又有什么特别适合什么算法呢? 

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_10.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_10.png" style="zoom:67%;" />

对象首先分配在伊甸园区域

新生代空间不足时, 触发 minor gc, 伊甸园和 from 存活的对象使用 copy 复制到 to 中, 存活的对象年龄加 1并且交换 from to

minor gc 会引发 stop the world, 暂停其它用户的线程, 等垃圾回收结束, 用户线程才恢复运行

当对象寿命超过阈值时, 会晋升至老年代, 最大寿命是15(4bit)

当老年代空间不足, 会先尝试触发 minor gc, 如果之后空间仍不足, 那么触发 full gc, STW的时间更长



### 相关 JVM 参数

| 含义                   | 参数                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 堆初始大小             | -Xms                                                         |
| 堆最大大小             | -Xmx 或 -XX:MaxHeapSize=size                                 |
| 新生代大小             | -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )            |
| 幸存区比例(动态)       | -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy |
| 幸存区比例(伊甸园占比) | -XX:SurvivorRatio=ratio                                      |
| 晋升阈值               | -XX:MaxTenuringThreshold=threshold                           |
| 晋升详情               | -XX:+PrintTenuringDistribution                               |
| GC详情                 | -XX:+PrintGCDetails -verbose:gc                              |
| FullGC 前 MinorGC      | -XX:+ScavengeBeforeFullGC                                    |



JVM的命令行参数参考: https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html

JVM参数分类

> 标准:  - 开头, 所有的HotSpot都支持
>
> 非标准: -X 开头, 特定版本HotSpot支持特定命令
>
> 不稳定: -XX 开头, 下个版本可能取消

-XX:+PrintCommandLineFlags 打印命令行参数

-XX:+PrintFlagsFinal 最终参数值

-XX:+PrintFlagsInitial 默认参数值



## 内存分代模型与回收策略

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_10.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_10.png" style="zoom:67%;" />

Java 堆(Java Heap)是JVM所管理的内存中最大的一块, 堆又是垃圾收集器管理的主要区域, 这里我们主要分析一下 Java 堆的结构. 

Java 堆主要分为2个区域-年轻代与老年代, 其中年轻代又分 Eden 区和 Survivor 区, 其中 Survivor 区又分 From 和 To 2个区. 可能这时候大家会有疑问, 为什么需要 Survivor 区, 为什么Survivor 还要分2个区. 不着急, 我们从头到尾, 看看对象到底是怎么来的, 而它又是怎么没的. 

### 新生代

#### Eden 区

IBM 公司的专业研究表明, 有将近98%的对象是朝生夕死, 所以针对这一现状, 大多数情况下, 对象会在新生代 Eden 区中进行分配, **当 Eden 区没有足够空间进行分配时, 虚拟机会发起一次 Minor GC, Minor GC 相比 Major GC 更频繁**, 回收速度也更快. 

**通过 Minor GC 之后, Eden 会被清空, Eden 区中绝大部分对象会被回收, 而那些无需回收的存活对象, 将会进到 Survivor 的 From 区(若 From 区不够, 则直接进入 Old 区). **

- -Xmn10M, 指定新生代内存
- -XX:SurvivorRatio=8 指定Eden内存大小

#### Survivor 区

Survivor 区相当于是 Eden 区和 Old 区的一个缓冲, 类似于我们交通灯中的黄灯. Survivor 又分为2个区, 一个是 From 区, 一个是 To 区. 每次执行 Minor GC, 会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区(如果 To 区不够, 则直接进入 Old 区). 

**为啥需要? **

不就是新生代到老年代么, 直接 Eden 到 Old 不好了吗, 为啥要这么复杂. 想想如果没有 Survivor 区, Eden 区每进行一次 Minor GC, 存活的对象就会被送到老年代, 老年代很快就会被填满. 而有很多对象虽然一次 Minor GC 没有消灭, 但其实也并不会蹦跶多久, 或许第二次, 第三次就需要被清除. 这时候移入老年区, 很明显不是一个明智的决定. 

所以, Survivor 的存在意义就是减少被送到老年代的对象, 进而减少 Major GC 的发生. Survivor 的预筛选保证, 只有经历16次 Minor GC 还能在新生代中存活的对象, 才会被送到老年代. 

**为啥需要俩? **

设置两个 Survivor 区最大的好处就是解决内存碎片化. 

我们先假设一下, Survivor 如果只有一个区域会怎样. Minor GC 执行后, Eden 区被清空了, 存活的对象放到了 Survivor 区, 而之前 Survivor 区中的对象, 可能也有一些是需要被清除的. 问题来了, 这时候我们怎么清除它们? 在这种场景下, 我们只能标记清除, 而我们知道标记清除最大的问题就是内存碎片, 在新生代这种经常会消亡的区域, 采用标记清除必然会让内存产生严重的碎片化. 因为 Survivor 有2个区域, 所以每次 Minor GC, 会将之前 Eden 区和 From 区中的存活对象复制到 To 区域. 第二次 Minor GC 时, From 与 To 职责兑换, 这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域, 以此反复. 

这种机制最大的好处就是, 整个过程中, 永远有一个 Survivor space 是空的, 另一个非空的 Survivor space 是无碎片的. 那么, Survivor 为什么不分更多块呢? 比方说分成三个、四个、五个?显然, 如果 Survivor 区再细分下去, 每一块的空间就会比较小, 容易导致 Survivor 区满, 两块 Survivor 区可能是经过权衡之后的最佳方案. 



**逃逸分析与栈上分配**

- 逃逸分析: 分析对象的作用域, 如果没有方法外部引用方法内部的对象, 就认为这个对象没有发生逃逸, 就可以把这个对象放到栈内存中
- 栈上分配: 根据方法的执行进行分配与释放, 不需要垃圾回收, 性能高



### 老年代

老年代占据着2/3的堆内存空间, 只有在 Major GC 的时候才会进行清理, 每次 GC 都会触发“Stop-The-World”. 内存越大, STW 的时间也越长, 所以内存也不仅仅是越大就越好. 由于复制算法在对象存活率较高的老年代会进行很多次的复制操作, 效率很低, 所以老年代这里采用的是标记 --- 整理算法. 

除了上述所说, 在内存担保机制下, 无法安置的对象会直接进到老年代, 以下几种情况也会进入老年代. 

**大对象**

大对象指需要大量连续内存空间的对象, 这部分对象不管是不是“朝生夕死”, 都会直接进到老年代. 这样做主要是为了避免在 Eden 区及2个 Survivor 区之间发生大量的内存复制. 当你的系统有非常多“朝生夕死”的大对象时, 得注意了. 

**-XX:PretenureSizeThreshold=10M 指定多大的内存是大对象**



**长期存活对象**

虚拟机给每个对象定义了一个对象年龄(Age)计数器. 正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动, **对象在 Survivor 区中每经历一次 Minor GC, 年龄就增加1岁. **当年龄增加到15岁时, 这时候就会被转移到老年代. 当然, 这里的15, JVM 也支持进行特殊设置. 

**-XX:MaxTenuringThreshold 15 指定增加到几岁**



**动态对象年龄**

虚拟机并不重视要求对象年龄必须到15岁, 才会放入老年区, 如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半, 年龄大于等于该年龄的对象就可以直接进去老年区, 无需等你“成年”. 

这其实有点类似于负载均衡, 轮询是负载均衡的一种, 保证每台机器都分得同样的请求. 看似很均衡, 但每台机的硬件不通, 健康状况不同, 我们还可以基于每台机接受的请求数, 或每台机的响应时间等, 来调整我们的负载均衡算法. 

### Stop The World

如果老年代满了, 会触发 Full GC, Full GC 会同时回收新生代和老年代(即对整个堆进行GC), 它会导致 Stop The World(简称 STW),造成挺大的性能开销. 

什么是 STW ? 所谓的 STW, 即在 GC(minor GC 或 Full GC)期间, 只有垃圾回收器线程在工作, 其他工作线程则被挂起. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_17.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_17.png" style="zoom:67%;" />

*为啥在垃圾收集期间其他工作线程会被挂起? 想象一下, 你一边在收垃圾, 另外一群人一边丢垃圾, 垃圾能收拾干净吗. *

一般 Full GC 会导致工作线程停顿时间过长(因为Full GC 会清理**整个堆**中的不可用对象, 一般要花较长的时间), 如果在此 server 收到了很多请求, 则会被拒绝服务！所以我们要尽量减少 Full GC(Minor GC 也会造成 STW,但只会触发轻微的 STW,因为 Eden 区的对象大部分都被回收了, 只有极少数存活对象会通过复制算法转移到 S0 或 S1 区, 所以相对还好). 

现在我们应该明白把新生代设置成 Eden, S0, S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了**尽可能地避免对象过早地进入老年代, 尽可能晚地触发 Full GC**. 想想新生代如果只设置 Eden 会发生什么, 后果就是每经过一次 Minor GC, 存活对象会过早地进入老年代, 那么老年代很快就会装满, 很快会触发 Full GC, 而对象其实在经过两三次的 Minor GC 后大部分都会消亡, 所以有了 S0,S1的缓冲, 只有少数的对象会进入老年代, 老年代大小也就不会这么快地增长, 也就避免了过早地触发 Full GC. 

由于 Full GC(或Minor GC) 会影响性能, 所以我们要在一个合适的时间点发起 GC, 这个时间点被称为 Safe Point, 这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿, 也不能过于频繁以至于过分增大运行时的负荷. 一般当线程在这个时间点上状态是可以确定的, 如确定 GC Root 的信息等, 可以使 JVM 开始安全地 GC. Safe Point 主要指的是以下特定位置: 

-   循环的末尾
-   方法返回前
-   调用方法的 call 之后
-   抛出异常的位置 另外需要注意的是由于新生代的特点(大部分对象经过 Minor GC后会消亡), Minor GC 用的是复制算法, 而在老生代由于对象比较多, 占用的空间较大, 使用复制算法会有较大开销(复制算法在对象存活率较高时要进行多次复制操作, 同时浪费一半空间)所以根据老生代特点, 在老年代进行的 GC 一般采用的是标记整理法来进行回收. 



### 永久代(1.7)/元数据区(1.8)(方法区)

方法区中存放生命周期较长的类信息、常量、静态变量, 每次垃圾收集只有少量的垃圾被清除. 方法区中主要清除两种垃圾: 

- 废弃常量

    回收废弃常量与回收Java堆中的对象非常类似. 以常量池中字面量的回收为例, 假如一个字符串“abc”已经进入了常量池中, 但是当前系统没有任何一个String对象是叫做“abc”的, 换句话说是没有任何String对象引用常量池中的“abc”常量, 也没有其他地方引用了这个字面量, 如果在这时候发生内存回收, 而且必要的话, 这个“abc”常量就会被系统“请”出常量池. 常量池中的其他类(接口)、方法、字段的符号引用也与此类似. 

- 无用的类

    判定一个类是否是“无用的类”, 条件较为苛刻: 

    - 该类所有的实例都已经被回收, 也就是Java堆中不存在该类的任何实例. 
    - 加载该类的ClassLoader已经被回收. 
    - 该类对应的java.lang.Class 对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法. 

    **在大量使用反射、动态代理、CGLib等bytecode框架的场景, 以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能, 以保证永久代不会溢出. **



## 具体回收过程

当GC线程启动时, 会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区, 然后把Eden Space和From Space区的对象释放掉. 当GC轮训扫描To Space区一定次数后, 把依然存活的对象复制到老年代, 然后释放To Space区的对象. 

对于用可达性分析法搜索不到的对象, GC并不一定会回收该对象. 要完全回收一个对象, 至少需要经过两次标记的过程. 

1. 对于一个没有其他引用的对象, JVM 会判断此对象是否有必要执行 finalize() 方法, 如果对象没有覆盖 finalize() 方法, 或者 finalize() 方法已经被虚拟机调用过, 那么视为“没有必要执行”. 那么对象基本上就真的被回收了. 
2. 如果对象被判定为有必要执行 finalize() 方法, 那么对象会被放入一个 F-Queue 队列中, 虚拟机会以较低的优先级执行这些 finalize()方法, 但不会确保所有的 finalize() 方法都会执行结束. 如果 finalize() 方法出现耗时操作, 虚拟机就直接停止指向该方法, 将对象清除. 

3. 如果在执行 finalize() 方法时, 将 this 赋给了某一个引用, 那么该对象就重生了. 如果没有, 那么就会被垃圾收集器清除. 任何一个对象的 finalize() 方法只会被系统自动调用一次, 如果对象面临下一次回收, 它的 finalize() 方法不会被再次执行, 想继续在 finalize() 中自救就失效了. 

![https://miaomiaoqi.github.io/images/java/jvm/jvm_19.png](https://miaomiaoqi.github.io/images/java/jvm/jvm_19.png)



## Mimor GC, Major GC, Mixed GC, Full GC

Minor GC: 从年轻代空间(包括 Eden 和 Survivor 区域) 回收内存

Major GC: 从老年代回收

**Mixed GC: 是在 G1 收集器中独有的, 用于收集整个 young gen 以及部分 old gen 的 GC**

Full GC: 清理整个堆空间, 包括年轻代, 老年代, 永久带(元空间)

**MinorGC = YGC**: 年轻代空间耗尽时触发

**MajorGC = FGC**: 在老年代无法继续分配空间时触发, 新生代老年代同时进行回收



### Minor GC

新生代(由 Eden and Survivor 组成)的垃圾收集叫做Minor GC. 该定义清晰易于理解. 但是以下几点仍然需要我们注意: 

* **当 jvm 无法为新建对象分配内存空间的时候Minor GC被触发, 例如新生代(Eden)空间被占满. 因此新生代空间占用率越高, Minor GC越频繁. **

* 当空间被占满, 它下面的所有对象都会被复制, 而且堆顶指针从空闲空间的零位置移动. 因此取代传统的标记清除压缩算法, 去清理Eden区和Survivor区, 因此Eden和Survivor区无内存碎片产生. 

* 在Minor GC期间,实际上Tenured区被忽略, 实际上Tenured区引用young区的对象被当作GC roots. 在标记期间young区引用的Tenured区对象的对象会被忽略. 

* 反对所有Minor GC都会触发“stop-the-world”这一观点. 在大多数应用中, 忽略"stop-the-world"停留时长. 不可否认的是新生代中的一些对象被错误当成垃圾而不会被移动到Survivor/Old区. 如果笔者反对的观点成立, 一些新生对象由于不合适被当作垃圾, 导致Minor GC停顿将会耗费更多的时间. 

### Major GC

Major GC通常是跟full GC是等价的, 收集整个GC堆. 但因为HotSpot VM发展了这么多年, 外界对各种名词的解读已经完全混乱了, 当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old gen. 

### Full GC

Full GC定义是相对明确的, 就是针对整个新生代、老生代、元空间(metaspace, java8以上版本取代perm gen)的全局范围的GC. 

当准备要触发一次young GC时, **如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大, 则不会触发young GC而是转为触发full GC(因为HotSpot VM的GC里, 除了CMS的concurrent collection之外, 其它能收集old gen的GC都会同时收集整个GC堆, 包括young gen, 所以不需要事先触发一次单独的young GC)；**或者, 如果有perm gen的话, 要在perm gen分配空间但已经没有足够空间时, 也要触发一次full GC；或者System.gc()、heap dump带GC, 默认也是触发full GC. 

## 垃圾回收器

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_18.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_18.png" style="zoom:67%;" />



![https://miaomiaoqi.github.io/images/java/jvm/jvm_18.png](https://miaomiaoqi.github.io/images/java/jvm/jvm_18.png)

1.8默认的垃圾回收: PS + ParallelOld

### 年轻代垃圾收集器

#### Serial 垃圾收集器(单线程, 采用复制算法)

* 最基本, 发展最悠久

* 只开启一条 GC 线程进行垃圾回收, 并且在垃圾收集过程中停止一切用户线程(Stop The World). 

* 一般客户端应用所需内存较小, 不会创建太多对象, 而且堆内存不大, 因此垃圾收集器回收时间短, 即使在这段时间停止一切用户线程, 也不会感觉明显卡顿. 因此 Serial 垃圾收集器**适合客户端使用**. 

* 由于 Serial 收集器只使用一条 GC 线程, 避免了线程切换的开销, 从而简单高效.  

应用程序线程 -> GC线程(应用程序线程暂停Stop The World) -> 应用程序线程

在整个扫描和复制过程采用单线程的方式来进行, 适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上, 是client级别默认的GC方式, 可以通过-XX:+UseSerialGC来强制指定. 

#### Parallel Scavenge收集器(多线程), 提高了用户体验, 相比Parnew多了吞吐量

* 复制算法(新生代收集器)

* Parallel Scavenge 和 ParNew 一样, 都是多线程、新生代垃圾收集器. 但是两者有巨大的不同点: 

    * Parallel Scavenge: 追求 CPU 吞吐量, 能够在较短时间内完成指定任务, 因此适合没有交互的后台计算. 

    * ParNew: 追求降低用户停顿时间, 适合交互式应用. 

* 达到可控制的吞吐量

    * 吞吐量: CPU用于运行用户代码的时间与CPU消耗的总时间的比值

    * 吞吐量 = (执行用户代码时间) / (执行用户代码时间 + 垃圾回收所占用的时间)

    追求高吞吐量, 可以通过减少 GC 执行实际工作的时间, 然而, 仅仅偶尔运行 GC 意味着每当 GC 运行时将有许多工作要做, 因为在此期间积累在堆中的对象数量很高. 单个 GC 需要花更多的时间来完成, 从而导致更高的暂停时间. 而考虑到低暂停时间, 最好频繁运行 GC 以便更快速完成, 反过来又导致吞吐量下降. 

    * 通过参数 -XX:GCTimeRadio 设置垃圾回收时间占总 CPU 时间的百分比. 0 < 吞吐量大小 < 100
    * 通过参数 -XX:MaxGCPauseMillis 设置垃圾处理过程最久停顿时间, 单位是毫秒. 这个值设置的小了, 机会增加频率, 所以要设置合理的值
    * 通过命令 -XX:+UseAdaptiveSizePolicy 开启自适应策略. 我们只要设置好堆的大小和 MaxGCPauseMillis 或 GCTimeRadio, 收集器会自动调整新生代的大小、Eden 和 Survivor 的比例、对象进入老年代的年龄, 以最大程度上接近我们设置的 MaxGCPauseMillis 或 GCTimeRadio. 

在整个扫描和复制过程采用多线程的方式来进行, 适用于多CPU、对暂停时间要求较短的应用上, 是server级别默认采用的GC方式, 可用-XX:+UseParallelGC来强制指定, 用-XX:ParallelGCThreads=4来指定线程数. 

#### ParNew 垃圾收集器(多线程)

* ParNew 是 Serial 的多线程版本. 由多条 GC 线程并行地进行垃圾清理. 但清理过程依然需要 Stop The World. 
* ParNew 追求“低停顿时间”,与 Serial 唯一区别就是使用了多线程进行垃圾收集, 在多 CPU 环境下性能比 Serial 会有一定程度的提升；但线程切换需要额外的开销, 因此在单 CPU 环境中表现不如 Serial. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_19.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_19.png" style="zoom:67%;" />

### 老年代垃圾收集器

#### Serial Old 垃圾收集器(单线程)

Serial Old 收集器是 Serial 的老年代版本, 都是单线程收集器, 只启用一条 GC 线程, 都适合客户端应用. 它们唯一的区别就是: Serial Old 工作在老年代, 使用“标记-整理”算法；Serial 工作在新生代, 使用“复制”算法. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_20.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_20.png" style="zoom:67%;" />

#### Parallel Old 垃圾收集器(多线程)

Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本, 使用多线程和标记整理法, 两者组合示意图如下,这两者的组合由于都是多线程收集器, 真正实现了「吞吐量优先」的目标

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_21.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_21.png" style="zoom:67%;" />

#### Cms, Concurrent Mark Sweep

CMS(Concurrent Mark Sweep, 并发标记清除)收集器是以获取最短回收停顿时间为目标的收集器(追求低停顿), 它在垃圾收集时使得用户线程和 GC 线程并发执行, 因此在垃圾收集过程中用户也不会感到明显的卡顿. 

工作过程:

* 初始标记: Stop The World, 仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记. 

* 并发标记: 使用多条标记线程, 与用户线程并发执行. 此过程进行可达性分析, 标记出所有废弃对象. 速度很慢. 

* 重新标记: Stop The World, 使用多条标记线程并发执行, 将刚才并发标记过程中新出现的废弃对象标记出来. 

* 并发清理: 只使用一条 GC 线程, 与用户线程并发执行, 清除刚才标记的对象. 这个过程非常耗时. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_22.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_22.png" style="zoom:67%;" />

从图中可以的看到初始标记和重新标记两个阶段会发生 STW, 造成用户线程挂起, 不过初始标记仅标记 GC Roots 能关联的对象, 速度很快, 并发标记是进行 GC Roots  Tracing 的过程, 重新标记是为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录, 这一阶段停顿时间一般比初始标记阶段稍长, 但**远比并发标记时间短**. 

整个过程中耗时最长的是并发标记和标记清理, 不过这两个阶段用户线程都可工作, 所以不影响应用的正常使用, 所以总体上看, 可以认为 CMS 收集器的内存回收过程是与用户线程一起并发执行的. 

但是 CMS 收集器远达不到完美的程度, 主要有以下三个缺点

-   CMS 收集器对 CPU 资源非常敏感  原因也可以理解, 比如本来我本来可以有 10 个用户线程处理请求, 现在却要分出 3 个作为回收线程, 吞吐量下降了30%, CMS 默认启动的回收线程数是 (CPU数量+3)/ 4, 如果 CPU 数量只有一两个, 那吞吐量就直接下降 50%,显然是不可接受的, 吞吐量低
-   CMS 无法处理浮动垃圾(Floating Garbage),可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生, 由于在并发清理阶段用户线程还在运行, 所以清理的同时新的垃圾也在不断出现, 这部分垃圾只能在下一次 GC 时再清理掉(即浮云垃圾), 同时在垃圾收集阶段用户线程也要继续运行, 就需要预留足够多的空间要确保用户线程正常执行, 这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用, JDK 1.5 默认当老年代使用了68%空间后就会被激活, 当然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置, 但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求, 会导致 **Concurrent Mode Failure** 失败, 这时会启用 Serial Old 收集器来重新进行老年代的收集, 而我们知道 Serial Old 收集器是单线程收集器, 这样就会导致 STW 更长了, 导致频繁 Full GC
-   CMS 采用的是标记清除法, 上文我们已经提到这种方法会产生大量的内存碎片, 这样会给大内存分配带来很大的麻烦, 如果无法找到足够大的连续空间来分配对象, 将会触发 Full GC, 这会影响应用的性能. 当然我们可以开启 -XX:+UseCMSCompactAtFullCollection(默认是开启的), 用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程, 内存整理会导致 STW, 停顿时间会变长, 还可以用另一个参数 -XX:CMSFullGCsBeforeCompation 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的. 

* 出现Concurrent Mode Failure

### 混合垃圾收集器

#### G1(标记, 整理, 清除)

G1 收集器是面向服务端的垃圾收集器, 被称为驾驭一切的垃圾回收器, 主要有以下几个特点

-   像 CMS 收集器一样, 能与应用程序线程并发执行. 
-   整理空闲空间更快. 
-   需要 GC 停顿时间更好预测. 
-   不会像 CMS 那样牺牲大量的吞吐性能. 
-   不需要更大的 Java Heap

与 CMS 相比, 它在以下两个方面表现更出色

1.  运作期间不会产生内存碎片, G1 从整体上看采用的是标记-整理法, 局部(两个 Region)上看是基于复制算法实现的, 两个算法都不会产生内存碎片, 收集后提供规整的可用内存, 这样有利于程序的长时间运行. 
2.  在 STW 上建立了**可预测**的停顿时间模型, 用户可以指定期望停顿时间, G1 会将停顿时间控制在用户设定的停顿时间以内. 

为什么G1能建立可预测的停顿模型呢, 主要原因在于 G1 对堆空间的分配与传统的垃圾收集器不一器, 传统的内存分配就像我们前文所述, 是连续的, 分成新生代, 老年代, 新生代又分 Eden,S0,S1,如下

![https://miaomiaoqi.github.io/images/jvm/gc/gc_23.png](https://miaomiaoqi.github.io/images/jvm/gc/gc_23.png)

而 G1 各代的存储地址不是连续的, 每一代都使用了 n 个不连续的大小相同的 Region, 每个Region占有一块连续的虚拟内存地址, 如图示

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_24.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_24.png" style="zoom:67%;" />

除了和传统的新老生代, 幸存区的空间区别, Region还多了一个H, 它代表Humongous, 这表示这些Region存储的是巨大对象(humongous object, H-obj), 即大小大于等于region一半的对象, 这样超大对象就直接分配到了老年代, 防止了反复拷贝移动. 那么 G1 分配成这样有啥好处呢? 

传统的收集器如果发生 Full GC 是对整个堆进行全区域的垃圾收集, 而分配成各个 Region 的话, 方便 G1 跟踪各个 Region 里垃圾堆积的价值大小(回收所获得的空间大小及回收所需经验值), 这样根据价值大小维护一个优先列表, 根据允许的收集时间, 优先收集回收价值最大的 Region,也就避免了整个老年代的回收, 也就减少了 STW 造成的停顿时间. 同时由于只收集部分 Region,可就做到了 STW 时间的可控. 

**这里抛个问题**

**一个对象和它内部所引用的对象可能不在同一个 Region 中, 那么当垃圾回收时, 是否需要扫描整个堆内存才能完整地进行一次可达性分析? **

**并不！每个 Region 都有一个 Remembered Set, 用于记录本区域中所有对象引用的对象所在的区域, 进行可达性分析时, 只要在 GC Roots 中再加上 Remembered Set 即可防止对整个堆内存进行遍历. **

G1 收集器的工作步骤如下

*   初始标记: Stop The World, 仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记. 
*   并发标记: 使用一条标记线程与用户线程并发执行. 此过程进行可达性分析, 速度很慢. 
*   最终标记: Stop The World, 使用多条标记线程并发执行. 
*   筛选回收(维护了一张表): 回收废弃对象, 此时也要 Stop The World, 并使用多条筛选回收线程并发执行. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_25.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_25.png" style="zoom:67%;" />

可以看到整体过程与 CMS 收集器非常类似, 筛选阶段会根据各个 Region 的回收价值和成本进行排序, 根据用户期望的 GC 停顿时间来制定回收计划. 



#### G1 回收阶段

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_14.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_14.png" style="zoom:50%;" />

##### Young Collection

会 STW

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_15.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_15.png" style="zoom:50%;" />



##### Young Collection + CM

在 Young GC 时会进行 GC Root 的初始标记

老年代占用堆空间比例达到阈值时, 进行并发标记(不会 STW), 由下面的 JVM 参数决定

-XX:InitiatingHeapOccupancyPercent=percent (默认45%)

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_16.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_16.png" style="zoom:50%;" />



##### Mixed Collection

会对 E、S、O 进行全面垃圾回收

*   最终标记(Remark)会 STW

*   拷贝存活(Evacuation)会 STW

-XX:MaxGCPauseMillis=ms

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_17.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_17.png" style="zoom:50%;" />



#### JDK 8u20 字符串去重

优点: 节省大量内存

缺点: 略微多占用了 cpu 时间, 新生代回收时间略微增加

-XX:+UseStringDeduplication

```java
String s1 = new String("hello"); // char[]{'h','e','l','l','o'}
String s2 = new String("hello"); // char[]{'h','e','l','l','o'}
```

将所有新分配的字符串放入一个队列

当新生代回收时, G1并发检查是否有字符串重复

如果它们值一样, 让它们引用同一个 char[]

注意, 与 String.intern() 不一样

*   String.intern() 关注的是字符串对象

*   而字符串去重关注的是 char[]

*   在 JVM 内部, 使用了不同的字符串表

#### JDK 8u40 并发标记类卸载

所有对象都经过并发标记后, 就能知道哪些类不再被使用, 当一个类加载器的所有类都不再使用, 则卸载它所加载的所有类

--XX:+ClassUnloadingWithConcurrentMark 默认启用



#### JDK 8u60 回收巨型对象

一个对象大于 region 的一半时, 称之为巨型对象

G1 不会对巨型对象进行拷贝

回收时被优先考虑

G1 会跟踪老年代所有 incoming 引用, 这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉



#### JDK 9 并发标记起始时间的调整

并发标记必须在堆空间占满前完成, 否则退化为 FullGC

JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent

JDK 9 可以动态调整

*   -XX:InitiatingHeapOccupancyPercent 用来设置初始值

*   进行数据采样并动态调整

*   总会添加一个安全的空档空间

#### JDK 9 更高效的回收

250+增强

180+bug修复

https://docs.oracle.com/en/java/javase/12/gctuning





#### ZGC



#### Shenandoah





### 串行

-XX:+UseSerialGC = Serial(新生代, 复制算法) + SerialOld(老年代, 标记整理算法)

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_11.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_11.png" style="zoom:67%;" />

单线程的只会有一个线程进行垃圾回收

堆内存较小, 适合个人电脑

### 吞吐量优先

多线程

堆内存较大, 多核 cpu

让单位时间内, STW 的**总时间**最短 0.2 0.2 = 0.4, 垃圾回收时间占比最低, 这样就称吞吐量高

-XX:+UseParallelGC ~ -XX:+UseParallelOldGC (1.8 中默认)

-XX:+UseAdaptiveSizePolicy(采用自适应的大小调整策略, 调整新生代的大小)

-XX:GCTimeRatio=ratio(1 / (1 + ratio))

 -XX:MaxGCPauseMillis=ms (200ms)

-XX:ParallelGCThreads=n

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_12.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_12.png" style="zoom:67%;" />



### 响应时间优先

多线程

堆内存较大, 多核 cpu

尽可能让**单次** STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5

-XX:+UseConcMarkSweepGC(老年代垃圾回收) ~ -XX:+UseParNewGC ~ SerialOld(有时会退化成串行)

-XX:ParallelGCThreads=n(并行线程数, 建议 CPU 核数) ~ -XX:ConcGCThreads=threads(并发线程数, 建议并行线程数的四分之一)

-XX:CMSInitiatingOccupancyFraction=percent

-XX:+CMSScavengeBeforeRemark

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_13.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_13.png" style="zoom:67%;" />



## 垃圾回收调优

掌握 GC 相关的 VM 参数, 会基本的空间调整

掌握相关工具

明白一点: 调优跟应用、环境有关, 没有放之四海而皆准的法则

**我们的 JVM 调优的目的就是减少 FullGC, 减少 STW 的时间**

### 调优领域

内存

锁竞争

cpu 占用

io

### 确定目标

【低延迟】还是【高吞吐量】, 选择合适的回收器

CMS, G1, ZGC

ParallelGC

Zing

### 最快的 GC

答案是不发生 GC

查看 FullGC 前后的内存占用, 考虑下面几个问题

*   数据是不是太多? 

    resultSet = statement.executeQuery("select * from 大表 limit n")

*   数据表示是否太臃肿? 

    对象图

    对象大小 16 Integer 24 int 4

*   是否存在内存泄漏? 

    static Map map =

    软

    弱

    第三方缓存实现

### 新生代调优

新生代的特点

*   所有的 new 操作的内存分配非常廉价

    TLAB thread-local allocation buffer

*   死亡对象的回收代价是零

*   大部分对象用过即死

*   Minor GC 的时间远远低于 Full GC

越大越好吗? 

-Xmn Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. **Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.**

新生代能容纳所有【并发量 * (请求-响应)】的数据

幸存区大到能保留【当前活跃对象+需要晋升对象】

晋升阈值配置得当, 让长时间存活对象尽快晋升

-XX:MaxTenuringThreshold=threshold

-XX:+PrintTenuringDistribution

```java
Desired survivor size 48286924 bytes, new threshold 10 (max 10)
- age 1: 28992024 bytes, 28992024 total
- age 2: 1366864 bytes, 30358888 total
- age 3: 1425912 bytes, 31784800 total
...
```

### 老年代调优

以 CMS 为例

CMS 的老年代内存越大越好

先尝试不做调优, 如果没有 Full GC 那么已经..., 否则先尝试调优新生代

观察发生 Full GC 时老年代内存占用, 将老年代内存预设调大 1/4 ~ 1/3

*   -XX:CMSInitiatingOccupancyFraction=percent





## 哪些场景会产生 OOM? 怎么解决? 

### 堆内存溢出

堆内存溢出太常见, 大部分人都应该能想得到这一点, 堆内存用来存储对象实例, 我们只要不停的创建对象, 并且保证 GC Roots 和对象之间有可达路径避免垃圾回收, 那么在对象数量超过最大堆的大小限制后很快就能出现这个异常. 

写一段代码测试一下, 设置堆内存大小2M. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_26.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_26.png" style="zoom:67%;" />

```java
public class HeapOOM {
    public static void main(String[] args) {
        List<HeapOOM> list = new ArrayList<>();
        while (true) {
            list.add(new HeapOOM());
        }
    }
}
```

运行代码, 很快能看见 OOM 异常出现, 这里的提示是 *Java heap space* 堆内存溢出. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_27.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_27.png" style="zoom:67%;" />

一般的排查方式可以通过设置 -XX: +HeapDumpOnOutOfMemoryError 在发生异常时dump出当前的内存转储快照来分析, 分析可以使用 Eclipse Memory Analyzer(MAT)来分析, 独立文件可以在官网下载. 

另外如果使用的是 IDEA 的话, 可以使用商业版 JProfiler 或者开源版本的 JVM-Profiler, 此外 IDEA2018 版本之后内置了分析工具, 包括 Flame Graph(火焰图)和 Call Tree(调用树)功能. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_28.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_28.png" style="zoom:67%;" />

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_29.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_29.png" style="zoom:67%;" />

### 方法区(运行时常量池)和元空间溢出

方法区和堆一样, 是线程共享的区域, 包含 class 文件信息、运行时常量池、常量池. 运行时常量池和常量池的主要区别是具备动态性, 也就是不一定非要是在 class 文件中的常量池中的内容才能进入运行时常量池, 运行期间也可以可以将新的常量放入池中, 比如 String 的 intern() 方法. 

我们写一段代码验证一下 String.intern(), 同时我们设置 -XX:MetaspaceSize=50m -XX:MaxMetaspaceSize=50m 元空间大小. 由于我使用的是 1.8 版本的 JDK, 而 1.8 版本之前方法区存在于永久代(PermGen), 1.8 之后取消了永久代的概念, 转为元空间(Metaspace). 如果是之前版本可以设置 PermSize MaxPermSize 永久代的大小. 

```java
private static String str = "test";
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        while (true){
            String str2 = str + str;
            str = str2;
            list.add(str.intern());
        }
}
```

运行代码, 会发现代码报错: 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_30.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_30.png" style="zoom:67%;" />

再次修改配置, 去除元空间限制, 修改堆内存大小 -Xms20m -Xmx20m, 可以看见堆内存报错. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_31.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_31.png" style="zoom:67%;" />

这是为什么呢? intern() 本身是一个 native 方法, 它的作用是: 如果字符串常量池中已经包含一个等于此 String 对象的字符串, 则返回代表池中这个字符串的 String 对象; 否则, 将此 String 对象包含的字符串添加到常量池中, 并且返回 String 对象的引用. 

而在 1.7 版本之后, 字符串常量池已经转移到堆区, 所以会报出堆内存溢出的错误, 如果 1.7 之前版本的话会看见 PermGen space 的报错. 

### 直接内存溢出

直接内存并不是虚拟机运行时数据区域的一部分, 并且不受堆内存的限制, 但是受到机器内存大小的限制. 常见的比如在 NIO 中可以使用 native 函数直接分配堆外内存就容易导致 OOM 的问题. 

直接内存大小可以通过 -XX:MaxDirectMemorySize 指定, 如果不指定, 则默认与 Java 堆最大值 -Xmx 一样. 

由直接内存导致的内存溢出, 一个明显的特征是在 dump 文件中不会看见明显的异常. 如果发现 OOM 之后 dump 文件很小, 而程序中又直接或间接使用了 NIO, 那就可以考虑检查一下是不是这方面的原因. 

### 栈内存溢出

栈是线程私有, 它的生命周期和线程相同. 每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息, 方法调用的过程就是栈帧入栈和出栈的过程. 

在 Java 虚拟机规范中, 对虚拟机栈定义了两种异常: 

1.  如果线程请求的栈深度大于虚拟机所允许的深度, 将抛出 StackOverflowError 异常; 
2.  如果虚拟机栈可以动态扩展, 并且扩展时无法申请到足够的内存, 抛出 OutOfMemoryError 异常. 

先写一段代码测试一下. 

```java
public class StackOOM {
    private int length = 1;

    public void stackTest() {
        System.out.println("stack lenght=" + length);
        length++;
        stackTest();
    }

    public static void main(String[] args) {
        StackOOM test = new StackOOM();
        test.stackTest();
    }
}
```

设置 -Xss160k, -Xss 代表每个线程的栈内存大小. 测试发现, 单线程下无论怎么设置参数都是 StackOverflow 异常: 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_32.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_32.png" style="zoom:67%;" />

尝试把代码修改为多线程, 调整 -Xss2m. 由于为每个线程分配的内存越大, 栈空间可容纳的线程数量越少, 越容易产生内存溢出. 反之, 如果内存不够的情况, 可以调小该参数来达到支撑更多线程的目的. 

```java
public class StackOOM {
    private void dontStop() {
        while (true) {
        }
    }

    public void stackLeakByThread() {
        while (true) {
            new Thread(() -> dontStop()).start();
        }
    }

    public static void main(String[] args) throws Throwable {
        StackOOM stackOOM = new StackOOM();
        stackOOM.stackLeakByThread();
    }
}
```













































