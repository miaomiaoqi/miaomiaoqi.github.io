---
layout: post
title:  "加密知识"
date:   2018-07-13 17:08:38
categories: Net
tags: SSL/TSL
author: miaoqi
---

* content
{:toc}
            

## 加密知识

* 密码学是涉及数学、电子信息、计算机等多学科的一门重要学科，是现代互联网安全的基石，也是目前如火如荼的区块链技术的安全保障。概括来说，加密方式可归结为不可逆加密与可逆加密。

### 不可逆加密

* 信息摘要（Message Digest）和安全散列（Secure Hash）算法属于此类，常见的算法包括 MD5、SHA1、PBKDF2、bcrypt 等。此类算法可将任意大小的原始数据变换成规定长度的输出，即获取内容的数字指纹，常用于校验原始内容是否被篡改。这类算法的主要特点是：

    * 不可逆性。除非穷举等手段，原则上不存在根据密文推断出原文的算法；

    * 雪崩效应。对输入数据敏感，原始内容的极小改动会造成输出的大差异；

    * 防碰撞性。原则上很难找到两组不同的原文，经过加密后密文相同。

* 哈希算法（安全散列）的一个变种是 HMAC（Hash-based Message Authentication Code）算法，用于解决身份认证和防抵赖。HMAC 算法的输入为一个密钥（通信双方共享）、一种哈希算法（常为经典哈希算法）和原始数据，输出的内容格式取决于所采用的哈希算法。由于只有通信双方知晓密钥，所以可确认信息就是由对方发出。

### 可逆加密

* 哈希算法可保证通信中的数据不被篡改，而可逆加密算法是还原出明文的关键。可逆加密算法可分成三类：

    * 基于算法的加密算法，也被称为古典加密算法，如 HTTP 认证中的 base64，比特币生成地址用的 base58（公开的算法也可称作编码方式）。这类算法主要对原始内容进行置换和替换得到密文，安全性依赖于算法是否外泄；

    * 对称加密算法，加密和解密使用同一个密钥。对称加密算法的出现标志密码学进入现代密码学阶段，密文的安全性从依赖于算法转向依赖于密钥。常见的对称加密算法有 DES、3DES、AES；

    * 非对称加密算法，加密和解密使用不同的密钥。非对称加密算法开创了密码学的里程碑，解决了对称加密过程中密钥分发的安全问题，被认为现代密码学最伟大的发明。常见的算法有 RSA、DH（Diffie-Hellman）、椭圆曲线算法（Elliptic curve cryptography，ECC）。

* 非对称算法设计巧妙，但实际中要结合对称加密使用。原因是某些算法不能加解密（DH、DSA），或者效率太低（RSA），或者能处理的数据大小有限制（RSA）。而对称加密算法的有点是速度快、加密强度高。常用非对称算法获得共享密钥，之后用对称加密处理数据。本文的重点是非对称加密及其衍生概念，下面逐一介绍。

### 公钥、私钥和证书

* 除算法外，非对称加密中另外两个重要的概念是公钥和私钥。公钥对外公开，任何人均可持有和使用；私钥自行保管，其安全性是通信安危的关键。

* 私钥和公钥的作用一般分为两种：

    * 公钥加密，私钥解密，主要用于通信；

    * 私钥加密（签名），公钥解密（验证），主要用于数字签名。

* 理论上有了公钥和密钥，双方就可以安全无碍的通信，那常说的证书是怎么回事？

    * 证书，顾名思义，就是证明的文件。例如浏览器和 tlanyan.me 服务器通信，浏览器怎么知道对方就是 tlanyan.me 对应的服务器呢？ 在不可信的网络下通信，中立的第三方作用就显现出来了。权威的第三方中立机构（ Certificate Authority, CA）收到 tlanyan.me 持有者的证书请求并核验信息后，将持有者的名称、公钥 与 CA 用**私钥加密生成的数字签名** 等信息写成证书颁发给申请者。

    * 用户与服务器通信时，服务器收到请求后将证书发给浏览器，浏览器对证书进行检查（是否过期，能否用 CA 的公钥验证签名等），并向第三方询问是否为真（是否被吊销等），确认无误后，就可以放心地通信了。

    * 证书包含公钥，所以拿到证书意味着就拿到了对方的公钥。几乎所有的浏览器都会对证书进行校验，以确保网页通信中的安全。使用自签发的证书，或者过期、与请求主机不符合的证书，都会导致浏览器发出安全警告，提醒用户潜在的风险。

    * 证书是由CA机构颁发的, 证书包括: 持有者的名称, CA生成的公钥, CA用私钥生成的数字签名, 客户端向CA请求验证证书, CA会用证书内的公钥去解密数字签名, 因为数字签名是用CA的私钥生成的

### SSL

* 不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险:

    1. 窃听风险（eavesdropping）：第三方可以获知通信内容。

    1. 篡改风险（tampering）：第三方可以修改通信内容。

    1. 冒充风险（pretending）：第三方可以冒充他人身份参与通信。

* SSL/TLS协议是为了解决这三大风险而设计的，希望达到:

    1. 所有信息都是加密传播，第三方无法窃听。

    1. 具有校验机制，一旦被篡改，通信双方会立刻发现。

    1. 配备身份证书，防止身份被冒充。

* 基本的运行过程

    * SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

        但是，这里有两个问题。

        1. 如何保证公钥不被篡改？

            将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

        1. 公钥加密计算量太大，如何减少耗用的时间？

            每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

    * 因此，SSL/TLS协议的基本过程是这样的:

        1. 客户端向服务器端索要并验证公钥。

        1. 双方协商生成"对话密钥"。

        1. 双方采用"对话密钥"进行加密通信。

    * 上面过程的前两步，又称为"握手阶段"（handshake）

* 握手阶段的详细过程

    1. 客户端发出请求（ClientHello）

        首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。

        在这一步，客户端主要向服务器提供以下信息。

        * 支持的协议版本，比如TLS 1.0版。

        * 一个客户端生成的随机数，稍后用于生成"对话密钥"。
        
        * 支持的加密方法，比如RSA公钥加密。
        
        * 支持的压缩方法。

        这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。

    1. 服务器回应（SeverHello）

        服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。

        * 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。

        * 一个服务器生成的随机数，稍后用于生成"对话密钥"。
        
        * 确认使用的加密方法，比如RSA公钥加密。
        
        * 服务器证书。

        除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。

    1. 客户端回应

        客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

        如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。

        * 一个随机数。该随机数用服务器公钥加密，防止被窃听。

        * 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
        
        * 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

        上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。

            "不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
    
            对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。
            
            pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"

    1. 服务器的最后回应

        服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。

        * 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

        * 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

    1. 至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。


* 客户端找了一个数字x用公钥加密请求服务端, 服务端用私钥解密出x, 这个x只有该客户端和服务端知道, 因为别人不知道x是什么, 别人也没有私钥不能解出x, 该客户端和服务端后续的通信过程采用x作为秘钥, 采用对称加密算法进行通信, 效率得到了大幅提升, 这个数字x叫做会话秘钥, 这套流程叫做SSL(Secure Socket Layer)
    
    
    
[1]: http://chenling1018.blog.163.com/blog/static/1480254201058112410789/
[2]: https://mp.weixin.qq.com/s/hJJUbb6aLbxmNl3k91M7UQ
[3]: http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html
    
    
    
    
    
    
    