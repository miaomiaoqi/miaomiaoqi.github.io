---
layout: post
title: JVM 垃圾回收与调优
categories: [Java]
description: 
keywords: 
---

* content
{:toc}












## 前言

Java 相比 C/C++ 最显著的特点便是引入了自动垃圾回收 (下文统一用 GC 指代自动垃圾回收), 它解决了 C/C++ 最令人头疼的内存管理问题, 让程序员专注于程序本身, 不用关心内存回收这些恼人的问题, 这也是 Java 能大行其道的重要原因之一, GC 真正让程序员的生产力得到了释放, 但是程序员很难感知到它的存在, 这就好比, 我们吃完饭后在桌上放下餐盘即走, 服务员会替你收拾好这些餐盘, 你不会关心服务员什么时候来收, 怎么收. 

有人说既然 GC 已经自动我们完成了清理,不了解 GC 貌似也没啥问题. 在大多数情况下确实没问题, 不过如果涉及到一些性能调优, 问题排查等, 深入地了解 GC 还是必不可少的, 曾经美团通过调整 JVM 相关 GC 参数让服务响应时间 TP90, TP99都下降了10ms+, 服务可用性得到了很大的提升！所以深入了解 GC 是成为一名优秀 Java 程序员的必修课！

垃圾回收分上下篇, 上篇会先讲垃圾回收理论, 主要包括

1.  GC 的几种主要的收集方法: 标记清除、标记整理、复制算法的原理与特点, 各自的优劣势
2.  为啥会有 Serial , CMS, G1 等各式样的回收器, 各自的优劣势是什么, 为啥没有一个统一的万能的垃圾回收器
3.  新生代为啥要设置成 Eden, S0,S1 这三个区, 基于什么考虑呢
4.  堆外内存不受 GC 控制, 那该怎么释放呢
5.  对象可回收, 就一定会被回收吗? 
6.  什么是 SafePoint,什么是 Stop The World

下篇主要讲垃圾回收的实践, 主要包括

1.  GC 日志格式怎么看
2.  主要有哪些发生 OOM 的场景
3.  发生 OOM, 如何定位, 常用的内存调试工具有哪些



## 什么是垃圾回收

垃圾回收(Garbage Collection, GC), 顾名思义就是释放垃圾占用的空间, 防止内存泄露. 有效的使用可以使用的内存, 对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收. 

Java 语言出来之前, 大家都在拼命的写 C 或者 C++ 的程序, 而此时存在一个很大的矛盾, C++ 等语言创建对象要不断的去开辟空间, 不用的时候又需要不断的去释放控件, 既要写构造函数, 又要写析构函数, 很多时候都在重复的 allocated, 然后不停的析构. 于是, 有人就提出, 能不能写一段程序实现这块功能, 每次创建, 释放控件的时候复用这段代码, 而无需重复的书写呢? 

1960年, 基于 MIT 的 Lisp 首先提出了垃圾回收的概念, 而这时 Java 还没有出世呢！**所以实际上 GC 并不是Java的专利, GC 的历史远远大于 Java 的历史！**



## JVM 内存区域

要搞懂垃圾回收的机制, 我们首先要知道垃圾回收主要回收的是哪些数据, 这些数据主要在哪一块区域, 所以我们一起来看下 JVM 的内存区域

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_1.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_1.png" style="zoom:67%;" />

-   虚拟机栈: 描述的是方法执行时的内存模型,是线程私有的, 生命周期与线程相同,每个方法被执行的同时会创建**栈桢**(下文会看到), 主要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息,方法执行时入栈, 方法执行完出栈, 出栈就相当于清空了数据, 入栈出栈的时机很明确, 所以这块区域**不需要进行 GC**. 

-   本地方法栈: 与虚拟机栈功能非常类似, 主要区别在于虚拟机栈为虚拟机执行 Java 方法时服务, 而本地方法栈为虚拟机执行本地方法时服务的. 这块区域也**不需要进行 GC**

-   程序计数器: 线程独有的, 可以把它看作是当前线程执行的字节码的行号指示器, 比如如下字节码内容, 在每个字节码`前面都有一个数字(行号), 我们可以认为它就是程序计数器存储的内容

    ![https://miaomiaoqi.github.io/images/jvm/gc/gc_2.png](https://miaomiaoqi.github.io/images/jvm/gc/gc_2.png)

    记录这些数字(指令地址)有啥用呢, 我们知道 Java 虚拟机的多线程是通过线程轮流切换并分配处理器的时间来完成的, 在任何一个时刻, 一个处理器只会执行一个线程, 如果这个线程被分配的时间片执行完了(线程被挂起), 处理器会切换到另外一个线程执行, 当下次轮到执行被挂起的线程(唤醒线程)时, 怎么知道上次执行到哪了呢, 通过记录在程序计数器中的行号指示器即可知道, 所以程序计数器的主要作用是记录线程运行时的状态, 方便线程被唤醒时能从上一次被挂起时的状态继续执行, 需要注意的是, 程序计数器是**唯一一个**在 Java 虚拟机规范中没有规定任何 OOM 情况的区域, 所以这块区域也**不需要进行 GC**

-   本地内存: 线程共享区域, Java 8 中, 本地内存, 也是我们通常说的**堆外内存**, 包含元空间和直接内存,注意到上图中 Java 8 和 Java 8 之前的 JVM 内存区域的区别了吗, 在 Java 8 之前有个**永久代**的概念, 实际上指的是 HotSpot 虚拟机上的永久代, 它用永久代实现了 JVM 规范定义的方法区功能, 主要存储类的信息, 常量, 静态变量, 即时编译器编译后代码等, 这部分由于是在堆中实现的, 受 GC 的管理, 不过由于永久代有 -XX:MaxPermSize 的上限, 所以如果动态生成类(将类信息放入永久代)或大量地执行 **String.intern** (将字段串放入永久代中的常量区), 很容易造成 OOM, 有人说可以把永久代设置得足够大, 但很难确定一个合适的大小, 受类数量, 常量数量的多少影响很大. 所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中, 这样方法区就不受 JVM 的控制了,也就不会进行 GC, 也因此提升了性能(发生 GC 会发生 Stop The Word,造成性能受到一定影响, 后文会提到), 也就不存在由于永久代限制大小而导致的 OOM 异常了(假设总内存1G, JVM 被分配内存 100M, 理论上元空间可以分配 2G-100M = 1.9G, 空间大小足够), 也方便在元空间中统一管理. 综上所述, 在 Java 8 以后这一区域也**不需要进行 GC**

-   堆: 前面几块数据区域都不进行 GC, 那只剩下堆了, 是的, 这里是 GC 发生的区域！对象实例和数组都是在堆上分配的, GC 也主要对这两类数据进行回收, 这块也是我们之后重点需要分析的区域



## 如何判断对象可以回收

上一节我们详细讲述了 JVM 的内存区域, 知道了 GC 主要发生在堆, 那么 GC 该怎么判断堆中的对象实例或数据是不是垃圾呢, 或者说判断某些数据是否是垃圾的方法有哪些. 

### 引用计数算法

引用计数算法(Reachability Counting)是通过在对象头中分配一个空间来保存该对象被引用的次数(Reference Count). 如果该对象被其它对象引用, 则它的引用计数加1, 如果删除对该对象的引用, 那么它的引用计数就减1, 当该对象的引用计数为0时, 那么该对象就会被回收. 

```java
String m = new String("jack");
```

先创建一个字符串, 这时候"jack"有一个引用, 就是 m. 

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_1.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_1.png" style="zoom:67%;" />

然后将 m 设置为 null, 这时候"jack"的引用次数就等于0了, 在引用计数算法中, 意味着这块内容就需要被回收了. 

```java
m = null;
```

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_2.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_2.png" style="zoom:67%;" />

**引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了, 而不是在进行垃圾收集时, 要挂起整个应用的运行, 直到对堆中所有对象的处理都结束. 因此, 采用引用计数的垃圾收集不属于严格意义上的"Stop-The-World"的垃圾收集机制**

**看似很美好, 但我们知道JVM的垃圾回收就是"Stop-The-World"的, 那是什么原因导致我们最终放弃了引用计数算法呢? 看下面的例子**

```java
public class ReferenceCountingGC {

    public Object instance;

    public ReferenceCountingGC(String name){}
}

public static void testGC(){

    ReferenceCountingGC a = new ReferenceCountingGC("objA");
    ReferenceCountingGC b = new ReferenceCountingGC("objB");

    a.instance = b;
    b.instance = a;

    a = null;
    b = null;
}
```

1. 定义 2 个对象

2. 相互引用

3. 置空各自的声明引用

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_3.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_3.png" style="zoom:67%;" />

**我们可以看到, 最后这 2 个对象已经不可能再被访问了, 但由于他们相互引用着对方, 导致它们的引用计数永远都不会为 0, 通过引用计数算法, 也就永远无法通知 GC 收集器回收它们**

### 可达性分析算法

可达性分析算法(Reachability Analysis)的基本思路是, 通过一些被称为引用链(GC Roots)的对象作为起点, 从这些节点开始向下搜索, 搜索走过的路径被称为(Reference Chain), 当一个对象到 GC Roots 没有任何引用链相连时(即从 GC Roots 节点到该节点不可达)则证明该对象是不可用的. 

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_4.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_4.png" style="zoom:67%;" />

通过可达性算法, 成功解决了引用计数所无法解决的问题-“循环依赖”, 只要你无法与 GC Root 建立直接或间接的连接, 系统就会判定你为可回收对象. 那这样就引申出了另一个问题, 哪些属于 GC Root. 

#### Java 内存区域

在 Java 语言中, 可作为 GC Root 的对象包括以下4种: 

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI(即一般说的 Native 方法)引用的对象

**GC Roots 并不包括堆中对象所引用的对象, 这样就不会有循环引用的问题**

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_5.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_5.png" style="zoom:67%;" />

**虚拟机栈(栈帧中的本地变量表)中引用的对象**

如下代码所示, a 是栈帧中的本地变量, 当 a = null 时, 由于此时 a 充当了 **GC Root** 的作用, a 与原来指向的实例 **new Test()** 断开了连接, 所以对象会被回收. 

```java
public class Test {
    public static  void main(String[] args) {
	    Test a = new Test();
	    a = null;
    }
}
```

**方法区中类静态属性引用的对象**

如下代码所示, 当栈帧中的本地变量 a = null 时, 由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接, 所以 a 原来指向的对象会被回收, 而由于我们给 s 赋值了变量的引用, s 在此时是类静态属性引用, 充当了 GC Root 的作用, 它指向的对象依然存活!

```java
public class Test {
    public static Test s;
    public static  void main(String[] args) {
	    Test a = new Test();
	    a.s = new Test();
	    a = null;
    }
}
```

**方法区中常量引用的对象**

如下代码所示, 常量 s 指向的对象并不会因为 a 指向的对象被回收而回收

```java
public class Test {
	public static final Test s = new Test();
    public static void main(String[] args) {
	    Test a = new Test();
	    a = null;
    }
}
```

**本地方法栈中引用的对象**

这是简单给不清楚本地方法为何物的童鞋简单解释一下: 所谓本地方法就是一个 java 调用非 java 代码的接口, 该方法并非 Java 实现的, 可能由 C 或 Python等其他语言实现的, Java 通过 JNI 来调用本地方法, 而本地方法是以库文件的形式存放的(在 WINDOWS 平台上是 DLL 文件形式, 在 UNIX 机器上是 SO 文件形式). 通过调用本地的库文件的内部方法, 使 JAVA 可以实现和本地机器的紧密联系, 调用系统级的各接口方法, 还是不明白? 见文末参考, 对本地方法定义与使用有详细介绍. 

当调用 Java 方法时, 虚拟机会创建一个栈桢并压入 Java 栈, 而当它调用的是本地方法时, 虚拟机会保持 Java 栈不变, 不会在 Java 栈祯中压入新的祯, 虚拟机只是简单地动态连接并直接调用指定的本地方法. 

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_6.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_6.png" style="zoom:67%;" />

```java
JNIEXPORT void JNICALL Java_com_pecuyu_jnirefdemo_MainActivity_newStringNative(JNIEnv *env, jobject instance, jstring jmsg) {
...
   // 缓存String的class
   jclass jc = (*env)->FindClass(env, STRING_PATH);
}
```

如上代码所示, 当 java 调用以上本地方法时, jc 会被本地方法栈压入栈中, jc 就是我们说的本地方法栈中 JNI 的对象引用, 因此只会在此本地方法执行完成后才会被释放. 

### 四种引用

1.  强引用

    只有所有 GC Roots 对象都不通过【强引用】引用该对象, 该对象才能被垃圾回收, 就算出现了 OOM 也不会对该对象进行回收

2.  软引用(SoftReference)

    仅有软引用引用该对象时, 在垃圾回收后, 内存仍不足时会再次出发垃圾回收, 回收软引用对象

    可以配合引用队列来释放软引用自身

3.  弱引用(WeakReference)

    仅有弱引用引用该对象时, 在垃圾回收时, 无论内存是否充足, 都会回收弱引用对象

    可以配合引用队列来释放弱引用自身

4.  虚引用(PhantomReference)

    必须配合引用队列使用, 主要配合 ByteBuffer 使用, 被引用对象回收时, 会将虚引用入队, 由 Reference Handler 线程调用虚引用相关方法释放直接内存

5.  终结器引用(FinalReference)

    无需手动编码, 但其内部配合引用队列使用, 在垃圾回收时, 终结器引用入队(被引用对象暂时没有被回收), 再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize方法, 第二次 GC 时才能回收被引用对象



## 垃圾回收算法

在确定了哪些垃圾可以被回收后, 垃圾收集器要做的事情就是开始进行垃圾回收, 但是这里面涉及到一个问题是: 如何高效地进行垃圾回收. 由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定, 因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器, 这里我们讨论几种常见的垃圾收集算法的核心思想

### 标记清除(Mark Sweep)



<img src="https://miaomiaoqi.github.io/images/jvm/jvm_7.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_7.png" style="zoom:67%;" />

标记清除算法(Mark-Sweep)是最基础的一种垃圾回收算法, 它分为2部分, 先把内存区域中的这些对象进行标记, 哪些属于可回收标记出来, 然后把这些垃圾拎出来清理掉. 就像上图一样, 清理掉的垃圾就变成未使用的内存区域, 等待被再次使用. 

这逻辑再清晰不过了, 并且也很好操作, 速度很快, **但它存在一个很大的问题, 那就是内存碎片**

上图中等方块的假设是 2M, 小一些的是 1M, 大一些的是 4M. 等我们回收完, 内存就会切成了很多段. 我们知道开辟内存空间时, 需要的是连续的内存区域, 这时候我们需要一个 2M的内存区域, 其中有2个 1M 是没法用的. 这样就导致, 其实我们本身还有这么多的内存的, 但却用不了. 



### 标记整理清除(Mark Compact)

速度慢

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_9.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_9.png" style="zoom:67%;" />

标记整理算法(Mark-Compact)标记过程仍然与标记 --- 清除算法一样, 但后续步骤不是直接对可回收对象进行清理, 而是让所有存活的对象都向一端移动, 再清理掉端边界以外的内存区域. 

标记整理算法一方面在标记-清除算法上做了升级, 解决了内存碎片的问题, 也规避了复制算法只能利用一半内存区域的弊端. 看起来很美好, 但从上图可以看到, 它对内存变动更频繁, 需要整理所有存活对象的引用地址, 在效率上比复制算法要差很多. 

这是一种老年代的垃圾收集算法. 老年代的对象一般寿命比较长, 因此每次垃圾回收会有大量对象存活, 如果采用复制算法, 每次需要复制大量存活的对象, 效率很低. 



### 复制(Copy)

不会有内存碎片

需要占用双倍内存空间

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_8.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_8.png" style="zoom:67%;" />

复制算法(Copying)是在标记清除算法上演化而来, 解决标记清除算法的内存碎片问题. 它将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块. 当这一块的内存用完了, 就将还存活着的对象复制到另外一块上面, 然后再把已使用过的内存空间一次清理掉**保证了内存的连续可用, 内存分配时也就不用考虑内存碎片等复杂情况, 逻辑清晰, 运行高效**. 

上面的图很清楚, 也很明显的暴露了另一个问题, 合着我这140平的大三房, 只能当70平米的小两房来使? 代价实在太高. 



为了解决空间利用率问题, 可以将内存分为三块: Eden、From Survivor、To Survivor, 比例是 8:1:1, 每次使用 Eden 和其中一块 Survivor. 回收时, 将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上, 最后清理掉 Eden 和刚才使用的 Survivor 空间. 这样只有 10% 的内存被浪费. 

但是我们无法保证每次回收都只有不多于 10% 的对象存活, 当 Survivor 空间不够, 需要依赖其他内存(指老年代)进行**分配担保**. 

**分配担保**

在发生 MinorGC 之前, 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间, 如果大于, 那么Minor GC 可以确保是安全的,如果不大于, 那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败. 如果允许, 那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小, 如果大于则进行 Minor GC, 否则可能进行一次 Full GC. 

**-XX:+HandlePromotionFailure 是否开启空间分配担保**







### 分代收集算法分代收集算法(Generational Collection)

严格来说并不是一种思想或理论, 而是融合上述3种基础的算法思想, 而产生的针对不同情况所采用不同算法的一套组合拳. 对象存活周期的不同将内存划分为几块. 一般是把 Java 堆分为新生代和老年代, 这样就可以根据各个年代的特点采用最适当的收集算法**在新生代中, 每次垃圾收集时都发现有大批对象死去, 只有少量存活, 那就选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集. 而老年代中因为对象存活率高、没有额外空间对它进行分配担保, 就必须使用标记-清理或者标记 --- 整理算法来进行回收**so, 另一个问题来了, 那内存区域到底被分为哪几块, 每一块又有什么特别适合什么算法呢? 

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_10.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_10.png" style="zoom:67%;" />

对象首先分配在伊甸园区域

新生代空间不足时, 触发 minor gc, 伊甸园和 from 存活的对象使用 copy 复制到 to 中, 存活的对象年龄加 1并且交换 from to

minor gc 会引发 stop the world, 暂停其它用户的线程, 等垃圾回收结束, 用户线程才恢复运行

当对象寿命超过阈值时, 会晋升至老年代, 最大寿命是15(4bit)

当老年代空间不足, 会先尝试触发 minor gc, 如果之后空间仍不足, 那么触发 full gc, STW的时间更长



### 相关 JVM 参数

| 含义                   | 参数                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 堆初始大小             | -Xms                                                         |
| 堆最大大小             | -Xmx 或 -XX:MaxHeapSize=size                                 |
| 新生代大小             | -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )            |
| 幸存区比例(动态)       | -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy |
| 幸存区比例(伊甸园占比) | -XX:SurvivorRatio=ratio                                      |
| 晋升阈值               | -XX:MaxTenuringThreshold=threshold                           |
| 晋升详情               | -XX:+PrintTenuringDistribution                               |
| GC详情                 | -XX:+PrintGCDetails -verbose:gc                              |
| FullGC 前 MinorGC      | -XX:+ScavengeBeforeFullGC                                    |



JVM的命令行参数参考: https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html

JVM参数分类

> 标准:  - 开头, 所有的HotSpot都支持
>
> 非标准: -X 开头, 特定版本HotSpot支持特定命令
>
> 不稳定: -XX 开头, 下个版本可能取消

-XX:+PrintCommandLineFlags 打印命令行参数

-XX:+PrintFlagsFinal 最终参数值

-XX:+PrintFlagsInitial 默认参数值



## 内存分代模型与回收策略

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_10.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_10.png" style="zoom:67%;" />

Java 堆(Java Heap)是JVM所管理的内存中最大的一块, 堆又是垃圾收集器管理的主要区域, 这里我们主要分析一下 Java 堆的结构. 

Java 堆主要分为2个区域-年轻代与老年代, 其中年轻代又分 Eden 区和 Survivor 区, 其中 Survivor 区又分 From 和 To 2个区. 可能这时候大家会有疑问, 为什么需要 Survivor 区, 为什么Survivor 还要分2个区. 不着急, 我们从头到尾, 看看对象到底是怎么来的, 而它又是怎么没的. 

### 新生代

#### Eden 区

IBM 公司的专业研究表明, 有将近98%的对象是朝生夕死, 所以针对这一现状, 大多数情况下, 对象会在新生代 Eden 区中进行分配, **当 Eden 区没有足够空间进行分配时, 虚拟机会发起一次 Minor GC, Minor GC 相比 Major GC 更频繁**, 回收速度也更快. 

**通过 Minor GC 之后, Eden 会被清空, Eden 区中绝大部分对象会被回收, 而那些无需回收的存活对象, 将会进到 Survivor 的 From 区(若 From 区不够, 则直接进入 Old 区)**

- -Xmn10M, 指定新生代内存
- -XX:SurvivorRatio=8 指定Eden内存大小

#### Survivor 区

Survivor 区相当于是 Eden 区和 Old 区的一个缓冲, 类似于我们交通灯中的黄灯. Survivor 又分为2个区, 一个是 From 区, 一个是 To 区. 每次执行 Minor GC, 会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区(如果 To 区不够, 则直接进入 Old 区). 

**为啥需要? **

不就是新生代到老年代么, 直接 Eden 到 Old 不好了吗, 为啥要这么复杂. 想想如果没有 Survivor 区, Eden 区每进行一次 Minor GC, 存活的对象就会被送到老年代, 老年代很快就会被填满. 而有很多对象虽然一次 Minor GC 没有消灭, 但其实也并不会蹦跶多久, 或许第二次, 第三次就需要被清除. 这时候移入老年区, 很明显不是一个明智的决定. 

所以, Survivor 的存在意义就是减少被送到老年代的对象, 进而减少 Major GC 的发生. Survivor 的预筛选保证, 只有经历16次 Minor GC 还能在新生代中存活的对象, 才会被送到老年代. 

**为啥需要俩? **

设置两个 Survivor 区最大的好处就是解决内存碎片化. 

我们先假设一下, Survivor 如果只有一个区域会怎样. Minor GC 执行后, Eden 区被清空了, 存活的对象放到了 Survivor 区, 而之前 Survivor 区中的对象, 可能也有一些是需要被清除的. 问题来了, 这时候我们怎么清除它们? 在这种场景下, 我们只能标记清除, 而我们知道标记清除最大的问题就是内存碎片, 在新生代这种经常会消亡的区域, 采用标记清除必然会让内存产生严重的碎片化. 因为 Survivor 有2个区域, 所以每次 Minor GC, 会将之前 Eden 区和 From 区中的存活对象复制到 To 区域. 第二次 Minor GC 时, From 与 To 职责兑换, 这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域, 以此反复. 

这种机制最大的好处就是, 整个过程中, 永远有一个 Survivor space 是空的, 另一个非空的 Survivor space 是无碎片的. 那么, Survivor 为什么不分更多块呢? 比方说分成三个、四个、五个?显然, 如果 Survivor 区再细分下去, 每一块的空间就会比较小, 容易导致 Survivor 区满, 两块 Survivor 区可能是经过权衡之后的最佳方案. 



**逃逸分析与栈上分配**

- 逃逸分析: 分析对象的作用域, 如果没有方法外部引用方法内部的对象, 就认为这个对象没有发生逃逸, 就可以把这个对象放到栈内存中
- 栈上分配: 根据方法的执行进行分配与释放, 不需要垃圾回收, 性能高



### 老年代

老年代占据着2/3的堆内存空间, 只有在 Major GC 的时候才会进行清理, 每次 GC 都会触发“Stop-The-World”. 内存越大, STW 的时间也越长, 所以内存也不仅仅是越大就越好. 由于复制算法在对象存活率较高的老年代会进行很多次的复制操作, 效率很低, 所以老年代这里采用的是标记 --- 整理算法. 

除了上述所说, 在内存担保机制下, 无法安置的对象会直接进到老年代, 以下几种情况也会进入老年代. 

**大对象**

大对象指需要大量连续内存空间的对象, 这部分对象不管是不是“朝生夕死”, 都会直接进到老年代. 这样做主要是为了避免在 Eden 区及2个 Survivor 区之间发生大量的内存复制. 当你的系统有非常多“朝生夕死”的大对象时, 得注意了. 

**-XX:PretenureSizeThreshold=10M 指定多大的内存是大对象**



**长期存活对象**

Java虚拟机会记录 Survivor区中的对象一共被来回复制了几次。**如果一个对象被复制的次数为 15 (对应虚拟机参数 -XX:+MaxTenuringThreshold),那么该对象将被晋升为至老年代**，(至于为什么是 15次，原因是 HotSpot会在对象头的中的标记字段里记录年龄，分配到的空间只有4位，所以最多只能记录到15)。另外，**如果单个 Survivor 区已经被占用了 50% (对应虚拟机参数: -XX:TargetSurvivorRatio)，那么较高复制次数的对象也会被晋升至老年代**



**动态对象年龄**

虚拟机并不重视要求对象年龄必须到15岁, 才会放入老年区, 如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半, 年龄大于等于该年龄的对象就可以直接进去老年区, 无需等你“成年”. 

这其实有点类似于负载均衡, 轮询是负载均衡的一种, 保证每台机器都分得同样的请求. 看似很均衡, 但每台机的硬件不通, 健康状况不同, 我们还可以基于每台机接受的请求数, 或每台机的响应时间等, 来调整我们的负载均衡算法. 

### Stop The World

如果老年代满了, 会触发 Full GC, Full GC 会同时回收新生代和老年代(即对整个堆进行GC), 它会导致 Stop The World(简称 STW),造成挺大的性能开销. 

什么是 STW ? 所谓的 STW, 即在 GC(minor GC 或 Full GC)期间, 只有垃圾回收器线程在工作, 其他工作线程则被挂起. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_17.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_17.png" style="zoom:67%;" />

*为啥在垃圾收集期间其他工作线程会被挂起? 想象一下, 你一边在收垃圾, 另外一群人一边丢垃圾, 垃圾能收拾干净吗. *

一般 Full GC 会导致工作线程停顿时间过长(因为Full GC 会清理**整个堆**中的不可用对象, 一般要花较长的时间), 如果在此 server 收到了很多请求, 则会被拒绝服务！所以我们要尽量减少 Full GC(Minor GC 也会造成 STW,但只会触发轻微的 STW,因为 Eden 区的对象大部分都被回收了, 只有极少数存活对象会通过复制算法转移到 S0 或 S1 区, 所以相对还好). 

现在我们应该明白把新生代设置成 Eden, S0, S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了**尽可能地避免对象过早地进入老年代, 尽可能晚地触发 Full GC**. 想想新生代如果只设置 Eden 会发生什么, 后果就是每经过一次 Minor GC, 存活对象会过早地进入老年代, 那么老年代很快就会装满, 很快会触发 Full GC, 而对象其实在经过两三次的 Minor GC 后大部分都会消亡, 所以有了 S0,S1的缓冲, 只有少数的对象会进入老年代, 老年代大小也就不会这么快地增长, 也就避免了过早地触发 Full GC. 

由于 Full GC(或Minor GC) 会影响性能, 所以我们要在一个合适的时间点发起 GC, 这个时间点被称为 Safe Point, 这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿, 也不能过于频繁以至于过分增大运行时的负荷. 一般当线程在这个时间点上状态是可以确定的, 如确定 GC Root 的信息等, 可以使 JVM 开始安全地 GC. Safe Point 主要指的是以下特定位置: 

-   循环的末尾
-   方法返回前
-   调用方法的 call 之后
-   抛出异常的位置 另外需要注意的是由于新生代的特点(大部分对象经过 Minor GC后会消亡), Minor GC 用的是复制算法, 而在老生代由于对象比较多, 占用的空间较大, 使用复制算法会有较大开销(复制算法在对象存活率较高时要进行多次复制操作, 同时浪费一半空间)所以根据老生代特点, 在老年代进行的 GC 一般采用的是标记整理法来进行回收. 



### 永久代(1.7)/元数据区(1.8)(方法区)

方法区中存放生命周期较长的类信息、常量、静态变量, 每次垃圾收集只有少量的垃圾被清除. 方法区中主要清除两种垃圾: 

- 废弃常量

    回收废弃常量与回收Java堆中的对象非常类似. 以常量池中字面量的回收为例, 假如一个字符串“abc”已经进入了常量池中, 但是当前系统没有任何一个String对象是叫做“abc”的, 换句话说是没有任何String对象引用常量池中的“abc”常量, 也没有其他地方引用了这个字面量, 如果在这时候发生内存回收, 而且必要的话, 这个“abc”常量就会被系统“请”出常量池. 常量池中的其他类(接口)、方法、字段的符号引用也与此类似. 

- 无用的类

    判定一个类是否是“无用的类”, 条件较为苛刻: 

    - 该类所有的实例都已经被回收, 也就是Java堆中不存在该类的任何实例. 
    - 加载该类的ClassLoader已经被回收. 
    - 该类对应的java.lang.Class 对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法. 

    **在大量使用反射、动态代理、CGLib等bytecode框架的场景, 以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能, 以保证永久代不会溢出**



## 具体回收过程

当GC线程启动时, 会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区, 然后把Eden Space和From Space区的对象释放掉. 当GC轮训扫描To Space区一定次数后, 把依然存活的对象复制到老年代, 然后释放To Space区的对象. 

对于用可达性分析法搜索不到的对象, GC并不一定会回收该对象. 要完全回收一个对象, 至少需要经过两次标记的过程. 

1. 对于一个没有其他引用的对象, JVM 会判断此对象是否有必要执行 finalize() 方法, 如果对象没有覆盖 finalize() 方法, 或者 finalize() 方法已经被虚拟机调用过, 那么视为“没有必要执行”. 那么对象基本上就真的被回收了. 
2. 如果对象被判定为有必要执行 finalize() 方法, 那么对象会被放入一个 F-Queue 队列中, 虚拟机会以较低的优先级执行这些 finalize()方法, 但不会确保所有的 finalize() 方法都会执行结束. 如果 finalize() 方法出现耗时操作, 虚拟机就直接停止指向该方法, 将对象清除. 

3. 如果在执行 finalize() 方法时, 将 this 赋给了某一个引用, 那么该对象就重生了. 如果没有, 那么就会被垃圾收集器清除. 任何一个对象的 finalize() 方法只会被系统自动调用一次, 如果对象面临下一次回收, 它的 finalize() 方法不会被再次执行, 想继续在 finalize() 中自救就失效了. 

![https://miaomiaoqi.github.io/images/java/jvm/jvm_19.png](https://miaomiaoqi.github.io/images/java/jvm/jvm_19.png)





## Minor GC, Young GC, Old GC, Major GC, Mixed GC, Full GC

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类有两种:

*   Partial GC(局部 GC): 并不收集整个 GC 堆的模式   
    *   Young GC: 只收集 Young Gen 的 GC，Young GC 还有种说法就叫做 Minor GC
    *   Old GC: 只收集 old gen 的 GC，只有垃圾收集器 CMS 的 concurrent collection 是这个模式
    *   Mixed GC: 收集整个 Young Gen 以及部分 old gen 的 GC，只有垃圾收集器 G1 有这个模式
*   Full GC: 收集整个堆，包括新生代，老年代，永久代(在 JDK 1.8 及以后，永久代被移除，换为 metaspace 元空间)等所有部分的模式



Minor GC/Young GC: 从年轻代空间(包括 Eden 和 Survivor 区域) 回收内存, **MinorGC = YGC**: 年轻代空间耗尽时触发

Major GC: 从老年代回收

**Mixed GC: 是在 G1 收集器中独有的, 用于收集整个 young gen 以及部分 old gen 的 GC**

Full GC: 清理整个堆空间, 包括年轻代, 老年代, 永久带(元空间)



**MajorGC = FGC**: 在老年代无法继续分配空间时触发, 新生代老年代同时进行回收



### Minor GC

首先我们先来看下 Minor GC / Young GC，大家都知道，新生代（Young Gen）也可以称之为年轻代，这两个名词是等价的。那么在年轻代中的 Eden 内存区域被占满之后，实际上就需要触发年轻代的 GC，或者是新生代的 GC。

此时这个新生代 GC，其实就是所谓的 Minor GC，也可以称之为 Young GC，这两个名词，相信大家就理解了，说白了，就专门针对新生代的 GC。

当 Eden 区的空间耗尽了怎么办？这个时候 Java虚拟机便会触发一次 **Minor GC**来收集新生代的垃圾，存活下来的对象，则会被送到 Survivor区。

新生代(由 Eden and Survivor 组成)的垃圾收集叫做Minor GC. 该定义清晰易于理解. 但是以下几点仍然需要我们注意: 

* **当 jvm 无法为新建对象分配内存空间的时候Minor GC被触发, 例如新生代(Eden)空间被占满. 因此新生代空间占用率越高, Minor GC越频繁**

* 当空间被占满, 它下面的所有对象都会被复制, 而且堆顶指针从空闲空间的零位置移动. 因此取代传统的标记清除压缩算法, 去清理Eden区和Survivor区, 因此Eden和Survivor区无内存碎片产生. 

* 在Minor GC期间,实际上Tenured区被忽略, 实际上Tenured区引用young区的对象被当作GC roots. 在标记期间young区引用的Tenured区对象的对象会被忽略. 

* 反对所有Minor GC都会触发“stop-the-world”这一观点. 在大多数应用中, 忽略"stop-the-world"停留时长. 不可否认的是新生代中的一些对象被错误当成垃圾而不会被移动到Survivor/Old区. 如果笔者反对的观点成立, 一些新生对象由于不合适被当作垃圾, 导致Minor GC停顿将会耗费更多的时间. 

### Old GC

只收集老年代的 GC(只有 CMS 的 concurrent collection是这个模式)



### Major GC

还有一个名词是所谓的 Major GC，这个其实一般用的比较少，他也是一个非常容易混淆的概念。

有些人把 Major GC 跟 Old GC等价起来，认为他就是针对老年代的 GC，也有人把 Major GC 和 Full GC 等价起来，认为他是针对 JVM 全体内存区域的GC。

所以针对这个容易混淆的概念，建议大家以后少提。如果听到有人说这个 Major GC的概念，大家可以问清楚，他到底是想说 Old GC 呢？还是 Full GC 呢？

### Full GC

Full GC定义是相对明确的, 就是针对整个新生代、老生代、元空间(metaspace, java8以上版本取代perm gen)的全局范围的GC. 

当准备要触发一次young GC时, **如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大, 则不会触发young GC而是转为触发full GC(因为HotSpot VM的GC里, 除了CMS的concurrent collection之外, 其它能收集old gen的GC都会同时收集整个GC堆, 包括young gen, 所以不需要事先触发一次单独的young GC)；**或者, 如果有perm gen的话, 要在perm gen分配空间但已经没有足够空间时, 也要触发一次full GC；或者System.gc()、heap dump带GC, 默认也是触发full GC. 



触发

*   **System.gc()，heap dump带GC,其默认都是触发 full GC.**
*   **如果有永久代(perm gen),要在永久代分配空间但已经没有足够空间时，也要触发一次 full GC**
*   **当准备要触发一次 young GC时，如果发现统计数据说之前 young GC的平均晋升大小比目前的 old gen剩余的空间大，则不会触发young GC而是转为触发 full GC** (因为HotSpot VM的GC里，除了垃圾回收器 CMS的concurrent collection 之外，其他能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先准备一次单独的young GC)



Full GC 相对于 Minor GC 来说，停止用户线程的 STW（stop the world）时间过长，至少慢10倍以上，所以要尽量避免，首先说一下Full GC可能产生的原因，接着给出排查方法以及解决策略。

在代码中调用System.gc()方法会建议JVM进行Full GC，但是注意这只是建议，JVM执行不执行是另外一回事儿，不过在大多数情况下会增加Full GC的次数，导致系统性能下降，一般建议不要手动进行此方法的调用，可以通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。

在YGC之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果小于，说明YGC是不安全的，则会查看参数 HandlePromotionFailure 是否被设置成了允许担保失败，如果不允许则直接触发Full GC；如果允许，那么会进一步检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于也会触发 Full GC

Metaspace（元空间）在空间不足时会进行扩容，当扩容到了-XX:MetaspaceSize 参数的指定值时，也会触发FGC



### MixedGC

Mixed GC 是 G1 中特有的概念，其实说白了，主要就是说在 G1 中，一旦老年代占据堆内存的 45%（-XX:InitiatingHeapOccupancyPercent：设置触发标记周期的 Java 堆占用率阈值，默认值是 45%。这里的Java 堆占比指的是 non_young_capacity_bytes，包括 old + humongous），就要触发 Mixed GC，此时对年轻代和老年代都会进行回收。Mixed GC 只有 G1 中才会出现。



## 垃圾回收器

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_18.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_18.png" style="zoom:67%;" />



![https://miaomiaoqi.github.io/images/java/jvm/jvm_18.png](https://miaomiaoqi.github.io/images/java/jvm/jvm_18.png)

1.8默认的垃圾回收: PS + ParallelOld

### 年轻代垃圾收集器

#### Serial 垃圾收集器(单线程, 采用复制算法)

* 最基本, 发展最悠久

* 只开启一条 GC 线程进行垃圾回收, 并且在垃圾收集过程中停止一切用户线程(Stop The World). 

* 一般客户端应用所需内存较小, 不会创建太多对象, 而且堆内存不大, 因此垃圾收集器回收时间短, 即使在这段时间停止一切用户线程, 也不会感觉明显卡顿. 因此 Serial 垃圾收集器**适合客户端使用**. 

* 由于 Serial 收集器只使用一条 GC 线程, 避免了线程切换的开销, 从而简单高效.  

应用程序线程 -> GC线程(应用程序线程暂停Stop The World) -> 应用程序线程

在整个扫描和复制过程采用单线程的方式来进行, 适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上, 是client级别默认的GC方式, 可以通过-XX:+UseSerialGC来强制指定. 

#### Parallel Scavenge收集器(多线程), 提高了用户体验, 相比Parnew多了吞吐量

* 复制算法(新生代收集器)

* Parallel Scavenge 和 ParNew 一样, 都是多线程、新生代垃圾收集器. 但是两者有巨大的不同点: 

    * Parallel Scavenge: 追求 CPU 吞吐量, 能够在较短时间内完成指定任务, 因此适合没有交互的后台计算. 

    * ParNew: 追求降低用户停顿时间, 适合交互式应用. 

* 达到可控制的吞吐量

    * 吞吐量: CPU用于运行用户代码的时间与CPU消耗的总时间的比值

    * 吞吐量 = (执行用户代码时间) / (执行用户代码时间 + 垃圾回收所占用的时间)

    追求高吞吐量, 可以通过减少 GC 执行实际工作的时间, 然而, 仅仅偶尔运行 GC 意味着每当 GC 运行时将有许多工作要做, 因为在此期间积累在堆中的对象数量很高. 单个 GC 需要花更多的时间来完成, 从而导致更高的暂停时间. 而考虑到低暂停时间, 最好频繁运行 GC 以便更快速完成, 反过来又导致吞吐量下降. 

    * 通过参数 -XX:GCTimeRadio 设置垃圾回收时间占总 CPU 时间的百分比. 0 < 吞吐量大小 < 100
    * 通过参数 -XX:MaxGCPauseMillis 设置垃圾处理过程最久停顿时间, 单位是毫秒. 这个值设置的小了, 机会增加频率, 所以要设置合理的值
    * 通过命令 -XX:+UseAdaptiveSizePolicy 开启自适应策略. 我们只要设置好堆的大小和 MaxGCPauseMillis 或 GCTimeRadio, 收集器会自动调整新生代的大小、Eden 和 Survivor 的比例、对象进入老年代的年龄, 以最大程度上接近我们设置的 MaxGCPauseMillis 或 GCTimeRadio. 

在整个扫描和复制过程采用多线程的方式来进行, 适用于多CPU、对暂停时间要求较短的应用上, 是server级别默认采用的GC方式, 可用-XX:+UseParallelGC来强制指定, 用-XX:ParallelGCThreads=4来指定线程数. 

#### ParNew 垃圾收集器(多线程)

* ParNew 是 Serial 的多线程版本. 由多条 GC 线程并行地进行垃圾清理. 但清理过程依然需要 Stop The World. 
* ParNew 追求“低停顿时间”,与 Serial 唯一区别就是使用了多线程进行垃圾收集, 在多 CPU 环境下性能比 Serial 会有一定程度的提升；但线程切换需要额外的开销, 因此在单 CPU 环境中表现不如 Serial. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_19.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_19.png" style="zoom:67%;" />

### 老年代垃圾收集器

#### Serial Old 垃圾收集器(单线程)

Serial Old 收集器是 Serial 的老年代版本, 都是单线程收集器, 只启用一条 GC 线程, 都适合客户端应用. 它们唯一的区别就是: Serial Old 工作在老年代, 使用“标记-整理”算法；Serial 工作在新生代, 使用“复制”算法. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_20.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_20.png" style="zoom:67%;" />

#### Parallel Old 垃圾收集器(多线程)

Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本, 使用多线程和标记整理法, 两者组合示意图如下,这两者的组合由于都是多线程收集器, 真正实现了「吞吐量优先」的目标

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_21.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_21.png" style="zoom:67%;" />

#### Cms, Concurrent Mark Sweep

CMS(Concurrent Mark Sweep, 并发标记清除)收集器是以获取最短回收停顿时间为目标的收集器(追求低停顿), 它在垃圾收集时使得用户线程和 GC 线程并发执行, 因此在垃圾收集过程中用户也不会感到明显的卡顿. 

工作过程:

* 初始标记: Stop The World, 仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记. 

* 并发标记: 使用多条标记线程, 与用户线程并发执行. 此过程进行可达性分析, 标记出所有废弃对象. 速度很慢. 

* 重新标记: Stop The World, 使用多条标记线程并发执行, 将刚才并发标记过程中新出现的废弃对象标记出来. 

* 并发清理: 只使用一条 GC 线程, 与用户线程并发执行, 清除刚才标记的对象. 这个过程非常耗时. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_22.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_22.png" style="zoom:67%;" />

从图中可以的看到初始标记和重新标记两个阶段会发生 STW, 造成用户线程挂起, 不过初始标记仅标记 GC Roots 能关联的对象, 速度很快, 并发标记是进行 GC Roots  Tracing 的过程, 重新标记是为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录, 这一阶段停顿时间一般比初始标记阶段稍长, 但**远比并发标记时间短**. 

整个过程中耗时最长的是并发标记和标记清理, 不过这两个阶段用户线程都可工作, 所以不影响应用的正常使用, 所以总体上看, 可以认为 CMS 收集器的内存回收过程是与用户线程一起并发执行的. 

但是 CMS 收集器远达不到完美的程度, 主要有以下三个缺点

-   CMS 收集器对 CPU 资源非常敏感  原因也可以理解, 比如本来我本来可以有 10 个用户线程处理请求, 现在却要分出 3 个作为回收线程, 吞吐量下降了30%, CMS 默认启动的回收线程数是 (CPU数量+3)/ 4, 如果 CPU 数量只有一两个, 那吞吐量就直接下降 50%,显然是不可接受的, 吞吐量低
-   CMS 无法处理浮动垃圾(Floating Garbage),可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生, 由于在并发清理阶段用户线程还在运行, 所以清理的同时新的垃圾也在不断出现, 这部分垃圾只能在下一次 GC 时再清理掉(即浮云垃圾), 同时在垃圾收集阶段用户线程也要继续运行, 就需要预留足够多的空间要确保用户线程正常执行, 这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用, JDK 1.5 默认当老年代使用了68%空间后就会被激活, 当然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置, 但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求, 会导致 **Concurrent Mode Failure** 失败, 这时会启用 Serial Old 收集器来重新进行老年代的收集, 而我们知道 Serial Old 收集器是单线程收集器, 这样就会导致 STW 更长了, 导致频繁 Full GC
-   CMS 采用的是标记清除法, 上文我们已经提到这种方法会产生大量的内存碎片, 这样会给大内存分配带来很大的麻烦, 如果无法找到足够大的连续空间来分配对象, 将会触发 Full GC, 这会影响应用的性能. 当然我们可以开启 -XX:+UseCMSCompactAtFullCollection(默认是开启的), 用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程, 内存整理会导致 STW, 停顿时间会变长, 还可以用另一个参数 -XX:CMSFullGCsBeforeCompation 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的. 

* 出现Concurrent Mode Failure

### 混合垃圾收集器

#### G1(标记, 整理, 清除)

G1 收集器是面向服务端的垃圾收集器, 被称为驾驭一切的垃圾回收器, 主要有以下几个特点

-   像 CMS 收集器一样, 能与应用程序线程并发执行. 
-   整理空闲空间更快. 
-   需要 GC 停顿时间更好预测. 
-   不会像 CMS 那样牺牲大量的吞吐性能. 
-   不需要更大的 Java Heap

与 CMS 相比, 它在以下两个方面表现更出色

1.  运作期间不会产生内存碎片, G1 从整体上看采用的是标记-整理法, 局部(两个 Region)上看是基于复制算法实现的, 两个算法都不会产生内存碎片, 收集后提供规整的可用内存, 这样有利于程序的长时间运行. 
2.  在 STW 上建立了**可预测**的停顿时间模型, 用户可以指定期望停顿时间, G1 会将停顿时间控制在用户设定的停顿时间以内. 

为什么G1能建立可预测的停顿模型呢, 主要原因在于 G1 对堆空间的分配与传统的垃圾收集器不一器, 传统的内存分配就像我们前文所述, 是连续的, 分成新生代, 老年代, 新生代又分 Eden,S0,S1,如下

![https://miaomiaoqi.github.io/images/jvm/gc/gc_23.png](https://miaomiaoqi.github.io/images/jvm/gc/gc_23.png)

而 G1 各代的存储地址不是连续的, 每一代都使用了 n 个不连续的大小相同的 Region, 每个Region占有一块连续的虚拟内存地址, 如图示

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_24.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_24.png" style="zoom:67%;" />

除了和传统的新老生代, 幸存区的空间区别, Region还多了一个H, 它代表Humongous, 这表示这些Region存储的是巨大对象(humongous object, H-obj), 即大小大于等于region一半的对象, 这样超大对象就直接分配到了老年代, 防止了反复拷贝移动. 那么 G1 分配成这样有啥好处呢? 

传统的收集器如果发生 Full GC 是对整个堆进行全区域的垃圾收集, 而分配成各个 Region 的话, 方便 G1 跟踪各个 Region 里垃圾堆积的价值大小(回收所获得的空间大小及回收所需经验值), 这样根据价值大小维护一个优先列表, 根据允许的收集时间, 优先收集回收价值最大的 Region,也就避免了整个老年代的回收, 也就减少了 STW 造成的停顿时间. 同时由于只收集部分 Region,可就做到了 STW 时间的可控. 

**这里抛个问题**

**一个对象和它内部所引用的对象可能不在同一个 Region 中, 那么当垃圾回收时, 是否需要扫描整个堆内存才能完整地进行一次可达性分析? **

**并不！每个 Region 都有一个 Remembered Set, 用于记录本区域中所有对象引用的对象所在的区域, 进行可达性分析时, 只要在 GC Roots 中再加上 Remembered Set 即可防止对整个堆内存进行遍历**

G1 收集器的工作步骤如下

*   初始标记: Stop The World, 仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记. 
*   并发标记: 使用一条标记线程与用户线程并发执行. 此过程进行可达性分析, 速度很慢. 
*   最终标记: Stop The World, 使用多条标记线程并发执行. 
*   筛选回收(维护了一张表): 回收废弃对象, 此时也要 Stop The World, 并使用多条筛选回收线程并发执行. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_25.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_25.png" style="zoom:67%;" />

可以看到整体过程与 CMS 收集器非常类似, 筛选阶段会根据各个 Region 的回收价值和成本进行排序, 根据用户期望的 GC 停顿时间来制定回收计划. 



#### G1 回收阶段

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_14.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_14.png" style="zoom:50%;" />

##### Young Collection

会 STW

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_15.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_15.png" style="zoom:50%;" />



##### Young Collection + CM

在 Young GC 时会进行 GC Root 的初始标记

老年代占用堆空间比例达到阈值时, 进行并发标记(不会 STW), 由下面的 JVM 参数决定

-XX:InitiatingHeapOccupancyPercent=percent (默认45%)

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_16.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_16.png" style="zoom:50%;" />



##### Mixed Collection

会对 E、S、O 进行全面垃圾回收

*   最终标记(Remark)会 STW

*   拷贝存活(Evacuation)会 STW

-XX:MaxGCPauseMillis=ms

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_17.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_17.png" style="zoom:50%;" />



#### JDK 8u20 字符串去重

优点: 节省大量内存

缺点: 略微多占用了 cpu 时间, 新生代回收时间略微增加

-XX:+UseStringDeduplication

```java
String s1 = new String("hello"); // char[]{'h','e','l','l','o'}
String s2 = new String("hello"); // char[]{'h','e','l','l','o'}
```

将所有新分配的字符串放入一个队列

当新生代回收时, G1并发检查是否有字符串重复

如果它们值一样, 让它们引用同一个 char[]

注意, 与 String.intern() 不一样

*   String.intern() 关注的是字符串对象

*   而字符串去重关注的是 char[]

*   在 JVM 内部, 使用了不同的字符串表

#### JDK 8u40 并发标记类卸载

所有对象都经过并发标记后, 就能知道哪些类不再被使用, 当一个类加载器的所有类都不再使用, 则卸载它所加载的所有类

--XX:+ClassUnloadingWithConcurrentMark 默认启用



#### JDK 8u60 回收巨型对象

一个对象大于 region 的一半时, 称之为巨型对象

G1 不会对巨型对象进行拷贝

回收时被优先考虑

G1 会跟踪老年代所有 incoming 引用, 这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉



#### JDK 9 并发标记起始时间的调整

并发标记必须在堆空间占满前完成, 否则退化为 FullGC

JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent

JDK 9 可以动态调整

*   -XX:InitiatingHeapOccupancyPercent 用来设置初始值

*   进行数据采样并动态调整

*   总会添加一个安全的空档空间

#### JDK 9 更高效的回收

250+增强

180+bug修复

https://docs.oracle.com/en/java/javase/12/gctuning





#### ZGC



#### Shenandoah





### 串行

-XX:+UseSerialGC = Serial(新生代, 复制算法) + SerialOld(老年代, 标记整理算法)

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_11.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_11.png" style="zoom:67%;" />

单线程的只会有一个线程进行垃圾回收

堆内存较小, 适合个人电脑

### 吞吐量优先

多线程

堆内存较大, 多核 cpu

让单位时间内, STW 的**总时间**最短 0.2 0.2 = 0.4, 垃圾回收时间占比最低, 这样就称吞吐量高

-XX:+UseParallelGC ~ -XX:+UseParallelOldGC (1.8 中默认)

-XX:+UseAdaptiveSizePolicy(采用自适应的大小调整策略, 调整新生代的大小)

-XX:GCTimeRatio=ratio(1 / (1 + ratio))

 -XX:MaxGCPauseMillis=ms (200ms)

-XX:ParallelGCThreads=n

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_12.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_12.png" style="zoom:67%;" />



### 响应时间优先

多线程

堆内存较大, 多核 cpu

尽可能让**单次** STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5

-XX:+UseConcMarkSweepGC(老年代垃圾回收) ~ -XX:+UseParNewGC ~ SerialOld(有时会退化成串行)

-XX:ParallelGCThreads=n(并行线程数, 建议 CPU 核数) ~ -XX:ConcGCThreads=threads(并发线程数, 建议并行线程数的四分之一)

-XX:CMSInitiatingOccupancyFraction=percent

-XX:+CMSScavengeBeforeRemark

<img src="https://miaomiaoqi.github.io/images/java/jvm/jvm_13.png" alt="https://miaomiaoqi.github.io/images/java/jvm/jvm_13.png" style="zoom:67%;" />



## 垃圾回收调优

掌握 GC 相关的 VM 参数, 会基本的空间调整

掌握相关工具

明白一点: 调优跟应用、环境有关, 没有放之四海而皆准的法则

**我们的 JVM 调优的目的就是减少 FullGC, 减少 STW 的时间**

### 调优领域

内存

锁竞争

cpu 占用

io

### 确定目标

【低延迟】还是【高吞吐量】, 选择合适的回收器

CMS, G1, ZGC

ParallelGC

Zing

### 最快的 GC

答案是不发生 GC

查看 FullGC 前后的内存占用, 考虑下面几个问题

*   数据是不是太多? 

    resultSet = statement.executeQuery("select * from 大表 limit n")

*   数据表示是否太臃肿? 

    对象图

    对象大小 16 Integer 24 int 4

*   是否存在内存泄漏? 

    static Map map =

    软

    弱

    第三方缓存实现

### 新生代调优

新生代的特点

*   所有的 new 操作的内存分配非常廉价

    TLAB thread-local allocation buffer

*   死亡对象的回收代价是零

*   大部分对象用过即死

*   Minor GC 的时间远远低于 Full GC

越大越好吗? 

-Xmn Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete**Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.**

新生代能容纳所有【并发量 * (请求-响应)】的数据

幸存区大到能保留【当前活跃对象+需要晋升对象】

晋升阈值配置得当, 让长时间存活对象尽快晋升

-XX:MaxTenuringThreshold=threshold

-XX:+PrintTenuringDistribution

```java
Desired survivor size 48286924 bytes, new threshold 10 (max 10)
- age 1: 28992024 bytes, 28992024 total
- age 2: 1366864 bytes, 30358888 total
- age 3: 1425912 bytes, 31784800 total
...
```

### 老年代调优

以 CMS 为例

CMS 的老年代内存越大越好

先尝试不做调优, 如果没有 Full GC 那么已经..., 否则先尝试调优新生代

观察发生 Full GC 时老年代内存占用, 将老年代内存预设调大 1/4 ~ 1/3

*   -XX:CMSInitiatingOccupancyFraction=percent



## java和jvm分别查看使用的垃圾收集器

### java查看垃圾收集器

使用命令：`java -XX:+PrintCommandLineFlags -version`

可以看到这台机器上，安装的java版本，默认的垃圾收集器是-XX:+UseParallelGC

### jvm查看垃圾收集器

使用命令：jmap -heap pid。pid通过jps可以查看，如下

老年代使用的是CMS收集器。和上面通过java命令查看得到的UseParallelGC(Parallel Scavenge+Parallel Old)不一样。

这是为啥？

因为java命令查看的是本机安装的java版本自带的默认垃圾收集器。而JVM是启动起来的具体进程，可以指定具体使用哪种收集器。比如：同一台机器上安装java1.8版本，默认是UseParallelGC，但是我可以在本机起来两个JVM，分别指定不同的垃圾收集器。所以这就是一直困惑我的问题：通过java命令查看的垃圾收集器和机器上gc日志打印出来的垃圾收集器，不一样。原来是我把java垃圾收集器当成了jvm垃圾收集器，它们两还是不一样的。一个是静态的，一个是动态的。JVM启动的时候，可以设置启动参数，修改垃圾收集器。如下：

```bash
JAVA_OPTS="$JAVA_OPTS -XX:+UseConcMarkSweepGC -XX:CMSMaxAbortablePrecleanTime=5000 -XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseCMSInitiatingOccupancyOnly"
```



## 查看 gc 次数

### 查看gc的次数

`jstat -gc java进程ID`

S0C：第一个幸存区的大小
S1C：第二个幸存区的大小
S0U：第一个幸存区的使用大小
S1U：第二个幸存区的使用大小
EC：伊甸园区的大小
EU：伊甸园区的使用大小
OC：老年代大小
OU：老年代使用大小
MC：方法区大小
MU：方法区使用大小
CCSC:压缩类空间大小
CCSU:压缩类空间使用大小
YGC：年轻代垃圾回收次数
YGCT：年轻代垃圾回收消耗时间
FGC：老年代垃圾回收次数
FGCT：老年代垃圾回收消耗时间
GCT：垃圾回收消耗总时间 

### 查看 java 进程的持续时间（不是运行时间）

`ps -eo pid,tty,user,comm,lstart,etime | grep java进程ID`

etime列代表持续时间

### 计算GC的频率

我们把持续时间 01:56:04转换成分钟就是116分钟，将分钟除以GC的次数7,那么约等于16分钟，频率就是16分钟一次GC



## 哪些场景会产生 OOM? 怎么解决? 

### 堆内存溢出

堆内存溢出太常见, 大部分人都应该能想得到这一点, 堆内存用来存储对象实例, 我们只要不停的创建对象, 并且保证 GC Roots 和对象之间有可达路径避免垃圾回收, 那么在对象数量超过最大堆的大小限制后很快就能出现这个异常. 

写一段代码测试一下, 设置堆内存大小2M. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_26.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_26.png" style="zoom:67%;" />

```java
public class HeapOOM {
    public static void main(String[] args) {
        List<HeapOOM> list = new ArrayList<>();
        while (true) {
            list.add(new HeapOOM());
        }
    }
}
```

运行代码, 很快能看见 OOM 异常出现, 这里的提示是 *Java heap space* 堆内存溢出. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_27.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_27.png" style="zoom:67%;" />

一般的排查方式可以通过设置 -XX: +HeapDumpOnOutOfMemoryError 在发生异常时dump出当前的内存转储快照来分析, 分析可以使用 Eclipse Memory Analyzer(MAT)来分析, 独立文件可以在官网下载. 

另外如果使用的是 IDEA 的话, 可以使用商业版 JProfiler 或者开源版本的 JVM-Profiler, 此外 IDEA2018 版本之后内置了分析工具, 包括 Flame Graph(火焰图)和 Call Tree(调用树)功能. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_28.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_28.png" style="zoom:67%;" />

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_29.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_29.png" style="zoom:67%;" />

### 方法区(运行时常量池)和元空间溢出

方法区和堆一样, 是线程共享的区域, 包含 class 文件信息、运行时常量池、常量池. 运行时常量池和常量池的主要区别是具备动态性, 也就是不一定非要是在 class 文件中的常量池中的内容才能进入运行时常量池, 运行期间也可以可以将新的常量放入池中, 比如 String 的 intern() 方法. 

我们写一段代码验证一下 String.intern(), 同时我们设置 -XX:MetaspaceSize=50m -XX:MaxMetaspaceSize=50m 元空间大小. 由于我使用的是 1.8 版本的 JDK, 而 1.8 版本之前方法区存在于永久代(PermGen), 1.8 之后取消了永久代的概念, 转为元空间(Metaspace). 如果是之前版本可以设置 PermSize MaxPermSize 永久代的大小. 

```java
private static String str = "test";
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        while (true){
            String str2 = str + str;
            str = str2;
            list.add(str.intern());
        }
}
```

运行代码, 会发现代码报错: 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_30.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_30.png" style="zoom:67%;" />

再次修改配置, 去除元空间限制, 修改堆内存大小 -Xms20m -Xmx20m, 可以看见堆内存报错. 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_31.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_31.png" style="zoom:67%;" />

这是为什么呢? intern() 本身是一个 native 方法, 它的作用是: 如果字符串常量池中已经包含一个等于此 String 对象的字符串, 则返回代表池中这个字符串的 String 对象; 否则, 将此 String 对象包含的字符串添加到常量池中, 并且返回 String 对象的引用. 

而在 1.7 版本之后, 字符串常量池已经转移到堆区, 所以会报出堆内存溢出的错误, 如果 1.7 之前版本的话会看见 PermGen space 的报错. 

### 直接内存溢出

直接内存并不是虚拟机运行时数据区域的一部分, 并且不受堆内存的限制, 但是受到机器内存大小的限制. 常见的比如在 NIO 中可以使用 native 函数直接分配堆外内存就容易导致 OOM 的问题. 

直接内存大小可以通过 -XX:MaxDirectMemorySize 指定, 如果不指定, 则默认与 Java 堆最大值 -Xmx 一样. 

由直接内存导致的内存溢出, 一个明显的特征是在 dump 文件中不会看见明显的异常. 如果发现 OOM 之后 dump 文件很小, 而程序中又直接或间接使用了 NIO, 那就可以考虑检查一下是不是这方面的原因. 

### 栈内存溢出

栈是线程私有, 它的生命周期和线程相同. 每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息, 方法调用的过程就是栈帧入栈和出栈的过程. 

在 Java 虚拟机规范中, 对虚拟机栈定义了两种异常: 

1.  如果线程请求的栈深度大于虚拟机所允许的深度, 将抛出 StackOverflowError 异常; 
2.  如果虚拟机栈可以动态扩展, 并且扩展时无法申请到足够的内存, 抛出 OutOfMemoryError 异常. 

先写一段代码测试一下. 

```java
public class StackOOM {
    private int length = 1;

    public void stackTest() {
        System.out.println("stack lenght=" + length);
        length++;
        stackTest();
    }

    public static void main(String[] args) {
        StackOOM test = new StackOOM();
        test.stackTest();
    }
}
```

设置 -Xss160k, -Xss 代表每个线程的栈内存大小. 测试发现, 单线程下无论怎么设置参数都是 StackOverflow 异常: 

<img src="https://miaomiaoqi.github.io/images/jvm/gc/gc_32.png" alt="https://miaomiaoqi.github.io/images/jvm/gc/gc_32.png" style="zoom:67%;" />

尝试把代码修改为多线程, 调整 -Xss2m. 由于为每个线程分配的内存越大, 栈空间可容纳的线程数量越少, 越容易产生内存溢出. 反之, 如果内存不够的情况, 可以调小该参数来达到支撑更多线程的目的. 

```java
public class StackOOM {
    private void dontStop() {
        while (true) {
        }
    }

    public void stackLeakByThread() {
        while (true) {
            new Thread(() -> dontStop()).start();
        }
    }

    public static void main(String[] args) throws Throwable {
        StackOOM stackOOM = new StackOOM();
        stackOOM.stackLeakByThread();
    }
}
```



---------------



## JVM 调优第一步, 了解 JVM 常用命令行参数

JVM 的命令行参数参考: https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html

HotSpot参数分类

*   标准: - 开头, 所有的HotSpot都支持

*   非标准: -X 开头, 特定版本HotSpot支持特定命令

*   不稳定: -XX 开头, 下个版本可能取消

    *   布尔类型: -XX: + 或 -某个参数表示开启或关闭

        -XX:+PrintGCDetails

    *   KV 类型: -XX:属性 Key=属性 Value

        -XX:Metaspace=128m

java -version

java -X

java -XX:+PrintFlagsWithComments //只有debug版本能用

试验用程序: 

```java
import java.util.List;
import java.util.LinkedList;

public class HelloGC {
    public static void main(String[] args) {
        System.out.println("HelloGC!");
        List list = new LinkedList();
        for(;;) {
            byte[] b = new byte[1024*1024];
            list.add(b);
        }
    }
}
```

1. 区分概念: 内存泄漏 memory leak, 内存溢出 out of memory
2. java -XX:+PrintCommandLineFlags HelloGC
3. java -Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGC  HelloGC
    PrintGCDetails PrintGCTimeStamps PrintGCCauses
4. java -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags HelloGC
5. java -XX:+PrintFlagsInitial 默认参数值
6. java -XX:+PrintFlagsFinal 最终参数值
7. java -XX:+PrintFlagsFinal \| grep xxx 找到对应的参数
8. java -XX:+PrintFlagsFinal -version \|grep GC
9. java -XX:+PrintFlagsFinal -version \| wc -l 

## 调优前的基础概念

1. 吞吐量: 用户代码时间 /(用户代码执行时间 + 垃圾回收时间)
2. 响应时间: STW越短, 响应时间越好

所谓调优, 首先确定, 追求啥? 吞吐量优先, 还是响应时间优先? 还是在满足一定的响应时间的情况下, 要求达到多大的吞吐量...

问题: 

科学计算, 吞吐量. 数据挖掘, thrput. 吞吐量优先的一般: (PS + PO)

响应时间: 网站 GUI API (1.8 G1)

## 什么是调优? 

1. 根据需求进行 JVM 规划和预调优
2. 优化运行JVM  运行环境(慢, 卡顿)
3. 解决 JVM 运行过程中出现的各种问题(OOM)

## 调优, 从规划开始

调优, 从业务场景开始, 没有业务场景的调优都是耍流氓

无监控(压力测试, 能看到结果), 不调优

步骤: 

1. 熟悉业务场景(没有最好的垃圾回收器, 只有最合适的垃圾回收器)
    1. 响应时间、停顿时间 [CMS G1 ZGC] (需要给用户作响应)
    2. 吞吐量 = 用户时间 /( 用户时间 + GC时间) [PS]
2. 选择回收器组合
3. 计算内存需求(经验值 1.5G 16G)
4. 选定CPU(越高越好)
5. 设定年代大小、升级年龄
6. 设定日志参数
    1. -Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause
    2. 或者每天产生一个日志文件
7. 观察日志情况

* 案例1: 垂直电商, 最高每日百万订单, 处理订单系统需要什么样的服务器配置? 

    > 这个问题比较业余, 因为很多不同的服务器配置都能支撑(1.5G 16G)
    >
    > 1小时360000集中时间段,  100个订单/秒, (找一小时内的高峰期, 1000订单/秒)
    >
    > 经验值, 
    >
    > 非要计算: 一个订单产生需要多少内存? 512K * 1000 500M内存
    >
    > 专业一点儿问法: 要求响应时间100ms
    >
    > 压测！

* 案例2: 12306遭遇春节大规模抢票应该如何支撑? 

    > 12306应该是中国并发量最大的秒杀网站: 
    >
    > 号称并发量100W最高
    >
    > CDN -> LVS -> NGINX -> 业务系统 -> 每台机器1W并发(10K问题) 100台机器
    >
    > 普通电商订单 -> 下单 ->订单系统(IO)减库存 ->等待用户付款
    >
    > 12306的一种可能的模型: 下单 -> 减库存 和 订单(redis kafka) 同时异步进行 ->等付款
    >
    > 减库存最后还会把压力压到一台服务器
    >
    > 可以做分布式本地库存 + 单独服务器做库存均衡
    >
    > 大流量的处理方法: 分而治之

* 怎么得到一个事务会消耗多少内存? 

    > 1. 弄台机器, 看能承受多少TPS? 是不是达到目标? 扩容或调优, 让它达到
    >
    > 2. 用压测来确定

## 解决 JVM 运行中的问题

### 一个案例理解常用工具

1. 测试代码: 

    ```java
    package com.mashibing.jvm.gc;
    
    import java.math.BigDecimal;
    import java.util.ArrayList;
    import java.util.Date;
    import java.util.List;
    import java.util.concurrent.ScheduledThreadPoolExecutor;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    
    /**
     * 从数据库中读取信用数据, 套用模型, 并把结果进行记录和传输
     */
    
    public class T15_FullGC_Problem01 {
    
        private static class CardInfo {
            BigDecimal price = new BigDecimal(0.0);
            String name = "张三";
            int age = 5;
            Date birthdate = new Date();
            public void m() {}
        }
    
        private static ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(50,
                new ThreadPoolExecutor.DiscardOldestPolicy());
    
        public static void main(String[] args) throws Exception {
            executor.setMaximumPoolSize(50);
    
            for (;;){
                modelFit();
                Thread.sleep(100);
            }
        }
    
        private static void modelFit(){
            List<CardInfo> taskList = getAllCardInfo();
            taskList.forEach(info -> {
                // do something
                executor.scheduleWithFixedDelay(() -> {
                    //do sth with info
                    info.m();
                }, 2, 3, TimeUnit.SECONDS);
            });
        }
    
        private static List<CardInfo> getAllCardInfo(){
            List<CardInfo> taskList = new ArrayList<>();
            for (int i = 0; i < 100; i++) {
                CardInfo ci = new CardInfo();
                taskList.add(ci);
            }
            return taskList;
        }
    }
    
    ```

2. java -Xms200M -Xmx200M -XX:+PrintGC com.mashibing.jvm.gc.T15_FullGC_Problem01

3. 一般是运维团队首先受到报警信息(CPU Memory)

4. top 命令观察到问题: 内存不断增长 CPU占用率居高不下

5. top -Hp 观察进程中的线程, 哪个线程CPU和内存占比高

6. jps 定位具体java进程
    jstack 定位线程状况, 重点关注: WAITING BLOCKED
    eg.
    waiting on <0x0000000088ca3310> (a java.lang.Object)
    假如有一个进程中100个线程, 很多线程都在waiting on <xx> , 一定要找到是哪个线程持有这把锁
    怎么找? 搜索jstack dump的信息, 找<xx> , 看哪个线程持有这把锁RUNNABLE
    作业: 1: 写一个死锁程序, 用jstack观察 2 : 写一个程序, 一个线程持有锁不释放, 其他线程等待

7. 为什么阿里规范里规定, 线程的名称(尤其是线程池)都要写有意义的名称

    排场问题时可以快速确定哪个业务的线程池出现了问题

8. 怎么样自定义线程池里的线程名称? 

    自定义ThreadFactory

9. jinfo pid 

10. jstat -gc 动态观察gc情况 / 阅读GC日志发现频繁GC / arthas观察 / jconsole/jvisualVM/ Jprofiler(最好用)
    jstat -gc 4655 500 : 每个500个毫秒打印GC的情况
    如果面试官问你是怎么定位OOM问题的? 如果你回答用图形界面(错误)
    1: 已经上线的系统不用图形界面用什么? (cmdline arthas)
    2: 图形界面到底用在什么地方? 测试！测试的时候进行监控！(压测观察)

11. jmap - histo 4655 \| head -20, 查找有多少对象产生

12. jmap -dump:format=b,file=xxx pid : 

    线上系统, 内存特别大, jmap 会对内存做一份快照, 执行期间会对进程产生很大影响, 甚至卡顿(电商不适合)
    1: 设定了参数 HeapDump, OOM 的时候会自动产生堆转储文件(不是很专业, 因为多有监控, 内存增长就会报警)
    2: <font color='red'>很多服务器备份(高可用), 停掉这台服务器对其他服务器不影响</font>
    3: 在线定位(一般小点儿公司用不到)

    4: 在测试环境中压测(产生类似内存增长问题, 在堆还不是很大的时候进行转储)

13. java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError com.mashibing.jvm.gc.T15_FullGC_Problem01

    可以在 OOM 时 dump 出内存文件, 在使用工具进行分析

14. 使用MAT / jhat /jvisualvm 进行dump文件分析
     [https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html](https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html)
    jhat -J-mx512M xxx.dump
    http://192.168.17.11:7000
    拉到最后: 找到对应链接
    可以使用 OQL 查找特定问题对象

15. 找到代码的问题

### arthas 在线排查工具

* 为什么需要在线排查? 

    在生产上我们经常会碰到一些不好排查的问题, 例如线程安全问题, 用最简单的threaddump或者heapdump不好查到问题原因. 为了排查这些问题, 有时我们会临时加一些日志, 比如在一些关键的函数里打印出入参, 然后重新打包发布, 如果打了日志还是没找到问题, 继续加日志, 重新打包发布. 对于上线流程复杂而且审核比较严的公司, 从改代码到上线需要层层的流转, 会大大影响问题排查的进度.  

* jvm 观察 jvm 信息

* thread 定位线程问题

* dashboard 观察系统情况

* heapdump + jhat 分析

* jad反编译

    动态代理生成类的问题定位

    第三方的类(观察代码)

    版本问题(确定自己最新提交的版本是不是被使用)

* redefine 热替换

    目前有些限制条件: 只能改方法实现(方法已经运行完成), 不能改方法名,  不能改属性 m() -> mm()

* sc  - search class

* watch  - watch method

* 没有包含的功能: jmap

## 案例汇总

OOM 产生的原因多种多样, 有些程序未必产生 OOM, 不断 FGC(CPU飙高, 但内存回收特别少) (上面案例)

1. 硬件升级系统反而卡顿的问题(见上)

2. 线程池不当运用产生OOM问题(见上)

    不断的往List里加对象(实在太LOW)

3. smile jira 问题
    实际系统不断重启
    解决问题 加内存 + 更换垃圾回收器 G1
    真正问题在哪儿? 不知道

4. tomcat http-header-size过大问题(Hector)

5. lambda 表达式导致方法区溢出问题(MethodArea / Perm Metaspace)
    LambdaGC.java     -XX:MaxMetaspaceSize=9M -XX:+PrintGCDetails

    ```java
    "C:\Program Files\Java\jdk1.8.0_181\bin\java.exe" -XX:MaxMetaspaceSize=9M -XX:+PrintGCDetails "-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2019.1\lib\idea_rt.jar=49316:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2019.1\bin" -Dfile.encoding=UTF-8 -classpath "C:\Program Files\Java\jdk1.8.0_181\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\rt.jar;C:\work\ijprojects\JVM\out\production\JVM;C:\work\ijprojects\ObjectSize\out\artifacts\ObjectSize_jar\ObjectSize.jar" com.mashibing.jvm.gc.LambdaGC
    [GC (Metadata GC Threshold) [PSYoungGen: 11341K->1880K(38400K)] 11341K->1888K(125952K), 0.0022190 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
    [Full GC (Metadata GC Threshold) [PSYoungGen: 1880K->0K(38400K)] [ParOldGen: 8K->1777K(35328K)] 1888K->1777K(73728K), [Metaspace: 8164K->8164K(1056768K)], 0.0100681 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
    [GC (Last ditch collection) [PSYoungGen: 0K->0K(38400K)] 1777K->1777K(73728K), 0.0005698 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
    [Full GC (Last ditch collection) [PSYoungGen: 0K->0K(38400K)] [ParOldGen: 1777K->1629K(67584K)] 1777K->1629K(105984K), [Metaspace: 8164K->8156K(1056768K)], 0.0124299 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] 
    java.lang.reflect.InvocationTargetException
    	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    	at java.lang.reflect.Method.invoke(Method.java:498)
    	at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:388)
    	at sun.instrument.InstrumentationImpl.loadClassAndCallAgentmain(InstrumentationImpl.java:411)
    Caused by: java.lang.OutOfMemoryError: Compressed class space
    	at sun.misc.Unsafe.defineClass(Native Method)
    	at sun.reflect.ClassDefiner.defineClass(ClassDefiner.java:63)
    	at sun.reflect.MethodAccessorGenerator$1.run(MethodAccessorGenerator.java:399)
    	at sun.reflect.MethodAccessorGenerator$1.run(MethodAccessorGenerator.java:394)
    	at java.security.AccessController.doPrivileged(Native Method)
    	at sun.reflect.MethodAccessorGenerator.generate(MethodAccessorGenerator.java:393)
    	at sun.reflect.MethodAccessorGenerator.generateSerializationConstructor(MethodAccessorGenerator.java:112)
    	at sun.reflect.ReflectionFactory.generateConstructor(ReflectionFactory.java:398)
    	at sun.reflect.ReflectionFactory.newConstructorForSerialization(ReflectionFactory.java:360)
    	at java.io.ObjectStreamClass.getSerializableConstructor(ObjectStreamClass.java:1574)
    	at java.io.ObjectStreamClass.access$1500(ObjectStreamClass.java:79)
    	at java.io.ObjectStreamClass$3.run(ObjectStreamClass.java:519)
    	at java.io.ObjectStreamClass$3.run(ObjectStreamClass.java:494)
    	at java.security.AccessController.doPrivileged(Native Method)
    	at java.io.ObjectStreamClass.<init>(ObjectStreamClass.java:494)
    	at java.io.ObjectStreamClass.lookup(ObjectStreamClass.java:391)
    	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1134)
    	at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548)
    	at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1509)
    	at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432)
    	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)
    	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)
    	at javax.management.remote.rmi.RMIConnectorServer.encodeJRMPStub(RMIConnectorServer.java:727)
    	at javax.management.remote.rmi.RMIConnectorServer.encodeStub(RMIConnectorServer.java:719)
    	at javax.management.remote.rmi.RMIConnectorServer.encodeStubInAddress(RMIConnectorServer.java:690)
    	at javax.management.remote.rmi.RMIConnectorServer.start(RMIConnectorServer.java:439)
    	at sun.management.jmxremote.ConnectorBootstrap.startLocalConnectorServer(ConnectorBootstrap.java:550)
    	at sun.management.Agent.startLocalManagementAgent(Agent.java:137)
    
    ```

6. 直接内存溢出问题(少见)
    《深入理解Java虚拟机》P59, 使用Unsafe分配直接内存, 或者使用NIO的问题

7. 栈溢出问题
    -Xss设定太小

8. 比较一下这两段程序的异同, 分析哪一个是更优的写法: 

    ```java 
    Object o = null;
    for(int i=0; i<100; i++) {
        o = new Object();
        //业务处理
    }
    ```

    ```java
    for(int i=0; i<100; i++) {
        Object o = new Object();
    }
    ```

9. 重写finalize引发频繁GC
    小米云, HBase同步系统, 系统通过nginx访问超时报警, 最后排查, C++程序员重写finalize引发频繁GC问题
    为什么C++程序员会重写finalize? (new delete)
    finalize耗时比较长(200ms)

10. 如果有一个系统, 内存一直消耗不超过10%, 但是观察GC日志, 发现FGC总是频繁产生, 会是什么引起的? 
    System.gc() (这个比较Low)

11. Distuptor有个可以设置链的长度, 如果过大, 然后对象大, 消费完不主动释放, 会溢出 (来自 死物风情)

12. 用jvm都会溢出, mycat用崩过, 1.6.5某个临时版本解析sql子查询算法有问题, 9个exists的联合sql就导致生成几百万的对象(来自 死物风情)

13. new 大量线程, 会产生 native thread OOM, (low)应该用线程池, 
     解决方案: 减少堆空间(太TMlow了),预留更多内存产生native thread
     JVM内存占物理内存比例 50% - 80%

14. 近期学生案例SQLLite的类库, 批处理的时候会把所有的结果加载内存, 有的人一下子更新几十万条数据, 结果就产生了内存溢出, 定位上用的是排除法, 去掉这个模块就没问题, 加上该模块就会出问题

15. java在线解压以及压缩文件造成的内存溢出

16. java使用opencv造成的卡顿与缓慢

17. 最容易引起崩溃的报表系统

18. 分库分表所引起的系统崩溃

19. CPU暴增如何排查? 

      1.   内存, cpu 监控报警

      2.   运维人员通知

      3.   阿里开源工具 arthas, top -Hp jstack

           *   使用 top 定位哪个进程对 cpu 的占用过高

           *   ps H -eo pid,tid,%cpu \| grep 进程 id (用ps命令进一步定位是哪个线程引起的cpu占用过高)

           *   jstack 进程 id
               *   可以根据线程 id 找到有问题的线程, 进一步定位到问题代码的源码行号, 此处需要将第 2 步的线程 id 转为 16 进制

      4.   给线程起一个有意义的名字, 分析是业务线程还是系统线程

           *   如果是业务线程去读业务代码
           *   系统线程去 GC 日志看日志进行调优

      5.   arthas thread 命令查看 cpu 过高的线程号


     6.   arthas thread 线程号, 查看方法调用

20. 死锁如何排查? 

      1.   jstack 观察线程情况
      2.   arthas -thread -b



## 虚拟机

1. Sun Classic VM

    * 世界上第一款商用的Java虚拟机

    * 只能使用纯解释器的方式来执行Java代码

1. Exact VM

    * Exact Memory Management准确试内存管理

    * 编译器和解释器混合工作以及两级即时编译器

    * 只在Solaris平台发布

    * 英雄气短

1. HotSpot VM

    * 称霸武林

1. KVM

    * Kilobyte简单, 轻量, 高度可移植

    * 在手机平台运行

1. JRockit

    * BEA公司

    * 世界上最快的Java虚拟机

    * 专注服务器端应用

    * 优势:    

        垃圾收集器

        MissionControl服务套件

1. J9

    * IBM公司

    * IBM Technology for Java Virtual Machine

1. Microsoft JVM

1. TaobaoVM





## 常用 java 命令

### 查看 java 进程

jps是jdk提供的一个查看当前java进程的小工具， 可以看做是JavaVirtual Machine Process Status Tool的缩写。非常简单实用。

`jps -lvVm`

-q：仅输出VM标识符，不包括classname,jar name,arguments in main method
-m：输出main method的参数
-l：输出完全的包名，应用主类名，jar的完全路径名
-v：输出jvm参数
-V：输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件



### 查看 jvm 参数 jps

```bash
jinfo -flag 参数名 pid
jinfo -flags pid
```



### 查看堆内存各个区域使用情况  jstat

#### 类加载统计

```bash
jstat -class pid
```

-   **Loaded:** 加载class的数量
-   **Bytes:** 所占用空间大小
-   **Unloaded:** 未加载数量
-   **Bytes:** 未加载占用空间
-   **Time:** 时间



####  编译统计

```bash
jstat -compiler pid
```

-   **Compiled:** 编译数量
-   **Failed:** 失败数量
-   **Invalid:** 不可用数量
-   **Time:** 时间
-   **FailedType:** 失败类型
-   **FailedMethod:** 失败的方法



#### 垃圾回收统计

```bash
jstat -gc pid
```

-   **S0C:** 第一个幸存区的大小
-   **S1C:** 第二个幸存区的大小
-   **S0U:** 第一个幸存区的使用大小
-   **S1U:** 第二个幸存区的使用大小
-   **EC:** 伊甸园区的大小
-   **EU:** 伊甸园区的使用大小
-   **OC:** 老年代大小
-   **OU:** 老年代使用大小
-   **MC:** 方法区大小
-   **MU:** 方法区使用大小
-   **CCSC:** 压缩类空间大小
-   **CCSU:** 压缩类空间使用大小
-   **YGC:** 年轻代垃圾回收次数
-   **YGCT:** 年轻代垃圾回收消耗时间
-   **FGC:** 老年代垃圾回收次数
-   **FGCT:** 老年代垃圾回收消耗时间
-   **GCT:** 垃圾回收消耗总时间



#### 堆内存统计

```bash
jstat -gccapacity pid
```

-   **NGCMN:** 新生代最小容量
-   **NGCMX:** 新生代最大容量
-   **NGC:** 当前新生代容量
-   **S0C:** 第一个幸存区大小
-   **S1C:** 第二个幸存区的大小
-   **EC:** 伊甸园区的大小
-   **OGCMN:** 老年代最小容量
-   **OGCMX:** 老年代最大容量
-   **OGC:** 当前老年代大小
-   **OC:** 当前老年代大小
-   **MCMN:** 最小元数据容量
-   **MCMX:** 最大元数据容量
-   **MC:** 当前元数据空间大小
-   **CCSMN:** 最小压缩类空间大小
-   **CCSMX:** 最大压缩类空间大小
-   **CCSC:** 当前压缩类空间大小
-   **YGC:** 年轻代gc次数
-   **FGC:** 老年代GC次数



#### 新生代垃圾回收统计

```bash
jstat -gcnew pid
```

-   **S0C:** 第一个幸存区大小
-   **S1C:** 第二个幸存区的大小
-   **S0U:** 第一个幸存区的使用大小
-   **S1U:** 第二个幸存区的使用大小
-   **TT:** 对象在新生代存活的次数
-   **MTT:** 对象在新生代存活的最大次数
-   **DSS:** 期望的幸存区大小
-   **EC:** 伊甸园区的大小
-   **EU:** 伊甸园区的使用大小
-   **YGC:** 年轻代垃圾回收次数
-   **YGCT:** 年轻代垃圾回收消耗时间



#### 新生代内存统计

```bash
jstat -gcnewcapacity pid
```

-   **NGCMN:** 新生代最小容量
-   **NGCMX:** 新生代最大容量
-   **NGC:** 当前新生代容量
-   **S0CMX:** 最大幸存1区大小
-   **S0C:** 当前幸存1区大小
-   **S1CMX:** 最大幸存2区大小
-   **S1C:** 当前幸存2区大小
-   **ECMX:** 最大伊甸园区大小
-   **EC:** 当前伊甸园区大小
-   **YGC:** 年轻代垃圾回收次数
-   **FGC:** 老年代回收次数



#### 老年代垃圾回收统计

```bash
jstat -gcold pid
```

-   **MC:** 方法区大小
-   **MU:** 方法区使用大小
-   **CCSC:** 压缩类空间大小
-   **CCSU:** 压缩类空间使用大小
-   **OC:** 老年代大小
-   **OU:** 老年代使用大小
-   **YGC:** 年轻代垃圾回收次数
-   **FGC:** 老年代垃圾回收次数
-   **FGCT:** 老年代垃圾回收消耗时间
-   **GCT:** 垃圾回收消耗总时间



#### 老年代内存统计

```bash
jstat -gcoldcapacity pid
```

-   **OGCMN:** 老年代最小容量
-   **OGCMX:** 老年代最大容量
-   **OGC:** 当前老年代大小
-   **OC:** 老年代大小
-   **YGC:** 年轻代垃圾回收次数
-   **FGC:** 老年代垃圾回收次数
-   **FGCT:** 老年代垃圾回收消耗时间
-   **GCT:** 垃圾回收消耗总时间



#### 元数据空间统计

```bash
jstat -gcmetacapacity pid
```

-   **MCMN:** 最小元数据容量
-   **MCMX:** 最大元数据容量
-   **MC:** 当前元数据空间大小
-   **CCSMN:** 最小压缩类空间大小
-   **CCSMX:** 最大压缩类空间大小
-   **CCSC:** 当前压缩类空间大小
-   **YGC:** 年轻代垃圾回收次数
-   **FGC:** 老年代垃圾回收次数
-   **FGCT:** 老年代垃圾回收消耗时间
-   **GCT:** 垃圾回收消耗总时间



#### 总结垃圾回收统计

```bash
jstat -gcutil -h20 pid
```

-   **S0:** 幸存1区当前使用比例
-   **S1:** 幸存2区当前使用比例
-   **E:** 伊甸园区使用比例
-   **O:** 老年代使用比例
-   **M:** 元数据区使用比例
-   **CCS:** 压缩使用比例
-   **YGC:** 年轻代垃圾回收次数
-   **FGC:** 老年代垃圾回收次数
-   **FGCT:** 老年代垃圾回收消耗时间
-   **GCT:** 垃圾回收消耗总时间



#### JVM 编译方法统计

```bash
jstat -printcompilation pid
```

-   **Compiled:** 最近编译方法的数量
-   **Size:** 最近编译方法的字节码数量
-   **Type:** 最近编译方法的编译类型. 
-   **Method:** 方法名标识. 



### 内存信息 jmap

#### 展示 pid 的整体堆信息

```bash
jmap -heap pid | head -n20
```

```bash
[root@localhost ~]# jmap -heap 27900
Attaching to process ID 27900, please wait...
Debugger attached successfully.
Client compiler detected.
JVM version is 20.45-b01
using thread-local object allocation.
Mark Sweep Compact GC
Heap Configuration: # 堆内存初始化配置
   MinHeapFreeRatio = 40     # -XX:MinHeapFreeRatio设置JVM堆最小空闲比率  
   MaxHeapFreeRatio = 70   # -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率  
   MaxHeapSize = 100663296 (96.0MB)   # -XX:MaxHeapSize=设置JVM堆的最大大小
   NewSize = 1048576 (1.0MB)     # -XX:NewSize=设置JVM堆的‘新生代’的默认大小
   MaxNewSize = 4294901760 (4095.9375MB) # -XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小
   OldSize = 4194304 (4.0MB)  # -XX:OldSize=设置JVM堆的‘老生代’的大小
   NewRatio = 2    # -XX:NewRatio=:‘新生代’和‘老生代’的大小比率
   SurvivorRatio = 8  # -XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值
   PermSize = 12582912 (12.0MB) # -XX:PermSize=<value>:设置JVM堆的‘持久代’的初始大小  
   MaxPermSize = 67108864 (64.0MB) # -XX:MaxPermSize=<value>:设置JVM堆的‘持久代’的最大大小  
Heap Usage:
New Generation (Eden + 1 Survivor Space): # 新生代区内存分布, 包含伊甸园区+1个Survivor区
   capacity = 30212096 (28.8125MB)
   used = 27103784 (25.848182678222656MB)
   free = 3108312 (2.9643173217773438MB)
   89.71169693092462% used
Eden Space: # Eden区内存分布
   capacity = 26869760 (25.625MB)
   used = 26869760 (25.625MB)
   free = 0 (0.0MB)
   100.0% used
From Space: # 其中一个 Survivor 区的内存分布
   capacity = 3342336 (3.1875MB)
   used = 234024 (0.22318267822265625MB)
   free = 3108312 (2.9643173217773438MB)
   7.001809512867647% used
To Space: # 另一个 Survivor 区的内存分布
   capacity = 3342336 (3.1875MB)
   used = 0 (0.0MB)
   free = 3342336 (3.1875MB)
   0.0% used
tenured generation:   # 当前的 Old 区内存分布  
   capacity = 67108864 (64.0MB)
   used = 67108816 (63.99995422363281MB)
   free = 48 (4.57763671875E-5MB)
   99.99992847442627% used
Perm Generation:     # 当前的"持久代"内存分布
   capacity = 14417920 (13.75MB)
   used = 14339216 (13.674942016601562MB)
   free = 78704 (0.0750579833984375MB)
   99.45412375710227% used
```

新生代的内存回收就是采用空间换时间的方式;
如果 from 区使用率一直是 100% 说明程序创建大量的短生命周期的实例, 使用 jstat 统计一下 jvm 在内存回收中发生的频率耗时以及是否有 full gc, 使用这个数据来评估一内存配置参数、gc 参数是否合理;

多次 ygc 后如果 s 区没变化, 这种情况不出意外就是[担保](http://blog.csdn.net/u013295276/article/details/78468790?locationNum=1&fps=1)了, 可以 jstat 持续观察下;

```bash
[root@localhost ~]# jmap -heap 4951
Attaching to process ID 4951, please wait...
Debugger attached successfully.
Client compiler detected.
JVM version is 20.45-b01

using thread-local object allocation.
Parallel GC with 1 thread(s)

Heap Configuration:
   MinHeapFreeRatio = 40
   MaxHeapFreeRatio = 70
   MaxHeapSize      = 734003200 (700.0MB)
   NewSize          = 314572800 (300.0MB)
   MaxNewSize       = 314572800 (300.0MB)
   OldSize          = 4194304 (4.0MB)
   NewRatio         = 2
   SurvivorRatio    = 8
   PermSize         = 104857600 (100.0MB)
   MaxPermSize      = 104857600 (100.0MB)

Heap Usage:
PS Young Generation
Eden Space:
   capacity = 235929600 (225.0MB)
   used     = 169898184 (162.02753448486328MB)
   free     = 66031416 (62.97246551513672MB)
   72.01223754882812% used
From Space:
   capacity = 39321600 (37.5MB)
   used     = 0 (0.0MB)
   free     = 39321600 (37.5MB)
   0.0% used
To Space:
   capacity = 39321600 (37.5MB)
   used     = 0 (0.0MB)
   free     = 39321600 (37.5MB)
   0.0% used
PS Old Generation
   capacity = 419430400 (400.0MB)
   used     = 0 (0.0MB)
   free     = 419430400 (400.0MB)
   0.0% used
PS Perm Generation
   capacity = 104857600 (100.0MB)
   used     = 14140688 (13.485610961914062MB)
   free     = 90716912 (86.51438903808594MB)
   13.485610961914062% used
```

根据打印的结果:默认存活区与eden比率=2:8

*   查看 eden 区:225M

*   两个存活区大小:都为37.5M

*   年轻代大小:300M

*   老年代大小:400M

*   持久代大小:100M

*   最大堆内存大小:年轻代大小+老年代大小=700M

*   java 应用程序占用内存大小:最大堆内存大小+持久代大小=700M+100M=800M

对应java参数(在tomcat的启动文件里)配置如下:

```bash
JAVA_OPTS="-Xms700m -Xmx700m -Xmn300m -Xss1024K -XX:PermSize=100m -XX:MaxPermSize=100 -XX:+UseParallelGC -XX:ParallelGCThreads=1 -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/opt/logs/gc.log -verbose:gc -XX:+DisableExplicitGC"
```

注意参数配置时, 上述参数为一行. 

各参数意义:

-   Xms
-   Xmx
-   Xmn
-   Xss
-   -XX:PermSize
-   -XX:MaxPermSize
-   NewRatio = 2  表示新生代(e+2s):老年代(不含永久区)=1:2, 指新生代占整个堆的1/3
-   SurvivorRatio = 8  表示2个S:eden=2:8, 一个S占年轻代的1/10



#### 展示 class 的内存情况

```bash
jmap -histo pid
```

说明: instances(实例数)、bytes(大小)、classs name(类名). 它基本是按照使用使用大小逆序排列的.  

```bash
# instance 是对象的实例个数 
# bytes 是总占用的字节数 
class name 对应的就是 Class 文件里的 class 的标识 
B 代表 byte
C 代表 char
D 代表 double
F 代表 float
I 代表 int
J 代表 long
Z 代表 boolean
前边有 [ 代表数组,  [I 就相当于 int[]
对象用 [L+ 类名表示
```

从打印结果可看出, 类名中存在[C、[B等内容, 

只知道它占用了那么大的内存, 但不知道由什么对象创建的. 下一步需要将其他dump出来, 使用内存分析工具进一步明确它是由谁引用的、由什么对象. 

```bash
jmap -histo:live pid>a.log
```

可以观察heap中所有对象的情况(heap中所有生存的对象的情况). 包括对象数量和所占空间大小. 可以将其保存到文本中去, 在一段时间后, 使用文本对比工具, 可以对比出GC回收了哪些对象. 

jmap -histo:live 这个命令执行, JVM 会先触发 gc, 然后再统计信息. 



#### 将内存使用的详细情况输出到文件

```bash
jmap -dump:format=b,file=heap pid
```

说明:内存信息 dump 到 a.log 文件中.

这个命令执行, JVM 会将整个 heap 的信息 dump 写入到一个文件, heap 如果比较大的话, 就会导致这个过程比较耗时, 并且执行的过程中为了保证 dump 的信息是可靠的, 所以会暂停应用. 



### 查看 cpu 使用率 top, ps

查看 CPU 使用率过高的进程

```bash
top
```

查看进程中使用 cpu 过高的线程

```bash
ps H -eo pid,tid,%cpu | grep pid
top -H -p pid
```



### 查看线程使用率 jstack

```bash
jstack pid | grep $线程号(16进制)
```



### Arthas 手册

1. 启动 arthas java -jar arthas-boot.jar
2. 绑定 java 进程
3. dashboard 命令观察系统整体情况
4. help 查看帮助
5. help xx 查看具体命令帮助




## 虚拟机工具

### jps(虚拟机进程状况工具)

* jps(java process status)

* 查看本地虚拟机唯一id lvmid(local virtual machine id)

* jps -l 输出主类的全名，如果进程执行的是jar包，输出jar包路径

* jps -m 输出虚拟机进程启动时传递给主类main()函数的参数

* jps -v 输出虚拟机进程启动时的JVM参数

* jps -q 只输出LVMID，省略主类的名称

### jstat(虚拟机统计信息监控工具)

* 监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程（需要远程主机提供RMI支持）虚拟机进程中的类信息、内存、垃圾收集、JIT编译等运行数据，在没有GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。

* jstat [ option vmid [ interval [ s | ms ] [ count ] ] ]

    这个VMID，对于本地虚拟机进程而言，VMID和LVMID是一致的。参数interval和count分别表示查询间隔和次数，如果省略这两个参数，说明只查询一次，假设需要每250毫秒查询一次进程2764的垃圾收集情况，一共查询20次，那命令应当是：

        jstat -gc 2764 250 20

    jstat主要工具选项

    | 选       项       | 作              用                                           |
    | ----------------- | ------------------------------------------------------------ |
    | -class            | 监视类装载、卸载数量、总空间以及类装载所耗费的时间           |
    | -gc               | 监视Java堆状况，包括Eden区、两个Survivor区、、老年代、永久带等的容量、已用空间、GC时间合计等信息 |
    | -gccapacity       | 监视内容基本与-gc相同，但输出主要关注Java堆各个区域使用到的最大、最小空间 |
    | -gcutil           | 监视内容基本与-gc相同，但输出主要关注已使用的空间占总空间的百分比 |
    | -gccause          | 与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因      |
    | -gcnew            | 监视新生代GC状况                                             |
    | -gcnewcapacity    | 监视内容基本与-gcnew相同，但输出主要关注使用到的最大、最小空间 |
    | -gcold            | 监视老年代GC状况                                             |
    | -gcoldcapacity    | 监视内容基本与-gcold相同，但输出主要关注使用到的最大、最小空间 |
    | -gcpermcapacity   | 输出永久代使用到的最大、最小空间                             |
    | -compiler         | 输出JIT编译器编译过的方法、耗时等信息                        |
    | -printcompilation | 输出已经被JIT编译的方法                                      |

* 类装载, 内存, 垃圾收集, jit编译的信息

### jinfo(Java配置信息工具)

* jinfo（Configuration Info for Java）的作用是实时地查看和调整虚拟机各项参数。使用jps命令的-v可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，可以使用jinfo的-flag选项进行查询，jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来。

* jinfo [ option ] pid

### jmap(Java内存映像工具)

* jmap（Memory Map for Java）命令用于生成堆转储快照。如果不使用jmap命令，要想获取Java堆转储，可以使用“-XX:+HeapDumpOnOutOfMemoryError”参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，Linux命令下可以通过kill -3发送进程退出信号也能拿到dump文件。

    jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和jinfo一样，jmap有不少功能在Windows平台下也是受限制的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux和Solaris系统下使用

* jmap [ option ] vmid

* jmap -dump:format=b,file=/asf/a.bin pid

    | 选项           | 作用                                                         |
    | -------------- | ------------------------------------------------------------ |
    | -dump          | 生成Java堆转储快照。格式为-dump:[live, ]format=b,file=<filename>，其中live自参数说明是否只dump出存活的对象 |
    | -finalizerinfo | 显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux和Solaris系统下有效 |
    | -heap          | 显示Java堆详细信息，如使用哪种收集器、参数配置、分代状况等。只在Linux和Solaris系统下有效 |
    | -histo         | 显示堆中对象统计信息，包括类、实例数量、合计容量             |
    | -permstat      | 以ClassLoader为统计口径显示永久代内存状态。只在Linux和Solaris系统下有效 |
    | -F             | 当虚拟机进行对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux和Solaris系统下有效 |

### jhat(jvm heap analysis tool)

### jstack

* jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。

* jstack [ option ] vmid

    | 选    项 | 作             用                             |
    | -------- | --------------------------------------------- |
    | -F       | 当正常输出的请求不被响应时，强制输出线程堆栈  |
    | -l       | 除堆栈外，显示关于锁的附加信息                |
    | -m       | 如果调用到本地方法的时候，可以显示C/C++的堆栈 |











## Java 调优

```bash
java -XX:+PrintFlagsInitial 查看 jvm 默认参数
java -XX:+PrintFlagsFinal -version 查看 jvm 改动后的参数 =代表没被修改过 :=代表被修改过
java -XX:+PrintCommandLineFlags -version
```

**常用参数**

*   -Xms20M

    初始大小内存, 默认为物理内存的 1/64, 等价于 -XX:InitialHeapSize

*   -Xmx20M

    最大分配内存, 默认为物理内存的 1/4, 等价于-XX:MaxHeapSize, 将-Xmx和-Xms设置为一样可以避免堆自动扩展。大的项目-Xmx和-Xms一般都要设置到10G、20G甚至还要高

*   -Xss20M

    设置单个线程栈的大小, 一般默认为 512k~1024k, 等价于-XX:ThreadStackSize

*   -Xmn20M

    设置年轻代大小

*   -XX:MetaspaceSize

    设置元空间大小

*   -XX:PrintGCDetails

    打印 GC 细节

*   -XX:+HeapDumpOnOutOfMemoryError

    当内存溢出时触发 java.lang.OutOfMemo: Java heap space

*   -XX:HeapDumpPath=/opt/heap

    内存溢出时，保存内存快照文件

*   -verbose:gc

    表示输出虚拟机中GC的详细情况

*   -Xoss128k

    表示设置本地方法栈的大小为128k。不过HotSpot并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说这个参数是无效的

*   -XX:PermSize=10M

    表示JVM初始分配的永久代的容量，必须以M为单位

*   -XX:MaxPermSize=10M

    表示JVM允许分配的永久代的最大容量，必须以M为单位，大部分情况下这个参数默认为64M

    **知识点：JDK8之后把-XX:PermSize 和 -XX:MaxPermGen移除了，取而代之的是**

*   -XX:MetaspaceSize=128m

    元空间默认大小

*   -XX:MaxMetaspaceSize=128m

    元空间最大大小

*   -Xnoclassgc

    表示关闭JVM对类的垃圾回收

*   -XX:+TraceClassLoading

    表示查看类的加载信息

*   -XX:+TraceClassUnLoading

    表示查看类的卸载信息

*   -XX:NewRatio=4

    表示设置年轻代：老年代的大小比值为1：4，这意味着年轻代占整个堆的1/5

*   -XX:SurvivorRatio=8

    表示设置2个Survivor区：1个Eden区的大小比值为2:8，这意味着Survivor区占整个年轻代的1/5，这个参数默认为8

*   -XX:+UseG1GC

    表示让JVM使用G1垃圾收集器

*   -XX:+PrintGCDetails

    表示在控制台上打印出GC具体细节

*   -XX:+PrintGC

    表示在控制台上打印出GC信息

*   -XX:PretenureSizeThreshold=3145728

    表示对象大于3145728（3M）时直接进入老年代分配，这里只能以字节作为单位

*   -XX:MaxTenuringThreshold=1

    表示对象年龄大于1，自动进入老年代

*   -XX:CompileThreshold=1000

    表示一个方法被调用1000次之后，会被认为是热点代码，并触发即时编译

*   -XX:+PrintHeapAtGC

    表示可以看到每次GC前后堆内存布局

*   -XX:+PrintTLAB

    表示可以看到TLAB的使用情况

*   -XX:+UseSpining

    开启自旋锁

*   -XX:PreBlockSpin

    更改自旋锁的自旋次数，使用这个参数必须先开启自旋锁





## OOM

java.lang.StackOverflowError

java.lang.OutOfMemoryError: Java heap space

java.lang.OutOfMemoryError: GC overhead limit exceeded

java.lang.OutOfMemoryError: Direct buffer memory

java.lang.OutOfMemoryError: unable to create new natived thread

java.lang.OutOfMemoryError: Metaspace



## 生产环境服务器变慢诊断

整机: top, uptime

cpu: vmstat

内存: free

硬盘: df

磁盘 io: iostat

网络 io: ifstat



## GC 调优

### 常见垃圾回收器组合参数设定: (1.8)

-XX:+UseSerialGC = Serial New (DefNew) + Serial Old

* 小型程序. 默认情况下不会是这种选项, HotSpot会根据计算及配置和JDK版本自动选择收集器

-XX:+UseParNewGC = ParNew + SerialOld

* 这个组合已经很少用(在某些版本中已经废弃)
* https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future

-XX:+UseConcurrentMarkSweepGC = ParNew + CMS + Serial Old

-XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】

-XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old

-XX:+UseG1GC = G1

Linux中没找到默认GC的查看方法, 而windows中会打印UseParallelGC 

* java +XX:+PrintCommandLineFlags -version
* 通过GC的日志来分辨

Linux下1.8版本默认的垃圾回收器到底是什么? 

* 1.8.0_181 默认(看不出来)Copy MarkCompact
* 1.8.0_222 默认 PS + PO

### GC常用参数

* -Xmn -Xms -Xmx -Xss

    年轻代 最小堆 最大堆 栈空间

* -XX:+UseTLAB

    使用TLAB, 默认打开

* -XX:+PrintTLAB

    打印TLAB的使用情况

* -XX:TLABSize

    设置TLAB大小

* -XX:+DisableExplictGC

    System.gc()不管用 , FGC

* -XX:+PrintGC

* -XX:+PrintGCDetails

* -XX:+PrintHeapAtGC

* -XX:+PrintGCTimeStamps

* -XX:+PrintGCApplicationConcurrentTime (低)

    打印应用程序时间

* -XX:+PrintGCApplicationStoppedTime (低)

    打印暂停时长

* -XX:+PrintReferenceGC (重要性低)

    记录回收了多少种不同引用类型的引用

* -verbose:class

    类加载详细过程

* -XX:+PrintVMOptions

* -XX:+PrintFlagsFinal  -XX:+PrintFlagsInitial

    必须会用

* -Xloggc:opt/log/gc.log

* -XX:MaxTenuringThreshold

    升代年龄, 最大值15

* 锁自旋次数 -XX:PreBlockSpin 热点代码检测参数-XX:CompileThreshold 逃逸分析 标量替换 ... 

    这些不建议设置

### Parallel常用参数

* -XX:SurvivorRatio

* -XX:PreTenureSizeThreshold

    大对象到底多大

* -XX:MaxTenuringThreshold

* -XX:+ParallelGCThreads

    并行收集器的线程数, 同样适用于CMS, 一般设为和CPU核数相同

* -XX:+UseAdaptiveSizePolicy

    自动选择各区大小比例

### CMS常用参数

* -XX:+UseConcMarkSweepGC

* -XX:ParallelCMSThreads

    CMS 线程数量

* -XX:CMSInitiatingOccupancyFraction

    使用多少比例的老年代后开始CMS收集, 默认是68%(近似值), 如果频繁发生SerialOld卡顿, 应该调小, (频繁CMS回收)

* -XX:+UseCMSCompactAtFullCollection

    在FGC时进行压缩

* -XX:CMSFullGCsBeforeCompaction

    多少次FGC之后进行压缩

* -XX:+CMSClassUnloadingEnabled

* -XX:CMSInitiatingPermOccupancyFraction

    达到什么比例时进行Perm回收

* GCTimeRatio

    设置GC时间占用程序运行时间的百分比

* -XX:MaxGCPauseMillis

    停顿时间, 是一个建议时间, GC会尝试用各种手段达到这个时间, 比如减小年轻代

### G1常用参数

* -XX:+UseG1GC

* -XX:MaxGCPauseMillis

    建议值, G1 会尝试调整 Young 区的块数来达到这个值

* -XX:GCPauseIntervalMillis
    GC 的间隔时间

* -XX:+G1HeapRegionSize

    分区大小, 建议逐渐增大该值, 1 2 4 8 16 32. 

    随着 size 增加, 垃圾的存活时间更长, GC 间隔更长, 但每次 GC 的时间也会更长

    ZGC做了改进(动态区块大小)

* G1 NewSizePercent

    新生代最小比例, 默认为 5%

* G1MaxNewSizePercent

    新生代最大比例, 默认为 60%

* GCTimeRatio

    GC时间建议比例, G1 会根据这个值调整堆空间

* ConcGCThreads

    线程数量

* InitiatingHeapOccupancyPercent

    启动G1的堆空间占用比



## 线上服务的 FGC 问题排查

线上服务的GC问题，是Java程序非常典型的一类问题，非常考验工程师排查问题的能力。同时，几乎是面试必考题，但是能真正答好此题的人并不多，要么原理没吃透，要么缺乏实战经验。

过去半年时间里，我们的广告系统出现了多次和GC相关的线上问题，有Full GC过于频繁的，有Young GC耗时过长的，这些问题带来的影响是：GC过程中的程序卡顿，进一步导致服务超时从而影响到广告收入。

这篇文章，我将以一个Full GC频繁的线上案例作为引子，详细介绍下GC的排查过程，另外会结合GC的运行原理给出一份实践指南，希望对你有所帮助。内容分成以下3个部分：

-   从一次Full GC频繁的线上案例说起
-   GC的运行原理介绍
-   排查Full GC问题的实践指南

### 从一次 Full GC 频繁的线上案例说起

去年10月份，我们的广告召回系统在程序上线后收到了FGC频繁的系统告警，通过下面的监控图可以看到：平均每35分钟就进行了一次FGC。而程序上线前，我们的FGC频次大概是2天一次。下面，详细介绍下该问题的排查过程。

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_11.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_11.png" />

### 检查JVM配置

通过以下命令查看JVM的启动参数：

```bash
ps aux | grep "applicationName=adsearch"
```

-   -Xms4g -Xmx4g -Xmn2g -Xss1024K
-   -XX:ParallelGCThreads=5
-   -XX:+UseConcMarkSweepGC
-   -XX:+UseParNewGC
-   -XX:+UseCMSCompactAtFullCollection
-   -XX:CMSInitiatingOccupancyFraction=80

可以看到堆内存为4G，新生代为2G，老年代也为2G，新生代采用ParNew收集器，老年代采用并发标记清除的CMS收集器，当老年代的内存占用率达到80%时会进行FGC。
进一步通过 jmap -heap 7276 | head -n20 可以得知新生代的Eden区为1.6G，S0和S1区均为0.2G。

### 观察老年代的内存变化

通过观察老年代的使用情况，可以看到：每次FGC后，内存都能回到500M左右，因此我们排除了内存泄漏的情况。

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_12.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_12.png" />

### 通过jmap命令查看堆内存中的对象

通过命令 `jmap -histo 7276 | head -n20`

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_13.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_13.png" />

上图中，按照对象所占内存大小排序，显示了存活对象的实例数、所占内存、类名。可以看到排名第一的是：int[]，而且所占内存大小远远超过其他存活对象。至此，我们将怀疑目标锁定在了 int[] 。

### 进一步dump堆内存文件进行分析

锁定 int[] 后，我们打算dump堆内存文件，通过可视化工具进一步跟踪对象的来源。考虑堆转储过程中会暂停程序，因此我们先从服务管理平台摘掉了此节点，然后通过以下命令dump堆内存：

```bash
jmap -dump:format=b,file=heap 7276
```

通过JVisualVM工具导入dump出来的堆内存文件，同样可以看到各个对象所占空间，其中int[]占到了50%以上的内存，进一步往下便可以找到 int[] 所属的业务对象，发现它来自于架构团队提供的codis基础组件

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_14.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_14.png" />

### 通过代码分析可疑对象

通过代码分析，codis基础组件每分钟会生成约40M大小的int数组，用于统计TP99 和 TP90，数组的生命周期是一分钟。而根据第2步观察老年代的内存变化时，发现老年代的内存基本上也是每分钟增加40多M，因此推断：这40M的int数组应该是从新生代晋升到老年代。

我们进一步查看了YGC的频次监控，通过下图可以看到大概1分钟有8次左右的YGC，这样基本验证了我们的推断：因为CMS收集器默认的分代年龄是6次，即YGC 6次后还存活的对象就会晋升到老年代，而codis组件中的大数组生命周期是1分钟，刚好满足这个要求。

<img src="https://miaomiaoqi.github.io/images/jvm/jvm_15.png" alt="https://miaomiaoqi.github.io/images/jvm/jvm_15.png" />

至此，整个排查过程基本结束了，那为什么程序上线前没出现此问题呢？通过上图可以看到：程序上线前YGC的频次在5次左右，此次上线后YGC频次变成了8次左右，从而引发了此问题。

### 解决方案

为了快速解决问题，我们将CMS收集器的分代年龄改成了15次，改完后FGC频次恢复到了2天一次，后续如果YGC的频次超过每分钟15次还会再次触发此问题。当然，我们最根本的解决方案是：优化程序以降低YGC的频率，同时缩短codis组件中int数组的生命周期，这里就不做展开了。



### 那到底什么情况下，GC会对程序产生影响呢？

不管YGC还是FGC，都会造成一定程度的程序卡顿（即Stop The World问题：GC线程开始工作，其他工作线程被挂起），即使采用ParNew、CMS或者G1这些更先进的垃圾回收算法，也只是在减少卡顿时间，而并不能完全消除卡顿。

根据严重程度从高到底，我认为包括以下4种情况：

-   **FGC过于频繁**：FGC通常是比较慢的，少则几百毫秒，多则几秒，正常情况FGC每隔几个小时甚至几天才执行一次，对系统的影响还能接受。但是，一旦出现FGC频繁（比如几十分钟就会执行一次），这种肯定是存在问题的，它会导致工作线程频繁被停止，让系统看起来一直有卡顿现象，也会使得程序的整体性能变差。
-   **YGC耗时过长**：一般来说，YGC的总耗时在几十或者上百毫秒是比较正常的，虽然会引起系统卡顿几毫秒或者几十毫秒，这种情况几乎对用户无感知，对程序的影响可以忽略不计。但是如果YGC耗时达到了1秒甚至几秒（都快赶上FGC的耗时了），那卡顿时间就会增大，加上YGC本身比较频繁，就会导致比较多的服务超时问题。
-   **FGC耗时过长**：FGC耗时增加，卡顿时间也会随之增加，尤其对于高并发服务，可能导致FGC期间比较多的超时问题，可用性降低，这种也需要关注。
-   **YGC过于频繁**：即使YGC不会引起服务超时，但是YGC过于频繁也会降低服务的整体性能，对于高并发服务也是需要关注的。
    其中，「FGC过于频繁」和「YGC耗时过长」，这两种情况属于比较典型的GC问题，大概率会对程序的服务质量产生影响。剩余两种情况的严重程度低一些，但是对于高并发或者高可用的程序也需要关注。



## 排查 FullGC 指南

### 清楚从程序角度，有哪些原因导致FGC？

-   大对象：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。
-   内存泄漏：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.
-   程序频繁生成一些长生命周期的对象，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）
-   程序BUG导致动态生成了很多新类，使得 Metaspace 不断被占用，先引发FGC，最后导致OOM.
-   代码中显式调用了gc方法，包括自己的代码甚至框架中的代码。
-   JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。

### 清楚排查问题时能使用哪些工具

公司的监控系统：大部分公司都会有，可全方位监控JVM的各项指标。
JDK的自带工具，包括jmap、jstat等常用命令：

-   \# 查看堆内存各区域的使用率以及GC情况
-   jstat -gcutil -h20 pid 1000
-   \# 查看堆内存中的存活对象，并按空间排序
-   jmap -histo pid | head -n20
-   \# dump堆内存文件
-   jmap -dump:format=b,file=heap pid

可视化的堆内存分析工具：JVisualVM、MAT, JProfile 等

### 排查指南

1.  查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）
2.  了解该时间点之前有没有程序上线、基础组件升级等情况。
3.  了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。
4.  再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。
5.  针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。
6.  通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。





## 参考资料

1. [https://blogs.oracle.com/](https://blogs.oracle.com/jonthecollector/our-collectors)[jonthecollector](https://blogs.oracle.com/jonthecollector/our-collectors)[/our-collectors](https://blogs.oracle.com/jonthecollector/our-collectors)
2. [https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)
3. [http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp)
4. JVM 调优参考文档: [https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184](https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184) 
5. [https://www.cnblogs.com/nxlhero/p/11660854.html](https://www.cnblogs.com/nxlhero/p/11660854.html) 在线排查工具
6. [https://www.jianshu.com/p/507f7e0cc3a3](https://www.jianshu.com/p/507f7e0cc3a3) arthas常用命令
7. [https://blog.csdn.net/chenssy/article/details/78271744](https://blog.csdn.net/chenssy/article/details/78271744) 分析hotspot error file







































