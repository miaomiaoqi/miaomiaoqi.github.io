---
layout: post
title: java 变量
categories: [Java]
description: 
keywords: 
---


* content
{:toc}






## 自增变量

```java
/**
 * 赋值=, 最后计算
 * =右边的从左到右加载值依次压入操作数栈
 * 实际先算哪个, 看运算符优先级
 * 自增、自减操作都是直接修改变量的值, 不经过操作数栈
 * 最后的赋值之前, 临时结果也是存储在操作数栈中
 *
 * @author miaoqi
 * @date 2023-05-12 16:27:6
 */
public class Exam1 {

    public static void main(String[] args) {
        int i = 1;
        // 1. 把 i 的值压入操作数栈(此时 i 的值已经被单独提取出来)
        // 2. i 变量自增 1
        // 3. 把操作数栈中的值赋值给 i
        // 可以理解为 int t = i; i = i + 1; i = t;
        i = i++;
        // 1. 把 i 的值压入操作数栈
        // 2. i 变量自增 1
        // 3. 把操作数栈中的值赋值给j
        // 可以理解为 int t = i; i = i + 1; j = t;
        int j = i++;
        // 1. 把 i 的值压入操作数栈
        // 2. i 变量自增 1
        // 3. 把 i 的值压入操作数栈
        // 4. 把 i 的值压入操作数栈
        // 5. i 变量自增 1
        // 6. 把操作数栈中前两个弹出求乘积结果再压入栈
        // 7. 把操作数栈中的值弹出求和再赋值给k
        int k = i + ++i * i++;
        System.out.println("i=" + i); // 4
        System.out.println("j=" + j); // 1
        System.out.println("k=" + k); // 11
    }

}
```



## 类初始化和实例初始化

Father

```java
/*
 * 父类的初始化<clinit>: 
 * （1）j = method();
 * （2）父类的静态代码块
 *
 *  父类的实例化方法: 
 * （1）super()（最前）
 * （2）i = test();
 * （3）父类的非静态代码块
 * （4）父类的无参构造（最后）
 *
 * 非静态方法前面其实有一个默认的对象 this
 * this 在构造器（或<init>）它表示的是正在创建的对象, 因为这里是在创建Son对象, 所以
 * test()执行的是子类重写的代码（面向对象多态）
 *
 * 这里i=test()执行的是子类重写的test()方法
 */
public class Father {

    private int i = test();
    private static int j = method();

    static {
        System.out.print("(1)");
    }

    Father() {
        System.out.print("(2)");
    }

    {
        System.out.print("(3)");
    }


    public int test() {
        System.out.print("(4)");
        return 1;
    }

    public static int method() {
        System.out.print("(5)");
        return 1;
    }

}
```

Son

```java
/*
 * 子类的初始化<clinit>: 
 * （1）j = method();
 * （2）子类的静态代码块
 *
 * 先初始化父类: (5)(1)
 * 初始化子类: （10）(6)
 *
 * 子类的实例化方法<init>: 
 * （1）super()（最前）      （9）（3）（2）
 * （2）i = test();    （9）
 * （3）子类的非静态代码块    （8）
 * （4）子类的无参构造（最后） （7）
 *
 * 因为创建了两个 Son 对象, 因此实例化方法<init>执行两次
 *
 * （9）（3）（2）（9）（8）（7）
 */
public class Son extends Father {

    private int i = test();
    private static int j = method();

    static {
        System.out.print("(6)");
    }

    Son() {
        // super(); // 写或不写都在, 在子类构造器中一定会调用父类的构造器
        System.out.print("(7)");
    }

    {
        System.out.print("(8)");
    }

    public int test() {
        System.out.print("(9)");
        return 1;
    }

    public static int method() {
        System.out.print("(10)");
        return 1;
    }

    public static void main(String[] args) {
        Son s1 = new Son();
        System.out.println();
        Son s2 = new Son();
    }

}
```

