---
layout: post
title: "线程池"
categories: [Java]
description:
keywords:
---

* content
{:toc}


## 线程池

在 web 开发中, 服务器需要接受并处理请求, 所以会为一个请求来分配一个线程来进行处理.如果每次请求都新创建一个线程的话实现起来非常简便, 但是存在一个问题: 

**如果并发的请求数量非常多, 但每个线程执行的时间很短, 这样就会频繁的创建和销毁线程, 如此一来会大大降低系统的效率.可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多.**

那么有没有一种办法使执行完一个任务, 并不被销毁, 而是可以继续执行其他的任务呢?

这就是线程池的目的了.线程池为线程生命周期的开销和资源不足问题提供了解决方案.通过对多个任务重用线程, 线程创建的开销被分摊到了多个任务上.

**什么时候使用线程池?**

* 单个任务处理时间比较短

* 需要处理的任务数量很大

**使用线程池的好处**

* 降低资源消耗.通过重复利用已创建的线程降低线程创建和销毁造成的消耗.

* 提高响应速度.当任务到达时, 任务可以不需要的等到线程创建就能立即执行.

* 提高线程的可管理性.线程是稀缺资源, 如果无限制的创建, 不仅会消耗系统资源, 还会降低系统的稳定性, 使用线程池可以进行统一的分配, 调优和监控.

**Java 中的线程池是用 ThreadPoolExecutor 类来实现的**

<img src="http://www.milky.show/images/thread/executor_1.png" style="zoom: 50%;" />

## Executor 框架接口

Executor 框架是一个根据一组执行策略调用, 调度, 执行和控制的异步任务的框架, 目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制.

J.U.C 中有三个 Executor 接口: 

* **Executor**: 一个运行新任务的简单接口

    Executor接口只有一个 execute 方法, 用来替代通常创建或启动线程的方法

* **ExecutorService**: 扩展了 Executor 接口.添加了一些用来管理执行器生命周期和任务生命周期的方法;

    ExecutorService 接口继承自 Executor 接口, 提供了管理终止的方法, 以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法. 增加了 shutDown(), shutDownNow(), invokeAll(), invokeAny() 和 submit() 等方法.如果需要支持即时关闭, 也就是 shutDownNow() 方法, 则任务需要正确处理中断.

* **ScheduledExecutorService**: 扩展了 ExecutorService.支持 Future 和定期执行任务.

    ScheduledExecutorService 扩展 ExecutorService 接口并增加了 schedule 方法.调用 schedule 方法可以在指定的延时后执行一个 Runnable 或者 Callable 任务. ScheduledExecutorService 接口还定义了按照指定时间间隔定期执行任务的 scheduleAtFixedRate() 方法和 scheduleWithFixedDelay() 方法.

### Executor 接口

```java
public interface Executor {
    void execute(Runnable command);
}
```

Executor 接口只有一个 execute 方法, 用来替代通常创建或启动线程的方法.例如, 使用 Thread 来创建并启动线程的代码如下: 

```java
Thread t = new Thread();
t.start();
```

使用 Executor 来启动线程执行任务的代码如下: 

```java
Thread t = new Thread();
executor.execute(t);
```

对于不同的 Executor 实现, execute() 方法可能是创建一个新线程并立即启动, 也有可能是使用已有的工作线程来运行传入的任务, 也可能是根据设置线程池的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接收传入的线程.

### ExecutorService 接口

ExecutorService 接口继承自 Executor 接口, 提供了管理终止的方法, 以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法.增加了 shutDown(), shutDownNow(), invokeAll(), invokeAny() 和 submit() 等方法.如果需要支持即时关闭, 也就是 shutDownNow() 方法, 则任务需要正确处理中断.

### ScheduledExecutorService 接口

ScheduledExecutorService 扩展 ExecutorService 接口并增加了 schedule 方法.调用 schedule 方法可以在指定的延时后执行一个 Runnable 或者 Callable 任务. ScheduledExecutorService 接口还定义了按照指定时间间隔定期执行任务的 scheduleAtFixedRate() 方法和 scheduleWithFixedDelay() 方法.



### Executors 工具类

Executors 是 java 提供的创建线程池的工具类, 主要提供了如下四个方法, 但是不推荐用这四个方法, 希望开发人员可以手动创建线程池, 深入了解参数的意义

* newSingleThreadExecutor

  只有一个线程的线程池. corePoolSize = maximumPoolSize = 1, keepAliveTime为0, 工作队列使用无界的 LinkedBlockingQueue. 适用于需要保证顺序的执行各个任务的场景. 

* newFixedThreadPool

  固定线程数的线程池. corePoolSize = maximumPoolSize, keepAliveTime为0, 工作队列使用无界的 LinkedBlockingQueue. 适用于为了满足资源管理的需求, 而需要限制当前线程数量的场景, 适用于负载比较重的服务器. 

* newCachedThreadPool

  按需要创建新线程的线程池. 核心线程数为0, 最大线程数为 Integer.MAX_VALUE, keepAliveTime 为 60 秒, 工作队列使用同步移交 SynchronousQueue. 该线程池可以无限扩展, 当需求增加时, 可以添加新的线程, 而当需求降低时会自动回收空闲线程. 适用于执行很多的短期异步任务, 或者是负载较轻的服务器. 

* newScheduledThreadPool

  创建一个以延迟或定时的方式来执行任务的线程池, 工作队列为 DelayedWorkQueue. 适用于需要多个后台线程执行周期任务. 
  
* newWorkStealingPool

    JDK 1.8 新增, 用于创建一个可以窃取的线程池, 底层使用 ForkJoinPool 实现. 

## ThreadPoolExecutor 分析

ThreadPoolExecutor 继承自 AbstractExecutorService, 也是实现了 ExecutorService 接口.

**线程池的实现类都是由 ThreadPoolExecutor 构建的,  Executors 类内部也是使用 ThreadPoolExecutor 构建线程池对象**

<img src="http://www.milky.show/images/thread/executor_2.png" alt="http://www.milky.show/images/thread/executor_2.png" style="zoom:50%;" />

**ctl 是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段, 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount), 这里可以看到, 使用了 Integer 类型来保存, 高 3 位保存 runState, 低 29 位保存 workerCount.COUNT_BITS 就是 29, CAPACITY 就是1 左移 29 位减 1(29个1), 这个常量表示 workerCount 的上限值, 大约是5亿.**

**ThreadPoolExecutor 核心属性**

```java
public ThreadPoolExecutor(int corePoolSize, 
                      int maximumPoolSize, 
                      long keepAliveTime, 
                      TimeUnit unit, 
                      BlockingQueue<Runnable> workQueue, 
                      ThreadFactory threadFactory, 
                      RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

构造方法中的字段含义如下:

- **corePoolSize:** 核心线程数量, 当有新任务在 execute() 方法提交时, 会执行以下判断

    1. 如果运行的线程少于 corePoolSize, 则创建新线程来处理任务, 即使线程池中的其他线程是空闲的
    2. 如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize, 则只有当workQueue满时才创建新的线程去处理任务
    3. 如果设置的 corePoolSize 和 maximumPoolSize 相同, 则创建的线程池的大小是固定的, 这时如果有新任务提交, 若 workQueue 未满, 则将请求放入 workQueue 中, 等待有空闲的线程去从 workQueue 中取任务并处理
    4. 如果运行的线程数量大于等于 maximumPoolSize, 这时如果 workQueue 已经满了, 则通过 handler 所指定的拒绝策略来处理任务

    所以, 任务提交时, 判断的顺序为 corePoolSize --> workQueue --> maximumPoolSize.

- **maximumPoolSize:** 最大线程数量

- **workQueue:** 保存等待执行的任务的阻塞队列, 当提交一个新的任务到线程池以后,  线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式, 主要有以下几种处理方式:

    * **直接切换:** 这种方式常用的队列是 SynchronousQueue, 但现在还没有研究过该队列, 这里暂时还没法介绍;

    * **使用无界队列:** 一般使用基于链表的阻塞队列 LinkedBlockingQueue. 如果使用这种方式, 那么线程池中能够创建的最大线程数就是 corePoolSize, 而 maximumPoolSize 就不会起作用了(后面也会说到).当线程池中所有的核心线程都是 RUNNING 状态时, 这时一个新的任务提交就会放入等待队列中.

    * **使用有界队列:** 一般使用 ArrayBlockingQueue. 使用该方式可以将线程池的最大线程数量限制为 maximumPoolSize, 这样能够降低资源的消耗, 但同时这种方式也使得线程池对线程的调度变得更困难, 因为线程池和队列的容量都是有限的值, 所以要想使线程池处理任务的吞吐率达到一个相对合理的范围, 又想使线程调度相对简单, 并且还要尽可能的降低线程池对资源的消耗, 就需要合理的设置Ï这两个数量.
        * 如果要想降低系统资源的消耗(包括 CPU 的使用率, 操作系统资源的消耗, 上下文环境切换的开销等), 可以设置较大的队列容量和较小的线程池容量,  但这样也会降低线程处理任务的吞吐量.
        * 如果提交的任务经常发生阻塞, 那么可以考虑通过调用 setMaximumPoolSize() 方法来重新设定线程池的容量.
        * 如果队列的容量设置的较小, 通常需要将线程池的容量设置大一点, 这样 CPU 的使用率会相对的高一些.但如果线程池的容量设置的过大, 则在提交的任务数量太多的情况下, 并发量会增加, 那么线程之间的调度就是一个要考虑的问题, 因为这样反而有可能降低处理任务的吞吐量.

- **keepAliveTime:** 线程池维护线程所允许的空闲时间. 当线程池中的线程数量大于 corePoolSize 的时候, 如果这时没有新的任务提交, 核心线程外的线程不会立即销毁, 而是会等待, 直到等待的时间超过了 keepAliveTime

- **threadFactory:** 它是 ThreadFactory 类型的变量, 用来创建新线程. 默认使用 Executors.defaultThreadFactory() 来创建线程. 使用默认的 ThreadFactory 来创建线程时, 会使新创建的线程具有相同的 NORM_PRIORITY 优先级并且是非守护线程, 同时也设置了线程的名称.

- **rejectHandler:** 它是 RejectedExecutionHandler 类型的变量, 表示线程池的饱和策略. 如果阻塞队列满了并且没有空闲的线程, 这时如果继续提交任务, 就需要采取一种策略处理该任务.线程池提供了 4 种策略: 

    * **AbortPolicy:** 中止策略. 默认的拒绝策略, 直接抛出 RejectedExecutionException. 调用者可以捕获这个异常, 然后根据需求编写自己的处理代码. 
    * **CallerRunsPolicy:** 调用者运行策略. 在调用者线程中执行该任务. 该策略实现了一种调节机制, 该策略既不会抛弃任务, 也不会抛出异常, 而是将任务回退到调用者(调用线程池执行任务的主线程), 由于执行任务需要一定时间, 因此主线程至少在一段时间内不能提交任务, 从而使得线程池有时间来处理完正在执行的任务. 
    * **DiscardOldestPolicy:** 抛弃最老策略. 抛弃阻塞队列中最老的任务, 相当于就是队列中下一个将要被执行的任务, 然后重新提交被拒绝的任务. 如果阻塞队列是一个优先队列, 那么“抛弃最旧的”策略将导致抛弃优先级最高的任务, 因此最好不要将该策略和优先级队列放在一起使用. 
    * **DiscardPolicy:** 抛弃策略. 什么都不做, 直接抛弃被拒绝的任务. 

<img src="http://www.milky.show/images/thread/executor_6.png" alt="http://www.milky.show/images/thread/executor_6.png" style="zoom:67%;" />

默认情况下, 即使是核心线程也只能在新任务到达时才创建和启动. 但是我们可以使用 prestartCoreThread(启动一个核心线程)或 prestartAllCoreThreads(启动全部核心线程)方法来提前启动核心线程. 



## 线程池的状态

下面再介绍下线程池的运行状态. 线程池一共有五种状态,  分别是:

* **RUNNING:** 能接受新提交的任务, 并且也能处理阻塞队列中的任务;

* **SHUTDOWN:** 关闭状态,**不再接受新提交的任务, 但却可以继续处理阻塞队列中已保存的任务**.在线程池处于 RUNNING 状态时, 调用**shutdown()** 方法会使线程池进入到该状态.(finalize() 方法在执行过程中也会调用shutdown()方法进入该状态)

* **STOP:** 不能接受新任务, 也不处理队列中的任务, 会中断正在处理任务的线程**.在线程池处于 RUNNING 或 SHUTDOWN 状态时, 调用**shutdownNow()** 方法会使线程池进入到该状态

* **TIDYING:** 如果所有的任务都已终止了, workerCount (有效线程数) 为0, 线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态.

* **TERMINATED:** 在 terminated() 方法执行完后进入该状态, 默认 terminated() 方法中什么也没有做.

    进入 TERMINATED 的条件如下: 
    
    * 线程池不是 RUNNING 状态
    
    * 线程池状态不是 TIDYING 状态或 TERMINATED 状态
    
    * 如果线程池状态是 SHUTDOWN 并且 workerQueue 为空
    
    * workerCount 为 0
    
    * 设置 TIDYING 状态成功

**下图为线程池的状态转换过程:**

<img src="http://www.milky.show/images/thread/executor_3.png" style="zoom:80%;" />



## 常见阻塞队列

ArrayBlockingQueue: 基于数组结构的有界阻塞队列, 按先进先出对元素进行排序. 

LinkedBlockingQueue: 基于链表结构的有界/无界阻塞队列, 按先进先出对元素进行排序, 吞吐量通常高于 ArrayBlockingQueue. Executors.newFixedThreadPool 使用了该队列. 

SynchronousQueue: 不是一个真正的队列, 而是一种在线程之间移交的机制. 要将一个元素放入 SynchronousQueue 中, 必须有另一个线程正在等待接受这个元素. 如果没有线程等待, 并且线程池的当前大小小于最大值, 那么线程池将创建一个线程, 否则根据拒绝策略, 这个任务将被拒绝. 使用直接移交将更高效, 因为任务会直接移交给执行它的线程, 而不是被放在队列中, 然后由工作线程从队列中提取任务. 只有当线程池是无界的或者可以拒绝任务时, 该队列才有实际价值. 

Executors.newCachedThreadPool 使用了该队列. 

PriorityBlockingQueue: 具有优先级的无界队列, 按优先级对元素进行排序. 元素的优先级是通过自然顺序或 Comparator 来定义的. 

**使用有界队列时, 需要注意线程池满了后, 被拒绝的任务如何处理.**

**使用无界队列时, 需要注意如果任务的提交速度大于线程池的处理速度, 可能会导致内存溢出**



## 核心线程怎么实现一直存活

阻塞队列方法有四种形式, 它们以不同的方式处理操作, 如下表. 

|      | 抛出异常  | 返回特殊值 | 一直阻塞 | 超时退出             |
| ---- | --------- | ---------- | -------- | -------------------- |
| 插入 | add(e)    | offer(e)   | put(e)   | offer(e, time, unit) |
| 移除 | remove()  | poll()     | take()   | poll(time, unit)     |
| 检查 | element() | peek()     | 不可用   | 不可用               |

**核心线程在获取任务时, 通过阻塞队列的 take() 方法实现的一直阻塞(存活).**

**原理同上, 也是利用阻塞队列的方法, 在获取任务时通过阻塞队列的 poll(time,unit) 方法实现的在延迟死亡.**



## 非核心线程能成为核心线程吗？

虽然我们一直讲着核心线程和非核心线程, 但是其实线程池内部是不区分核心线程和非核心线程的. 只是根据当前线程池的工作线程数来进行调整, 因此看起来像是有核心线程于非核心线程. 



## 终止线程池的两种方式

shutdown: “温柔"的关闭线程池. 不接受新任务, 但是在关闭前会将之前提交的任务处理完毕. 

shutdownNow: “粗暴”的关闭线程池, 也就是直接关闭线程池, 通过 Thread#interrupt() 方法终止所有线程, 不会等待之前提交的任务执行完毕. 但是会返回队列中未处理的任务. 



## 线程池里 ctl 的作用

ctl 是一个打包两个概念字段的原子整数. 

*   workerCount: 指示线程的有效数量

*   runState: 指示线程池的运行状态, 有 RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED 等状态. 

int 类型有32位, 其中 ctl 的低29为用于表示 workerCount, 高3位用于表示 runState, 如下图所示. 

<img src="http://www.milky.show/images/thread/executor_7.png" style="zoom:50%;" />

例如, 当我们的线程池运行状态为 RUNNING, 工作线程个数为3, 则此时 ctl 的原码为: 1010 0000 0000 0000 0000 0000 0000 0011

个人认为, ctl 这么设计的主要好处是将对 runState 和 workerCount 的操作封装成了一个原子操作. 

runState 和 workerCount 是线程池正常运转中的 2 个最重要属性, 线程池在某一时刻该做什么操作, 取决于这2个属性的值. 

因此无论是查询还是修改, 我们必须保证对这 2 个属性的操作是属于“同一时刻”的, 也就是原子操作, 否则就会出现错乱的情况. 如果我们使用2个变量来分别存储, 要保证原子性则需要额外进行加锁操作, 这显然会带来额外的开销, 而将这2个变量封装成1个 AtomicInteger 则不会带来额外的加锁开销, 而且只需使用简单的位操作就能分别得到 runState 和 workerCount. 

由于这个设计, workerCount 的上限 CAPACITY  = (1 << 29) - 1, 对应的二进制原码为: 0001 1111 1111 1111 1111 1111 1111 1111(不用数了, 29 个 1). 

通过 ctl 得到 runState, 只需通过位操作: ctl & ~CAPACITY. 

~(按位取反), 于是“~CAPACITY”的值为: 1110 0000 0000 0000 0000 0000 0000 0000, 只有高3位为1, 与 ctl 进行 & 操作, 结果为 ctl 高3位的值, 也就是 runState. 

通过 ctl 得到 workerCount 则更简单了, 只需通过位操作: c & CAPACITY. 

**ctl相关方法**

```java
private static int runStateOf(int c)     { return c & ~CAPACITY; }
private static int workerCountOf(int c)  { return c & CAPACITY; }
private static int ctlOf(int rs,  int wc) { return rs | wc; }
```

* **runStateOf:** 获取运行状态

* **workerCountOf:** 获取活动线程数

* **ctlOf:** 获取运行状态和活动线程数的值





## 如何设置线程池数量

要想合理的配置线程池大小, 首先我们需要区分任务是计算密集型还是I/O密集型. 

* CPU 密集型的程序 - 核心数 + 1, 通常能实现最优的利用率. 

* I/O 密集型的程序 - 核心数 * 2, 这个做法是可以的, 但个人觉得不是最优的. 

在我们日常的开发中, 我们的任务几乎是离不开 I/O 的, 常见的网络 I/O(RPC调用)、磁盘 I/O(数据库操作), 并且 I/O 的等待时间通常会占整个任务处理时间的很大一部分, 在这种情况下, 开启更多的线程可以让 CPU 得到更充分的使用, 一个较合理的计算公式如下: 

线程数 = CPU 数 * CPU 利用率 * (任务等待时间 / 任务计算时间 + 1)

例如我们有个定时任务, 部署在 4 核的服务器上, 该任务有 100ms 在计算, 900ms 在 I/O 等待, 则线程数约为: 4* 1* (1 + 900 / 100) = 40个. 

当然, 具体我们还要结合实际的使用场景来考虑. 

1. 高并发、任务执行时间短的业务, 线程池线程数可以设置为CPU核数+1, 减少线程上下文的切换

2. 并发不高、任务执行时间长的业务要区分开看

  * 假如是业务时间长集中在IO操作上, 也就是IO密集型的任务, 因为IO操作并不占用CPU, 所以不要让所有的CPU闲下来, 可以加大线程池中的线程数目, 让CPU处理更多的业务

  * 假如是业务时间长集中在计算操作上, 也就是计算密集型任务, 这个就没办法了, 和（1）一样吧, 线程池中的线程数设置得少一些, 减少线程上下文的切换

3. 并发高、业务执行时间长, 解决这种类型任务的关键不在于线程池而在于整体架构的设计, 看看这些业务里面某些数据是否能做缓存是第一步, 增加服务器是第二步, 至于线程池的设置, 设置参考（2）。最后, 业务执行时间长的问题, 也可能需要分析一下, 看看能不能使用中间件对任务进行拆分和解耦

**如何来设置**

需要根据几个值来决定

* tasks: 每秒的任务数, 假设为500~1000
* taskcost: 每个任务花费时间, 假设为0.1s
* responsetime: 系统允许容忍的最大响应时间, 假设为1s

做几个计算

* corePoolSize = 每秒需要多少个线程处理？ 

* threadcount = tasks/(1/taskcost) =tasks*taskcout =  (500~1000)*0.1 = 50~100 个线程。corePoolSize设置应该大于50

    根据8020原则, 如果80%的每秒任务数小于800, 那么corePoolSize设置为80即可

* queueCapacity = (coreSizePool/taskcost)*responsetime*

    计算可得 queueCapacity = 80/0.1*1 = 80。意思是队列里的线程可以等待1s, 超过了的需要新开线程来执行

    切记不能设置为Integer.MAX_VALUE, 这样队列会很大, 线程数只会保持在corePoolSize大小, 当任务陡增时, 不能新开线程来执行, 响应时间会随之陡增。

* maxPoolSize = (max(tasks)- queueCapacity)/(1/taskcost)（最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数

    计算可得 maxPoolSize = (1000-80)/10 = 92

* rejectedExecutionHandler: 根据具体情况来决定, 任务不重要可丢弃, 任务重要则要利用一些缓冲机制来处理

* keepAliveTime和allowCoreThreadTimeout: 采用默认通常能满足



### 线程数和 CPU 利用率的小测试

抛开一些操作系统, 计算机原理不谈, 说一个基本的理论(不用纠结是否严谨, 只为好理解):**一个CPU核心, 单位时间内只能执行一个线程的指令**

那么理论上, 我一个线程只需要不停的执行指令, 就可以跑满一个核心的利用率. 

来写个死循环空跑的例子验证一下: 

测试环境: AMD Ryzen 5 3600, 6 - Core, 12 - Threads

```java
public class CPUUtilizationTest {
    public static void main(String[] args) {
        //死循环, 什么都不做
        while (true){
        }
    }
}
```

运行这个例子后, 来看看现在CPU的利用率: 

<img src="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_9.png" alt="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_9.png" style="zoom:67%;" />

从图上可以看到, 我的3号核心利用率已经被跑满了

那基于上面的理论, 我多开几个线程试试呢? 

```java
public class CPUUtilizationTest {
    public static void main(String[] args) {

        for (int j = 0; j < 6; j++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    while (true){
                    }
                }
            }).start();
        }
    }
}
```

此时再看CPU利用率, 1/2/5/7/9/11 几个核心的利用率已经被跑满: 

<img src="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_10.png" alt="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_10.png" style="zoom:67%;" />

那如果开12个线程呢, 是不是会把所有核心的利用率都跑满? 答案一定是会的: 

<img src="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_11.png" alt="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_11.png" style="zoom:67%;" />

如果此时我把上面例子的线程数继续增加到 24 个线程, 会出现什么结果呢? 

<img src="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_12.png" alt="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_12.png" style="zoom:67%;" />

从上图可以看到, CPU 利用率和上一步一样, 还是所有核心 100%, 不过此时负载已经从 11.x 增加到了 22.x, 说明此时 CPU 更繁忙, 线程的任务无法及时执行. 

现代 CPU 基本都是多核心的, 比如我这里测试用的 AMD 3600, 6 核心 12 线程(超线程), 我们可以简单的认为它就是12核心CPU. 那么我这个CPU就可以同时做 12 件事, 互不打扰. 

如果要执行的线程大于核心数, 那么就需要通过操作系统的调度了. 操作系统给每个线程分配CPU时间片资源, 然后不停的切换, 从而实现“并行”执行的效果. 

但是这样真的更快吗? 从上面的例子可以看出, 一个线程就可以把一个核心的利用率跑满. 如果每个线程都很“霸道”, 不停的执行指令, 不给CPU空闲的时间, 并且同时执行的线程数大于CPU的核心数, 就会导致操作系统更频繁的执行切换线程执行, 以确保每个线程都可以得到执行. 

不过切换是有代价的, 每次切换会伴随着寄存器数据更新, 内存页表更新等操作. 虽然一次切换的代价和I/O操作比起来微不足道, 但如果线程过多, 线程切换的过于频繁, 甚至在单位时间内切换的耗时已经大于程序执行的时间, 就会导致CPU资源过多的浪费在上下文切换上, 而不是在执行程序, 得不偿失. 

上面死循环空跑的例子, 有点过于极端了, 正常情况下不太可能有这种程序. 

大多程序在运行时都会有一些 I/O 操作, 可能是读写文件, 网络收发报文等, 这些 I/O 操作在进行时时需要等待反馈的. 比如网络读写时, 需要等待报文发送或者接收到, 在这个等待过程中, 线程是等待状态, CPU 没有工作. 此时操作系统就会调度 CPU 去执行其他线程的指令, 这样就完美利用了 CPU 这段空闲期, 提高了 CPU 的利用率. 

上面的例子中, 程序不停的循环什么都不做, CPU 要不停的执行指令, 几乎没有啥空闲的时间. 如果插入一段 I/O 操作呢, I/O 操作期间 CPU 是空闲状态, CPU 的利用率会怎么样呢? 先看看单线程下的结果: 

```java
public class CPUUtilizationTest {
    public static void main(String[] args) throws InterruptedException {

        for (int n = 0; n < 1; n++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    while (true){
                        // 每次空循环 1亿 次后, sleep 50ms, 模拟 I/O 等待、切换
                        for (int i = 0; i < 100_000_000l; i++) {
                        }
                        try {
                            Thread.sleep(50);
                        }
                        catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }).start();
        }
    }
}
```

<img src="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_13.png" alt="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_13.png" style="zoom:67%;" />

哇, 唯一有利用率的 9 号核心, 利用率也才 50%, 和前面没有 sleep 的 100% 相比, 已经低了一半了. 现在把线程数调整到 12 个看看: 

<img src="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_14.png" alt="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_14.png" style="zoom:67%;" />

单个核心的利用率 60 左右, 和刚才的单线程结果差距不大, 还没有把 CPU 利用率跑满, 现在将线程数增加到 18: 

<img src="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_15.png" alt="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_15.png" style="zoom:67%;" />

此时单核心利用率, 已经接近 100% 了. 由此可见, 当线程中有 I/O 等操作不占用CPU资源时, 操作系统可以调度 CPU 可以同时执行更多的线程. 

现在将 I/O 事件的频率调高看看呢, 把循环次数减到一半, 50_000_000, 同样是 18 个线程: 

<img src="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_16.png" alt="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_16.png" style="zoom:67%;" />

此时每个核心的利用率, 大概只有70%左右了. 

### 线程数和 CPU 利用率的小总结

上面的例子, 只是辅助, 为了更好的理解线程数/程序行为/CPU 状态的关系, 来简单总结一下: 

- 一个极端的线程(不停执行“计算”型操作时), 就可以把单个核心的利用率跑满, 多核心CPU最多只能同时执行等于核心数的“极端”线程数
- 如果每个线程都这么“极端”, 且同时执行的线程数超过核心数, 会导致不必要的切换, 造成负载过高, 只会让执行更慢
- I/O 等暂停类操作时, CPU 处于空闲状态, 操作系统调度 CPU 执行其他线程, 可以提高 CPU 利用率, 同时执行更多的线程
- I/O 事件的频率频率越高, 或者等待/暂停时间越长, CPU 的空闲时间也就更长, 利用率越低, 操作系统可以调度 CPU 执行更多的线程

### 线程数规划的公式

前面的铺垫, 都是为了帮助理解, 现在来看看书本上的定义. 《Java 并发编程实战》介绍了一个线程数计算的公式: 

<img src="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_17.png" alt="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_17.png" style="zoom:67%;" />

如果希望程序跑到 CPU 的目标利用率, 需要的线程数公式为: 

<img src="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_18.png" alt="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_18.png" style="zoom:67%;" />

公式很清晰, 现在来带入上面的例子试试看: 

如果我期望目标利用率为90%(多核90), 那么需要的线程数为: 

核心数12 * 利用率0.9 * (1 + 50(sleep时间)/50(循环50_000_000耗时)) ≈ 22

现在把线程数调到 22, 看看结果: 

<img src="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_19.png" alt="http://www.milky.show/images/operatingsystem/cpuaverage/cpu_19.png" style="zoom:67%;" />

现在 CPU 利用率大概 80+, 和预期比较接近了, 由于线程数过多, 还有些上下文切换的开销, 再加上测试用例不够严谨, 所以实际利用率低一些也正常. 

把公式变个形, 还可以通过线程数来计算 CPU 利用率: 

![http://www.milky.show/images/operatingsystem/cpuaverage/cpu_20.png](http://www.milky.show/images/operatingsystem/cpuaverage/cpu_20.png)

线程数22 / (核心数12 * (1 + 50(sleep时间)/50(循环50_000_000耗时))) ≈ 0.9

虽然公式很好, 但在真实的程序中, 一般很难获得准确的等待时间和计算时间, 因为程序很复杂, 不只是“计算”. 一段代码中会有很多的内存读写, 计算, I/O 等复合操作, 精确的获取这两个指标很难, 所以光靠公式计算线程数过于理想化. 

### 真实程序中的线程数

那么在实际的程序中, 或者说一些Java的业务系统中, 线程数(线程池大小)规划多少合适呢? 

**先说结论: 没有固定答案, 先设定预期, 比如我期望的CPU利用率在多少, 负载在多少, GC频率多少之类的指标后, 再通过测试不断的调整到一个合理的线程数**

比如一个普通的, SpringBoot 为基础的业务系统, 默认Tomcat容器+HikariCP连接池+G1回收器, 如果此时项目中也需要一个业务场景的多线程(或者线程池)来异步/并行执行业务流程. 

此时我按照上面的公式来规划线程数的话, 误差一定会很大. 因为此时这台主机上, 已经有很多运行中的线程了, Tomcat有自己的线程池, HikariCP也有自己的后台线程, JVM也有一些编译的线程, 连G1都有自己的后台线程. 这些线程也是运行在当前进程、当前主机上的, 也会占用CPU的资源. 

**所以受环境干扰下, 单靠公式很难准确的规划线程数, 一定要通过测试来验证. **

流程一般是这样: 

1. 分析当前主机上, 有没有其他进程干扰

2. 分析当前JVM进程上, 有没有其他运行中或可能运行的线程

3. 设定目标

4. - 目标CPU利用率 - 我最高能容忍我的CPU飙到多少? 
     - 目标GC频率/暂停时间 - 多线程执行后, GC频率会增高, 最大能容忍到什么频率, 每次暂停时间多少? 
     - 执行效率 - 比如批处理时, 我单位时间内要开多少线程才能及时处理完毕
     - ……

5. 梳理链路关键点, 是否有卡脖子的点, 因为如果线程数过多, 链路上某些节点资源有限可能会导致大量的线程在等待资源(比如三方接口限流, 连接池数量有限, 中间件压力过大无法支撑等)

6. 不断的增加/减少线程数来测试, 按最高的要求去测试, 最终获得一个“满足要求”的线程数**

**而且而且而且！不同场景下的线程数理念也有所不同:**

- Tomcat 中的 maxThreads, 在 Blocking I/O 和 No-Blocking I/O 下就不一样
- Dubbo 默认还是单连接呢, 也有 I/O线程(池)和业务线程(池)的区分, I/O 线程一般不是瓶颈, 所以不必太多, 但业务线程很容易称为瓶颈
- Redis 6.0 以后也是多线程了, 不过它只是 I/O 多线程, “业务”处理还是单线程

**所以, 不要纠结设置多少线程了. 没有标准答案, 一定要结合场景, 带着目标, 通过测试去找到一个最合适的线程数. **

可能还有同学可能会有疑问: “我们系统也没啥压力, 不需要那么合适的线程数, 只是一个简单的异步场景, 不影响系统其他功能就可以”

很正常, 很多的内部业务系统, 并不需要啥性能, 稳定好用符合需求就可以了. 那么我的推荐的线程数是: CPU核心数



### 附录

Java 获取 CPU 核心数

```java
Runtime.getRuntime().availableProcessors() // 获取逻辑核心数, 如6核心12线程, 那么返回的是12
```

Linux 获取 CPU 核心数

```java
# 总核数 = 物理CPU个数 X 每颗物理CPU的核数 
# 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数

# 查看物理CPU个数
cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l

# 查看每个物理CPU中core的个数(即核数)
cat /proc/cpuinfo| grep "cpu cores"| uniq

# 查看逻辑CPU的个数
cat /proc/cpuinfo| grep "processor"| wc -l
```



## 线程池的方法介绍

execute(): 提交任务, 交给线程池执行

submit(): 提交任务, 能够返回执行结果, execute + Future

shutdown(): 关闭线程池, 等待任务都执行完

shutdownNow(): 关闭线程池, 不等待任务执行完成

getTaskCount(): 线程池已执行和未执行的任务总数

getCompletedTaskCount(): 已完成的任务数量

getPoolSize(): 线程池当前的线程数量

getActiveCount(): 当前线程池中正在执行任务的线程数量

**execute 方法**

execute() 方法用来提交任务, 代码如下: 

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
    * clt记录着runState和workerCount
    */
    int c = ctl.get();
    /*
    * workerCountOf方法取出低29位的值, 表示当前活动的线程数;
    * 如果当前活动线程数小于corePoolSize, 则新建一个线程放入线程池中;
    * 并把任务添加到该线程中.
    */
    if (workerCountOf(c) < corePoolSize) {
        /*
        * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断;
        * 如果为true, 根据corePoolSize来判断;
        * 如果为false, 则根据maximumPoolSize来判断
        */
        if (addWorker(command,  true))
            return;
        /*
        * 如果添加失败, 则重新获取ctl值
        */
        c = ctl.get();
    }
    /*
    * 如果当前线程池是运行状态并且任务添加到队列成功
    */
    if (isRunning(c) && workQueue.offer(command)) {
        // 重新获取ctl值
        int recheck = ctl.get();
        // 再次判断线程池的运行状态, 如果不是运行状态, 由于之前已经把command添加到workQueue中了, 
        // 这时需要移除该command
        // 执行过后通过handler使用拒绝策略对该任务进行处理, 整个方法返回
        if (! isRunning(recheck) && remove(command))
            reject(command);
        /*
        * 获取线程池中的有效线程数, 如果数量是0, 则执行addWorker方法
        * 这里传入的参数表示: 
        * 1. 第一个参数为null, 表示在线程池中创建一个线程, 但不去启动;
        * 2. 第二个参数为false, 将线程池的有限线程数量的上限设置为maximumPoolSize, 添加线程时根据maximumPoolSize来判断;
        * 如果判断workerCount大于0, 则直接返回, 在workQueue中新增的command会在将来的某个时刻被执行.
        */
        else if (workerCountOf(recheck) == 0)
            addWorker(null,  false);
    }
    /*
    * 如果执行到这里, 有两种情况: 
    * 1. 线程池已经不是RUNNING状态;
    * 2. 线程池是RUNNING状态, 但workerCount >= corePoolSize并且workQueue已满.
    * 这时, 再次调用addWorker方法, 但第二个参数传入为false, 将线程池的有限线程数量的上限设置为maximumPoolSize;
    * 如果失败则拒绝该任务
    */
    else if (!addWorker(command,  false))
        reject(command);
}
```

简单来说, 在执行 execute() 方法时如果状态一直是 RUNNING 时, 的执行过程如下: 

1. 如果 `workerCount < corePoolSize`, 则创建并启动一个线程来执行新提交的任务;
2. 如果 `workerCount >= corePoolSize`, 且线程池内的阻塞队列未满, 则将任务添加到该阻塞队列中;
3. 如果 `workerCount >= corePoolSize && workerCount < maximumPoolSize`, 且线程池内的阻塞队列已满, 则创建并启动一个线程来执行新提交的任务
4. 如果 `workerCount >= maximumPoolSize`, 并且线程池内的阻塞队列已满,  则根据拒绝策略来处理该任务,  默认的处理方式是直接抛异常.

这里要注意一下 `addWorker(null, false);`, 也就是创建一个线程, 但并没有传入任务, 因为任务已经被添加到 workQueue 中了, 所以 worker 在执行的时候, 会直接从 workQueue 中获取任务.所以, 在 `workerCountOf(recheck) == 0` 时执行 `addWorker(null,  false);` 也是为了保证线程池在 RUNNING状态下必须要有一个线程来执行任务.

execute 方法执行流程如下: 

<img src="http://www.milky.show/images/thread/executor_4.png" alt="http://www.milky.show/images/thread/executor_4.png" style="zoom: 67%;" />

**addWorker 方法**

addWorker 方法的主要工作是在线程池中创建一个新的线程并执行, firstTask 参数 用于指定新增的线程执行的第一个任务, core 参数为 true 表示在新增线程时会判断当前活动线程数是否少于 corePoolSize, false 表示新增线程前需要判断当前活动线程数是否少于 maximumPoolSize, 代码如下: 

```java
private boolean addWorker(Runnable firstTask,  boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        // 获取运行状态
        int rs = runStateOf(c);

        /*
        * 这个if判断
        * 如果rs >= SHUTDOWN, 则表示此时不再接收新任务;
        * 接着判断以下3个条件, 只要有1个不满足, 则返回false: 
        * 1. rs == SHUTDOWN, 这时表示关闭状态, 不再接受新提交的任务, 但却可以继续处理阻塞队列中已保存的任务
        * 2. firsTask为空
        * 3. 阻塞队列不为空
        * 
        * 首先考虑rs == SHUTDOWN的情况
        * 这种情况下不会接受新提交的任务, 所以在firstTask不为空的时候会返回false;
        * 然后, 如果firstTask为空, 并且workQueue也为空, 则返回false, 
        * 因为队列中已经没有任务了, 不需要再添加线程了
        */
        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            // 获取线程数
            int wc = workerCountOf(c);
            // 如果wc超过CAPACITY, 也就是ctl的低29位的最大值(二进制是29个1), 返回false;
            // 这里的core是addWorker方法的第二个参数, 如果为true表示根据corePoolSize来比较, 
            // 如果为false则根据maximumPoolSize来比较.
            // 
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            // 尝试增加workerCount, 如果成功, 则跳出第一个for循环
            if (compareAndIncrementWorkerCount(c))
                break retry;
            // 如果增加workerCount失败, 则重新获取ctl的值
            c = ctl.get();  // Re-read ctl
            // 如果当前的运行状态不等于rs, 说明状态已被改变, 返回第一个for循环继续执行
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 根据firstTask来创建Worker对象
        w = new Worker(firstTask);
        // 每一个Worker对象都会创建一个线程
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());
                // rs < SHUTDOWN表示是RUNNING状态;
                // 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null, 向线程池中添加线程.
                // 因为在SHUTDOWN时不会在添加新的任务, 但还是会执行workQueue中的任务
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    // workers是一个HashSet
                    workers.add(w);
                    int s = workers.size();
                    // largestPoolSize记录着线程池中出现过的最大线程数量
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                // 启动线程
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

注意一下这里的 `t.start()` 这个语句, 启动时会调用 Worker 类中的 run 方法, Worker 本身实现了 Runnable 接口, 所以一个 Worker 类型的对象也是一个线程.

**Worker 类**

线程池中的每一个线程被封装成一个 Worker 对象, ThreadPool 维护的其实就是一组 Worker 对象, 看一下 Worker 的定义: 

```java
private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
{
    /**
    * This class will never be serialized,  but we provide a
    * serialVersionUID to suppress a javac warning.
    */
    private static final long serialVersionUID = 6138294804551838833L;

    /** Thread this worker is running in.  Null if factory fails.*/
    final Thread thread;
    /** Initial task to run.  Possibly null.*/
    Runnable firstTask;
    /** Per-thread task counter*/
    volatile long completedTasks;

    /**
    * Creates with given first task and thread from ThreadFactory.
    * @param firstTask the first task (null if none)
    */
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }

    /** Delegates main run loop to outer runWorker */
    public void run() {
        runWorker(this);
    }

    // Lock methods
    //
    // The value 0 represents the unlocked state.
    // The value 1 represents the locked state.

    protected boolean isHeldExclusively() {
        return getState() != 0;
    }

    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0,  1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }

    void interruptIfStarted() {
        Thread t;
        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
            try {
                t.interrupt();
            } catch (SecurityException ignore) {
            }
        }
    }
}
```

Worker 类继承了 AQS, 并实现了 Runnable 接口, 注意其中的 firstTask 和 thread 属性: firstTask 用它来保存传入的任务; thread 是在调用构造方法时通过ThreadFactory 来创建的线程, 是用来处理任务的线程.

在调用构造方法时, 需要把任务传入, 这里通过 `getThreadFactory().newThread(this);`来新建一个线程, newThread 方法传入的参数是 this, 因为Worker 本身继承了 Runnable 接口, 也就是一个线程, 所以一个 Worker 对象在启动的时候会调用 Worker 类中的 run 方法.

Worker 继承了 AQS, 使用 AQS 来实现独占锁的功能.为什么不使用 ReentrantLock 来实现呢? 可以看到 tryAcquire 方法, 它是不允许重入的, 而ReentrantLock 是允许重入的: 

1. lock 方法一旦获取了独占锁, 表示当前线程正在执行任务中;
2. 如果正在执行任务, 则不应该中断线程;
3. 如果该线程现在不是独占锁的状态, 也就是空闲的状态, 说明它没有在处理任务, 这时可以对该线程进行中断;
4. 线程池在执行 shutdown 方法或 tryTerminate 方法时会调用 interruptIdleWorkers 方法来中断空闲的线程, interruptIdleWorkers 方法会使用 tryLock 方法来判断线程池中的线程是否是空闲状态;
5. 之所以设置为不可重入, 是因为我们不希望任务在调用像 setCorePoolSize 这样的线程池控制方法时重新获取锁. 如果使用 ReentrantLock, 它是可重入的, 这样如果在任务中调用了如 setCorePoolSize 这类线程池控制的方法, 会中断正在运行的线程.

所以, Worker 继承自 AQS, 用于判断线程是否空闲以及是否可以被中断

此外, 在构造方法中执行了 `setState(-1);`, 把 state 变量设置为 -1, 为什么这么做呢? 是因为 AQS 中默认的 state 是 0, 如果刚创建了一个 Worker 对象, 还没有执行任务时, 这时就不应该被中断, 看一下 tryAquire 方法

```java
protected boolean tryAcquire(int unused) {
    if (compareAndSetState(0,  1)) {
        setExclusiveOwnerThread(Thread.currentThread());
        return true;
    }
    return false;
}
```

tryAcquire 方法是根据 state 是否是 0 来判断的, 所以, `setState(-1);`将 state 设置为 -1 是为了禁止在执行任务前对线程进行中断

正因为如此, 在 runWorker 方法中会先调用 Worker 对象的 unlock 方法将 state 设置为 0

**runWorker 方法**

在 Worker 类中的 run 方法调用了 runWorker 方法来执行任务, runWorker 方法的代码如下:

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    // 获取第一个任务
    Runnable task = w.firstTask;
    w.firstTask = null;
    // 允许中断
    w.unlock(); // allow interrupts
    // 是否因为异常退出循环
    boolean completedAbruptly = true;
    try {
        // 如果task为空, 则通过getTask来获取任务
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping,  ensure thread is interrupted;
            // if not,  ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(),  STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(),  STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt,  task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task,  thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w,  completedAbruptly);
    }
}
```

这里说明一下第一个 if 判断, 目的是: 

- 如果线程池正在停止, 那么要保证当前线程是中断状态
- 如果不是的话, 则要保证当前线程不是中断状态

这里要考虑在执行该 if 语句期间可能也执行了 shutdownNow 方法, shutdownNow 方法会把状态设置为 STOP, 回顾一下 STOP 状态:

> 不能接受新任务, 也不处理队列中的任务, 会中断正在处理任务的线程.在线程池处于 RUNNING 或 SHUTDOWN 状态时, 调用 shutdownNow() 方法会使线程池进入到该状态.

STOP 状态要中断线程池中的所有线程, 而这里使用 `Thread.interrupted()` 来判断是否中断是为了确保在 RUNNING 或者 SHUTDOWN 状态时线程是非中断状态的, 因为 Thread.interrupted() 方法会复位中断的状态.

总结一下 runWorker 方法的执行过程: 

1. while 循环不断地通过 getTask() 方法获取任务
2. getTask() 方法从阻塞队列中取任务
3. 如果线程池正在停止, 那么要保证当前线程是中断状态, 否则要保证当前线程不是中断状态
4. 调用 `task.run()` 执行任务
5. 如果 task 为 null 则跳出循环, 执行 processWorkerExit() 方法
6. runWorker 方法执行完毕, 也代表着 Worker 中的 run 方法执行完毕, 销毁线程

这里的 beforeExecute 方法和 afterExecute 方法在 ThreadPoolExecutor 类中是空的, 留给子类来实现

completedAbruptly 变量来表示在执行任务过程中是否出现了异常, 在 processWorkerExit 方法中会对该变量的值进行判断



**getTask 方法**

getTask 方法用来从阻塞队列中取任务, 代码如下:

```java
private Runnable getTask() {
    // timeOut变量的值表示上次从阻塞队列中取任务时是否超时
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        /*
        * 如果线程池状态rs >= SHUTDOWN, 也就是非RUNNING状态, 再进行以下判断: 
        * 1. rs >= STOP, 线程池是否正在stop;
        * 2. 阻塞队列是否为空.
        * 如果以上条件满足, 则将workerCount减1并返回null.
        * 因为如果当前线程池状态的值是SHUTDOWN或以上时, 不允许再向阻塞队列中添加任务.
        */
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        // timed变量用于判断是否需要进行超时控制.
        // allowCoreThreadTimeOut默认是false, 也就是核心线程不允许进行超时;
        // wc > corePoolSize, 表示当前线程池中的线程数量大于核心线程数量;
        // 对于超过核心线程数量的这些线程, 需要进行超时控制
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        /*
        * wc > maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法;
        * timed && timedOut 如果为true, 表示当前操作需要进行超时控制, 并且上次从阻塞队列中获取任务发生了超时
        * 接下来判断, 如果有效线程数量大于1, 或者阻塞队列是空的, 那么尝试将workerCount减1;
        * 如果减1失败, 则返回重试.
        * 如果wc == 1时, 也就说明当前线程是线程池中唯一的一个线程了.
        */
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            /*
            * 根据timed来判断, 如果为true, 则通过阻塞队列的poll方法进行超时控制, 如果在keepAliveTime时间内没有获取到任务, 则返回null;
            * 否则通过take方法, 如果这时队列为空, 则take方法会阻塞直到队列不为空.
            * 
            */
            Runnable r = timed ?
                workQueue.poll(keepAliveTime,  TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            // 如果 r == null, 说明已经超时, timedOut设置为true
            timedOut = true;
        } catch (InterruptedException retry) {
            // 如果获取任务时当前线程发生了中断, 则设置timedOut为false并返回循环重试
            timedOut = false;
        }
    }
}
```

这里重要的地方是第二个if判断, 目的是控制线程池的有效线程数量.由上文中的分析可以知道, 在执行 execute 方法时, 如果当前线程池的线程数量超过了corePoolSize 且小于 maximumPoolSize, 并且 workQueue 已满时, 则可以增加工作线程, 但这时如果超时没有获取到任务, 也就是 timedOut 为 true 的情况, 说明 workQueue 已经为空了, 也就说明了当前线程池中不需要那么多线程来执行任务了, 可以把多于 corePoolSize 数量的线程销毁掉, 保持线程数量在corePoolSize 即可

什么时候会销毁? 当然是 runWorker 方法执行完之后, 也就是 Worker 中的 run 方法执行完, 由 JVM 自动回收

getTask 方法返回 null 时, 在 runWorker 方法中会跳出 while 循环, 然后会执行 processWorkerExit 方法

**processWorkerExit 方法**

```java
private void processWorkerExit(Worker w,  boolean completedAbruptly) {
    // 如果completedAbruptly值为true, 则说明线程执行时出现了异常, 需要将workerCount减1;
    // 如果线程执行时没有出现异常, 说明在getTask()方法中已经已经对workerCount进行了减1操作, 这里就不必再减了. 
    if (completedAbruptly) // If abrupt,  then workerCount wasn't adjusted
        decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 统计完成的任务数
        completedTaskCount += w.completedTasks;
        // 从workers中移除, 也就表示着从线程池中移除了一个工作线程
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }

    // 根据线程池状态进行判断是否结束线程池
    tryTerminate();

    int c = ctl.get();
    /*
    * 当线程池是RUNNING或SHUTDOWN状态时, 如果worker是异常结束, 那么会直接addWorker;
    * 如果allowCoreThreadTimeOut=true, 并且等待队列有任务, 至少保留一个worker;
    * 如果allowCoreThreadTimeOut=false, workerCount不少于corePoolSize.
    */
    if (runStateLessThan(c,  STOP)) {
        if (!completedAbruptly) {
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            if (min == 0 && ! workQueue.isEmpty())
                min = 1;
            if (workerCountOf(c) >= min)
                return; // replacement not needed
        }
        addWorker(null,  false);
    }
}
```

至此, processWorkerExit 执行完之后, 工作线程被销毁, 以上就是整个工作线程的生命周期, 从 execute 方法开始, Worker 使用 ThreadFactory 创建新的工作线程, runWorker 通过 getTask 获取任务, 然后执行任务, 如果 getTask 返回 null, 进入 processWorkerExit 方法, 整个线程结束, 如图所示: 

<img src="http://www.milky.show/images/thread/executor_5.png" alt="http://www.milky.show/images/thread/executor_5.png" style="zoom:67%;" />

**tryTerminate 方法**

tryTerminate 方法根据线程池状态进行判断是否结束线程池, 代码如下:

```java
final void tryTerminate() {
    for (;;) {
        int c = ctl.get();
        /*
        * 当前线程池的状态为以下几种情况时, 直接返回: 
        * 1. RUNNING, 因为还在运行中, 不能停止;
        * 2. TIDYING或TERMINATED, 因为线程池中已经没有正在运行的线程了;
        * 3. SHUTDOWN并且等待队列非空, 这时要执行完workQueue中的task;
        */
        if (isRunning(c) ||
            runStateAtLeast(c,  TIDYING) ||
            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))
            return;
        // 如果线程数量不为0, 则中断一个空闲的工作线程, 并返回
        if (workerCountOf(c) != 0) { // Eligible to terminate
            interruptIdleWorkers(ONLY_ONE);
            return;
        }

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 这里尝试设置状态为TIDYING, 如果设置成功, 则调用terminated方法
            if (ctl.compareAndSet(c,  ctlOf(TIDYING,  0))) {
                try {
                    // terminated方法默认什么都不做, 留给子类实现
                    terminated();
                } finally {
                    // 设置状态为TERMINATED
                    ctl.set(ctlOf(TERMINATED,  0));
                    termination.signalAll();
                }
                return;
            }
        } finally {
            mainLock.unlock();
        }
        // else retry on failed CAS
    }
}
```

**shutdown 方法**

shutdown 方法要将线程池切换到 SHUTDOWN 状态, 并调用 interruptIdleWorkers 方法请求中断所有空闲的 worker, 最后调用 tryTerminate 尝试结束线程池

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 安全策略判断
        checkShutdownAccess();
        // 切换状态为SHUTDOWN
        advanceRunState(SHUTDOWN);
        // 中断空闲线程
        interruptIdleWorkers();
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    // 尝试结束线程池
    tryTerminate();
}
```

这里思考一个问题: 在 runWorker 方法中, 执行任务时对 Worke r对象 w 进行了 lock 操作, 为什么要在执行任务的时候对每个工作线程都加锁呢?

下面仔细分析一下: 

- 在 getTask 方法中, 如果这时线程池的状态是 SHUTDOWN 并且 workQueue 为空, 那么就应该返回 null 来结束这个工作线程, 而使线程池进入SHUTDOWN 状态需要调用 shutdown 方法
- shutdown 方法会调用 interruptIdleWorkers 来中断空闲的线程, interruptIdleWorkers 持有 mainLock, 会遍历 workers 来逐个判断工作线程是否空闲.但 getTask 方法中没有 mainLock
- 在 getTask 中, 如果判断当前线程池状态是 RUNNING, 并且阻塞队列为空, 那么会调用 `workQueue.take()` 进行阻塞
- 如果在判断当前线程池状态是 RUNNING 后, 这时调用了 shutdown 方法把状态改为了 SHUTDOWN, 这时如果不进行中断, 那么当前的工作线程在调用了 `workQueue.take()` 后会一直阻塞而不会被销毁, 因为在 SHUTDOWN 状态下不允许再有新的任务添加到 workQueue 中, 这样一来线程池永远都关闭不了了
- 由上可知, shutdown 方法与 getTask 方法(从队列中获取任务时)存在竞态条件
- 解决这一问题就需要用到线程的中断, 也就是为什么要用 interruptIdleWorkers 方法.在调用 `workQueue.take()` 时, 如果发现当前线程在执行之前或者执行期间是中断状态, 则会抛出 InterruptedException, 解除阻塞的状态
- 但是要中断工作线程, 还要判断工作线程是否是空闲的, 如果工作线程正在处理任务, 就不应该发生中断;
- 所以 Worker 继承自 AQS, 在工作线程处理任务时会进行 lock, interruptIdleWorkers 在进行中断时会使用 tryLock 来判断该工作线程是否正在处理任务, 如果 tryLock 返回 true, 说明该工作线程当前未执行任务, 这时才可以被中断.

下面就来分析一下 interruptIdleWorkers 方法.

**interruptIdleWorkers 方法**

```java
private void interruptIdleWorkers() {
    interruptIdleWorkers(false);
}

private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers) {
            Thread t = w.thread;
            if (!t.isInterrupted() && w.tryLock()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
```

interruptIdleWorkers 遍历 workers 中所有的工作线程, 若线程没有被中断 tryLock 成功, 就中断该线程.

为什么需要持有 mainLock? 因为 workers 是 HashSet 类型的, 不能保证线程安全.

**shutdownNow 方法**

```java
public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(STOP);
        // 中断所有工作线程,无论是否空闲
        interruptWorkers();
        // 取出队列中没有被执行的任务
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
```

shutdownNow 方法与 shutdown 方法类似, 不同的地方在于: 

1. 设置状态为 STOP

2. 中断所有工作线程, 无论是否是空闲的

3. 取出阻塞队列中没有被执行的任务并返回

shutdownNow 方法执行完之后调用 tryTerminate 方法, 该方法在上文已经分析过了, 目的就是使线程池的状态设置为 TERMINATED

## 线程池的监控

通过线程池提供的参数进行监控.线程池里有一些属性在监控线程池的时候可以使用

- **getTaskCount**: 线程池已经执行的和未执行的任务总数
- **getCompletedTaskCount**: 线程池已完成的任务数量, 该值小于等于 taskCount
- **getLargestPoolSize**: 线程池曾经创建过的最大线程数量. 通过这个数据可以知道线程池是否满过, 也就是达到了 maximumPoolSize
- **getPoolSize**: 线程池当前的线程数量
- **getActiveCount**: 当前线程池中正在执行任务的线程数量

通过这些方法, 可以对线程池进行监控, 在 ThreadPoolExecutor 类中提供了几个空方法, 如 beforeExecute 方法, afterExecute 方法和 terminated 方法, 可以扩展这些方法在执行前或执行后增加一些新的操作, 例如统计线程池的执行任务的时间等, 可以继承自 ThreadPoolExecutor 来进行扩展.





## 常见面试问题

Q. 线程池是什么时候创建线程的？

*A.任务提交的时候*

Q.任务runnable task是先放到core到maxThread之间的线程, 还是先放到队列？

*A.先放队列!!!*

Q. 队列中的任务是什么时候取出来的？

A. worker中 runWorker() 一个任务完成后, 会取下一个任务

Q. 什么时候会触发reject策略？

A.队列满并且maxthread也满了,  还有新任务, 默认策略是reject

Q. core到maxThread之间的线程什么时候会die?

A. 没有任务时, 或者抛异常时。  

  core线程也会die的, core到maxThread之间的线程有可能会晋升到core线程区间, 

  core max只是个计数, 线程并不是创建后就固定在一个区间了

Q. task抛出异常, 线程池中这个work thread还能运行其他任务吗?

A. 不能。 但是会创建新的线程, 新线程可以运行其他task。

对于 schedulerThreadPoolExecutor?  虽然有新线程, 但是旧的循环任务不会再继续执行了,  开发实践推荐任务中捕获所有Exception

[线程池分析](https://www.cnblogs.com/yszzu/p/10122658.html)